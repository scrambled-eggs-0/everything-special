"use strict";(self.webpackChunkomniserver=self.webpackChunkomniserver||[]).push([[417],{417:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nlet noise = {};\r\n\r\nfunction Grad(x, y, z) {\r\n    this.x = x; this.y = y; this.z = z;\r\n}\r\n\r\nGrad.prototype.dot2 = function (x, y) {\r\n    return this.x * x + this.y * y;\r\n};\r\n\r\nGrad.prototype.dot3 = function (x, y, z) {\r\n    return this.x * x + this.y * y + this.z * z;\r\n};\r\n\r\nlet grad3 = [new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0),\r\nnew Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1),\r\nnew Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1)];\r\n\r\nlet p = [151, 160, 137, 91, 90, 15,\r\n    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\r\n    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\r\n    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\r\n    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\r\n    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\r\n    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\r\n    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\r\n    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\r\n    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\r\n    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\r\n    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\r\n    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];\r\n// To remove the need for index wrapping, double the permutation table length\r\nlet perm = new Array(512);\r\nlet gradP = new Array(512);\r\n\r\n// This isn't a very good seeding function, but it works ok. It supports 2^16\r\n// different seed values. Write something better if you need more seeds.\r\nnoise.seed = function (seed) {\r\n    if (seed > 0 && seed < 1) {\r\n        // Scale the seed out\r\n        seed *= 65536;\r\n    }\r\n\r\n    seed = Math.floor(seed);\r\n    if (seed < 256) {\r\n        seed |= seed << 8;\r\n    }\r\n\r\n    for (let i = 0; i < 256; i++) {\r\n        let v;\r\n        if (i & 1) {\r\n            v = p[i] ^ (seed & 255);\r\n        } else {\r\n            v = p[i] ^ ((seed >> 8) & 255);\r\n        }\r\n\r\n        perm[i] = perm[i + 256] = v;\r\n        gradP[i] = gradP[i + 256] = grad3[v % 12];\r\n    }\r\n};\r\n\r\nnoise.seed(0.69420);\r\n\r\n// Skewing and unskewing factors for 2, 3, and 4 dimensions\r\nconst F2 = 0.5 * (Math.sqrt(3) - 1);\r\nconst G2 = (3 - Math.sqrt(3)) / 6;\r\n\r\nconst F3 = 1 / 3;\r\nconst G3 = 1 / 6;\r\n\r\n// 2D simplex noise\r\nnoise.simplex2 = function (xin, yin) {\r\n    let n0, n1, n2; // Noise contributions from the three corners\r\n    // Skew the input space to determine which simplex cell we're in\r\n    let s = (xin + yin) * F2; // Hairy factor for 2D\r\n    let i = Math.floor(xin + s);\r\n    let j = Math.floor(yin + s);\r\n    let t = (i + j) * G2;\r\n    let x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\r\n    let y0 = yin - j + t;\r\n    // For the 2D case, the simplex shape is an equilateral triangle.\r\n    // Determine which simplex we are in.\r\n    let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\r\n    if (x0 > y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)\r\n        i1 = 1; j1 = 0;\r\n    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\r\n        i1 = 0; j1 = 1;\r\n    }\r\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\r\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\r\n    // c = (3-sqrt(3))/6\r\n    let x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\r\n    let y1 = y0 - j1 + G2;\r\n    let x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords\r\n    let y2 = y0 - 1 + 2 * G2;\r\n    // Work out the hashed gradient indices of the three simplex corners\r\n    i &= 255;\r\n    j &= 255;\r\n    let gi0 = gradP[i + perm[j]];\r\n    let gi1 = gradP[i + i1 + perm[j + j1]];\r\n    let gi2 = gradP[i + 1 + perm[j + 1]];\r\n    // Calculate the contribution from the three corners\r\n    let t0 = 0.5 - x0 * x0 - y0 * y0;\r\n    if (t0 < 0) {\r\n        n0 = 0;\r\n    } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient\r\n    }\r\n    let t1 = 0.5 - x1 * x1 - y1 * y1;\r\n    if (t1 < 0) {\r\n        n1 = 0;\r\n    } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot2(x1, y1);\r\n    }\r\n    let t2 = 0.5 - x2 * x2 - y2 * y2;\r\n    if (t2 < 0) {\r\n        n2 = 0;\r\n    } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot2(x2, y2);\r\n    }\r\n    // Add contributions from each corner to get the final noise value.\r\n    // The result is scaled to return values in the interval [-1,1].\r\n    return 70 * (n0 + n1 + n2);\r\n};\r\n\r\n// 3D simplex noise\r\nnoise.simplex3 = function (xin, yin, zin) {\r\n    let n0, n1, n2, n3; // Noise contributions from the four corners\r\n\r\n    // Skew the input space to determine which simplex cell we're in\r\n    let s = (xin + yin + zin) * F3; // Hairy factor for 2D\r\n    let i = Math.floor(xin + s);\r\n    let j = Math.floor(yin + s);\r\n    let k = Math.floor(zin + s);\r\n\r\n    let t = (i + j + k) * G3;\r\n    let x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.\r\n    let y0 = yin - j + t;\r\n    let z0 = zin - k + t;\r\n\r\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\r\n    // Determine which simplex we are in.\r\n    let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\r\n    let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\r\n    if (x0 >= y0) {\r\n        if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }\r\n        else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }\r\n        else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }\r\n    } else {\r\n        if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }\r\n        else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }\r\n        else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }\r\n    }\r\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\r\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\r\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\r\n    // c = 1/6.\r\n    let x1 = x0 - i1 + G3; // Offsets for second corner\r\n    let y1 = y0 - j1 + G3;\r\n    let z1 = z0 - k1 + G3;\r\n\r\n    let x2 = x0 - i2 + 2 * G3; // Offsets for third corner\r\n    let y2 = y0 - j2 + 2 * G3;\r\n    let z2 = z0 - k2 + 2 * G3;\r\n\r\n    let x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner\r\n    let y3 = y0 - 1 + 3 * G3;\r\n    let z3 = z0 - 1 + 3 * G3;\r\n\r\n    // Work out the hashed gradient indices of the four simplex corners\r\n    i &= 255;\r\n    j &= 255;\r\n    k &= 255;\r\n    let gi0 = gradP[i + perm[j + perm[k]]];\r\n    let gi1 = gradP[i + i1 + perm[j + j1 + perm[k + k1]]];\r\n    let gi2 = gradP[i + i2 + perm[j + j2 + perm[k + k2]]];\r\n    let gi3 = gradP[i + 1 + perm[j + 1 + perm[k + 1]]];\r\n\r\n    // Calculate the contribution from the four corners\r\n    let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\r\n    if (t0 < 0) {\r\n        n0 = 0;\r\n    } else {\r\n        t0 *= t0;\r\n        n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient\r\n    }\r\n    let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\r\n    if (t1 < 0) {\r\n        n1 = 0;\r\n    } else {\r\n        t1 *= t1;\r\n        n1 = t1 * t1 * gi1.dot3(x1, y1, z1);\r\n    }\r\n    let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\r\n    if (t2 < 0) {\r\n        n2 = 0;\r\n    } else {\r\n        t2 *= t2;\r\n        n2 = t2 * t2 * gi2.dot3(x2, y2, z2);\r\n    }\r\n    let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\r\n    if (t3 < 0) {\r\n        n3 = 0;\r\n    } else {\r\n        t3 *= t3;\r\n        n3 = t3 * t3 * gi3.dot3(x3, y3, z3);\r\n    }\r\n    // Add contributions from each corner to get the final noise value.\r\n    // The result is scaled to return values in the interval [-1,1].\r\n    return 32 * (n0 + n1 + n2 + n3);\r\n\r\n};\r\n\r\n// ##### Perlin noise stuff\r\n\r\nfunction fade(t) {\r\n    return t * t * t * (t * (t * 6 - 15) + 10);\r\n}\r\n\r\nfunction lerp(a, b, t) {\r\n    return (1 - t) * a + t * b;\r\n}\r\n\r\n// 2D Perlin Noise\r\nnoise.perlin2 = function (x, y) {\r\n    // Find unit grid cell containing point\r\n    let X = Math.floor(x), Y = Math.floor(y);\r\n    // Get relative xy coordinates of point within that cell\r\n    x = x - X; y = y - Y;\r\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n    X = X & 255; Y = Y & 255;\r\n\r\n    // Calculate noise contributions from each of the four corners\r\n    let n00 = gradP[X + perm[Y]].dot2(x, y);\r\n    let n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);\r\n    let n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);\r\n    let n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);\r\n\r\n    // Compute the fade curve value for x\r\n    let u = fade(x);\r\n\r\n    // Interpolate the four results\r\n    return lerp(\r\n        lerp(n00, n10, u),\r\n        lerp(n01, n11, u),\r\n        fade(y));\r\n};\r\n\r\n// 3D Perlin Noise\r\nnoise.perlin3 = function (x, y, z) {\r\n    // Find unit grid cell containing point\r\n    let X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);\r\n    // Get relative xyz coordinates of point within that cell\r\n    x = x - X; y = y - Y; z = z - Z;\r\n    // Wrap the integer cells at 255 (smaller integer period can be introduced here)\r\n    X = X & 255; Y = Y & 255; Z = Z & 255;\r\n\r\n    // Calculate noise contributions from each of the eight corners\r\n    let n000 = gradP[X + perm[Y + perm[Z]]].dot3(x, y, z);\r\n    let n001 = gradP[X + perm[Y + perm[Z + 1]]].dot3(x, y, z - 1);\r\n    let n010 = gradP[X + perm[Y + 1 + perm[Z]]].dot3(x, y - 1, z);\r\n    let n011 = gradP[X + perm[Y + 1 + perm[Z + 1]]].dot3(x, y - 1, z - 1);\r\n    let n100 = gradP[X + 1 + perm[Y + perm[Z]]].dot3(x - 1, y, z);\r\n    let n101 = gradP[X + 1 + perm[Y + perm[Z + 1]]].dot3(x - 1, y, z - 1);\r\n    let n110 = gradP[X + 1 + perm[Y + 1 + perm[Z]]].dot3(x - 1, y - 1, z);\r\n    let n111 = gradP[X + 1 + perm[Y + 1 + perm[Z + 1]]].dot3(x - 1, y - 1, z - 1);\r\n\r\n    // Compute the fade curve value for x, y, z\r\n    let u = fade(x);\r\n    let v = fade(y);\r\n    let w = fade(z);\r\n\r\n    // Interpolate\r\n    return lerp(\r\n        lerp(\r\n            lerp(n000, n100, u),\r\n            lerp(n001, n101, u), w),\r\n        lerp(\r\n            lerp(n010, n110, u),\r\n            lerp(n011, n111, u), w),\r\n        v);\r\n};\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (noise);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb21uaXNlcnZlci8uL2VYY2xpZW50L2V4dHJhcy9ub2lzZS5qcz9lZDNmIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBub2lzZSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gR3JhZCh4LCB5LCB6KSB7XHJcbiAgICB0aGlzLnggPSB4OyB0aGlzLnkgPSB5OyB0aGlzLnogPSB6O1xyXG59XHJcblxyXG5HcmFkLnByb3RvdHlwZS5kb3QyID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLnggKiB4ICsgdGhpcy55ICogeTtcclxufTtcclxuXHJcbkdyYWQucHJvdG90eXBlLmRvdDMgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xyXG4gICAgcmV0dXJuIHRoaXMueCAqIHggKyB0aGlzLnkgKiB5ICsgdGhpcy56ICogejtcclxufTtcclxuXHJcbmxldCBncmFkMyA9IFtuZXcgR3JhZCgxLCAxLCAwKSwgbmV3IEdyYWQoLTEsIDEsIDApLCBuZXcgR3JhZCgxLCAtMSwgMCksIG5ldyBHcmFkKC0xLCAtMSwgMCksXHJcbm5ldyBHcmFkKDEsIDAsIDEpLCBuZXcgR3JhZCgtMSwgMCwgMSksIG5ldyBHcmFkKDEsIDAsIC0xKSwgbmV3IEdyYWQoLTEsIDAsIC0xKSxcclxubmV3IEdyYWQoMCwgMSwgMSksIG5ldyBHcmFkKDAsIC0xLCAxKSwgbmV3IEdyYWQoMCwgMSwgLTEpLCBuZXcgR3JhZCgwLCAtMSwgLTEpXTtcclxuXHJcbmxldCBwID0gWzE1MSwgMTYwLCAxMzcsIDkxLCA5MCwgMTUsXHJcbiAgICAxMzEsIDEzLCAyMDEsIDk1LCA5NiwgNTMsIDE5NCwgMjMzLCA3LCAyMjUsIDE0MCwgMzYsIDEwMywgMzAsIDY5LCAxNDIsIDgsIDk5LCAzNywgMjQwLCAyMSwgMTAsIDIzLFxyXG4gICAgMTkwLCA2LCAxNDgsIDI0NywgMTIwLCAyMzQsIDc1LCAwLCAyNiwgMTk3LCA2MiwgOTQsIDI1MiwgMjE5LCAyMDMsIDExNywgMzUsIDExLCAzMiwgNTcsIDE3NywgMzMsXHJcbiAgICA4OCwgMjM3LCAxNDksIDU2LCA4NywgMTc0LCAyMCwgMTI1LCAxMzYsIDE3MSwgMTY4LCA2OCwgMTc1LCA3NCwgMTY1LCA3MSwgMTM0LCAxMzksIDQ4LCAyNywgMTY2LFxyXG4gICAgNzcsIDE0NiwgMTU4LCAyMzEsIDgzLCAxMTEsIDIyOSwgMTIyLCA2MCwgMjExLCAxMzMsIDIzMCwgMjIwLCAxMDUsIDkyLCA0MSwgNTUsIDQ2LCAyNDUsIDQwLCAyNDQsXHJcbiAgICAxMDIsIDE0MywgNTQsIDY1LCAyNSwgNjMsIDE2MSwgMSwgMjE2LCA4MCwgNzMsIDIwOSwgNzYsIDEzMiwgMTg3LCAyMDgsIDg5LCAxOCwgMTY5LCAyMDAsIDE5NixcclxuICAgIDEzNSwgMTMwLCAxMTYsIDE4OCwgMTU5LCA4NiwgMTY0LCAxMDAsIDEwOSwgMTk4LCAxNzMsIDE4NiwgMywgNjQsIDUyLCAyMTcsIDIyNiwgMjUwLCAxMjQsIDEyMyxcclxuICAgIDUsIDIwMiwgMzgsIDE0NywgMTE4LCAxMjYsIDI1NSwgODIsIDg1LCAyMTIsIDIwNywgMjA2LCA1OSwgMjI3LCA0NywgMTYsIDU4LCAxNywgMTgyLCAxODksIDI4LCA0MixcclxuICAgIDIyMywgMTgzLCAxNzAsIDIxMywgMTE5LCAyNDgsIDE1MiwgMiwgNDQsIDE1NCwgMTYzLCA3MCwgMjIxLCAxNTMsIDEwMSwgMTU1LCAxNjcsIDQzLCAxNzIsIDksXHJcbiAgICAxMjksIDIyLCAzOSwgMjUzLCAxOSwgOTgsIDEwOCwgMTEwLCA3OSwgMTEzLCAyMjQsIDIzMiwgMTc4LCAxODUsIDExMiwgMTA0LCAyMTgsIDI0NiwgOTcsIDIyOCxcclxuICAgIDI1MSwgMzQsIDI0MiwgMTkzLCAyMzgsIDIxMCwgMTQ0LCAxMiwgMTkxLCAxNzksIDE2MiwgMjQxLCA4MSwgNTEsIDE0NSwgMjM1LCAyNDksIDE0LCAyMzksIDEwNyxcclxuICAgIDQ5LCAxOTIsIDIxNCwgMzEsIDE4MSwgMTk5LCAxMDYsIDE1NywgMTg0LCA4NCwgMjA0LCAxNzYsIDExNSwgMTIxLCA1MCwgNDUsIDEyNywgNCwgMTUwLCAyNTQsXHJcbiAgICAxMzgsIDIzNiwgMjA1LCA5MywgMjIyLCAxMTQsIDY3LCAyOSwgMjQsIDcyLCAyNDMsIDE0MSwgMTI4LCAxOTUsIDc4LCA2NiwgMjE1LCA2MSwgMTU2LCAxODBdO1xyXG4vLyBUbyByZW1vdmUgdGhlIG5lZWQgZm9yIGluZGV4IHdyYXBwaW5nLCBkb3VibGUgdGhlIHBlcm11dGF0aW9uIHRhYmxlIGxlbmd0aFxyXG5sZXQgcGVybSA9IG5ldyBBcnJheSg1MTIpO1xyXG5sZXQgZ3JhZFAgPSBuZXcgQXJyYXkoNTEyKTtcclxuXHJcbi8vIFRoaXMgaXNuJ3QgYSB2ZXJ5IGdvb2Qgc2VlZGluZyBmdW5jdGlvbiwgYnV0IGl0IHdvcmtzIG9rLiBJdCBzdXBwb3J0cyAyXjE2XHJcbi8vIGRpZmZlcmVudCBzZWVkIHZhbHVlcy4gV3JpdGUgc29tZXRoaW5nIGJldHRlciBpZiB5b3UgbmVlZCBtb3JlIHNlZWRzLlxyXG5ub2lzZS5zZWVkID0gZnVuY3Rpb24gKHNlZWQpIHtcclxuICAgIGlmIChzZWVkID4gMCAmJiBzZWVkIDwgMSkge1xyXG4gICAgICAgIC8vIFNjYWxlIHRoZSBzZWVkIG91dFxyXG4gICAgICAgIHNlZWQgKj0gNjU1MzY7XHJcbiAgICB9XHJcblxyXG4gICAgc2VlZCA9IE1hdGguZmxvb3Ioc2VlZCk7XHJcbiAgICBpZiAoc2VlZCA8IDI1Nikge1xyXG4gICAgICAgIHNlZWQgfD0gc2VlZCA8PCA4O1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgICBsZXQgdjtcclxuICAgICAgICBpZiAoaSAmIDEpIHtcclxuICAgICAgICAgICAgdiA9IHBbaV0gXiAoc2VlZCAmIDI1NSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdiA9IHBbaV0gXiAoKHNlZWQgPj4gOCkgJiAyNTUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGVybVtpXSA9IHBlcm1baSArIDI1Nl0gPSB2O1xyXG4gICAgICAgIGdyYWRQW2ldID0gZ3JhZFBbaSArIDI1Nl0gPSBncmFkM1t2ICUgMTJdO1xyXG4gICAgfVxyXG59O1xyXG5cclxubm9pc2Uuc2VlZCgwLjY5NDIwKTtcclxuXHJcbi8vIFNrZXdpbmcgYW5kIHVuc2tld2luZyBmYWN0b3JzIGZvciAyLCAzLCBhbmQgNCBkaW1lbnNpb25zXHJcbmNvbnN0IEYyID0gMC41ICogKE1hdGguc3FydCgzKSAtIDEpO1xyXG5jb25zdCBHMiA9ICgzIC0gTWF0aC5zcXJ0KDMpKSAvIDY7XHJcblxyXG5jb25zdCBGMyA9IDEgLyAzO1xyXG5jb25zdCBHMyA9IDEgLyA2O1xyXG5cclxuLy8gMkQgc2ltcGxleCBub2lzZVxyXG5ub2lzZS5zaW1wbGV4MiA9IGZ1bmN0aW9uICh4aW4sIHlpbikge1xyXG4gICAgbGV0IG4wLCBuMSwgbjI7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xyXG4gICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxyXG4gICAgbGV0IHMgPSAoeGluICsgeWluKSAqIEYyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXHJcbiAgICBsZXQgaSA9IE1hdGguZmxvb3IoeGluICsgcyk7XHJcbiAgICBsZXQgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XHJcbiAgICBsZXQgdCA9IChpICsgaikgKiBHMjtcclxuICAgIGxldCB4MCA9IHhpbiAtIGkgKyB0OyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpbiwgdW5za2V3ZWQuXHJcbiAgICBsZXQgeTAgPSB5aW4gLSBqICsgdDtcclxuICAgIC8vIEZvciB0aGUgMkQgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXHJcbiAgICBsZXQgaTEsIGoxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaikgY29vcmRzXHJcbiAgICBpZiAoeDAgPiB5MCkgeyAvLyBsb3dlciB0cmlhbmdsZSwgWFkgb3JkZXI6ICgwLDApLT4oMSwwKS0+KDEsMSlcclxuICAgICAgICBpMSA9IDE7IGoxID0gMDtcclxuICAgIH0gZWxzZSB7ICAgIC8vIHVwcGVyIHRyaWFuZ2xlLCBZWCBvcmRlcjogKDAsMCktPigwLDEpLT4oMSwxKVxyXG4gICAgICAgIGkxID0gMDsgajEgPSAxO1xyXG4gICAgfVxyXG4gICAgLy8gQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBpbiAoeCx5KSwgYW5kXHJcbiAgICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxyXG4gICAgLy8gYyA9ICgzLXNxcnQoMykpLzZcclxuICAgIGxldCB4MSA9IHgwIC0gaTEgKyBHMjsgLy8gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcclxuICAgIGxldCB5MSA9IHkwIC0gajEgKyBHMjtcclxuICAgIGxldCB4MiA9IHgwIC0gMSArIDIgKiBHMjsgLy8gT2Zmc2V0cyBmb3IgbGFzdCBjb3JuZXIgaW4gKHgseSkgdW5za2V3ZWQgY29vcmRzXHJcbiAgICBsZXQgeTIgPSB5MCAtIDEgKyAyICogRzI7XHJcbiAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVyc1xyXG4gICAgaSAmPSAyNTU7XHJcbiAgICBqICY9IDI1NTtcclxuICAgIGxldCBnaTAgPSBncmFkUFtpICsgcGVybVtqXV07XHJcbiAgICBsZXQgZ2kxID0gZ3JhZFBbaSArIGkxICsgcGVybVtqICsgajFdXTtcclxuICAgIGxldCBnaTIgPSBncmFkUFtpICsgMSArIHBlcm1baiArIDFdXTtcclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcclxuICAgIGxldCB0MCA9IDAuNSAtIHgwICogeDAgLSB5MCAqIHkwO1xyXG4gICAgaWYgKHQwIDwgMCkge1xyXG4gICAgICAgIG4wID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdDAgKj0gdDA7XHJcbiAgICAgICAgbjAgPSB0MCAqIHQwICogZ2kwLmRvdDIoeDAsIHkwKTsgIC8vICh4LHkpIG9mIGdyYWQzIHVzZWQgZm9yIDJEIGdyYWRpZW50XHJcbiAgICB9XHJcbiAgICBsZXQgdDEgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MTtcclxuICAgIGlmICh0MSA8IDApIHtcclxuICAgICAgICBuMSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHQxICo9IHQxO1xyXG4gICAgICAgIG4xID0gdDEgKiB0MSAqIGdpMS5kb3QyKHgxLCB5MSk7XHJcbiAgICB9XHJcbiAgICBsZXQgdDIgPSAwLjUgLSB4MiAqIHgyIC0geTIgKiB5MjtcclxuICAgIGlmICh0MiA8IDApIHtcclxuICAgICAgICBuMiA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHQyICo9IHQyO1xyXG4gICAgICAgIG4yID0gdDIgKiB0MiAqIGdpMi5kb3QyKHgyLCB5Mik7XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXHJcbiAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byByZXR1cm4gdmFsdWVzIGluIHRoZSBpbnRlcnZhbCBbLTEsMV0uXHJcbiAgICByZXR1cm4gNzAgKiAobjAgKyBuMSArIG4yKTtcclxufTtcclxuXHJcbi8vIDNEIHNpbXBsZXggbm9pc2Vcclxubm9pc2Uuc2ltcGxleDMgPSBmdW5jdGlvbiAoeGluLCB5aW4sIHppbikge1xyXG4gICAgbGV0IG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xyXG5cclxuICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cclxuICAgIGxldCBzID0gKHhpbiArIHlpbiArIHppbikgKiBGMzsgLy8gSGFpcnkgZmFjdG9yIGZvciAyRFxyXG4gICAgbGV0IGkgPSBNYXRoLmZsb29yKHhpbiArIHMpO1xyXG4gICAgbGV0IGogPSBNYXRoLmZsb29yKHlpbiArIHMpO1xyXG4gICAgbGV0IGsgPSBNYXRoLmZsb29yKHppbiArIHMpO1xyXG5cclxuICAgIGxldCB0ID0gKGkgKyBqICsgaykgKiBHMztcclxuICAgIGxldCB4MCA9IHhpbiAtIGkgKyB0OyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpbiwgdW5za2V3ZWQuXHJcbiAgICBsZXQgeTAgPSB5aW4gLSBqICsgdDtcclxuICAgIGxldCB6MCA9IHppbiAtIGsgKyB0O1xyXG5cclxuICAgIC8vIEZvciB0aGUgM0QgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYSBzbGlnaHRseSBpcnJlZ3VsYXIgdGV0cmFoZWRyb24uXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXHJcbiAgICBsZXQgaTEsIGoxLCBrMTsgLy8gT2Zmc2V0cyBmb3Igc2Vjb25kIGNvcm5lciBvZiBzaW1wbGV4IGluIChpLGosaykgY29vcmRzXHJcbiAgICBsZXQgaTIsIGoyLCBrMjsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcclxuICAgIGlmICh4MCA+PSB5MCkge1xyXG4gICAgICAgIGlmICh5MCA+PSB6MCkgeyBpMSA9IDE7IGoxID0gMDsgazEgPSAwOyBpMiA9IDE7IGoyID0gMTsgazIgPSAwOyB9XHJcbiAgICAgICAgZWxzZSBpZiAoeDAgPj0gejApIHsgaTEgPSAxOyBqMSA9IDA7IGsxID0gMDsgaTIgPSAxOyBqMiA9IDA7IGsyID0gMTsgfVxyXG4gICAgICAgIGVsc2UgeyBpMSA9IDA7IGoxID0gMDsgazEgPSAxOyBpMiA9IDE7IGoyID0gMDsgazIgPSAxOyB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh5MCA8IHowKSB7IGkxID0gMDsgajEgPSAwOyBrMSA9IDE7IGkyID0gMDsgajIgPSAxOyBrMiA9IDE7IH1cclxuICAgICAgICBlbHNlIGlmICh4MCA8IHowKSB7IGkxID0gMDsgajEgPSAxOyBrMSA9IDA7IGkyID0gMDsgajIgPSAxOyBrMiA9IDE7IH1cclxuICAgICAgICBlbHNlIHsgaTEgPSAwOyBqMSA9IDE7IGsxID0gMDsgaTIgPSAxOyBqMiA9IDE7IGsyID0gMDsgfVxyXG4gICAgfVxyXG4gICAgLy8gQSBzdGVwIG9mICgxLDAsMCkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYywtYykgaW4gKHgseSx6KSxcclxuICAgIC8vIGEgc3RlcCBvZiAoMCwxLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMsLWMpIGluICh4LHkseiksIGFuZFxyXG4gICAgLy8gYSBzdGVwIG9mICgwLDAsMSkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLC1jLDEtYykgaW4gKHgseSx6KSwgd2hlcmVcclxuICAgIC8vIGMgPSAxLzYuXHJcbiAgICBsZXQgeDEgPSB4MCAtIGkxICsgRzM7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXJcclxuICAgIGxldCB5MSA9IHkwIC0gajEgKyBHMztcclxuICAgIGxldCB6MSA9IHowIC0gazEgKyBHMztcclxuXHJcbiAgICBsZXQgeDIgPSB4MCAtIGkyICsgMiAqIEczOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXJcclxuICAgIGxldCB5MiA9IHkwIC0gajIgKyAyICogRzM7XHJcbiAgICBsZXQgejIgPSB6MCAtIGsyICsgMiAqIEczO1xyXG5cclxuICAgIGxldCB4MyA9IHgwIC0gMSArIDMgKiBHMzsgLy8gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lclxyXG4gICAgbGV0IHkzID0geTAgLSAxICsgMyAqIEczO1xyXG4gICAgbGV0IHozID0gejAgLSAxICsgMyAqIEczO1xyXG5cclxuICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgZm91ciBzaW1wbGV4IGNvcm5lcnNcclxuICAgIGkgJj0gMjU1O1xyXG4gICAgaiAmPSAyNTU7XHJcbiAgICBrICY9IDI1NTtcclxuICAgIGxldCBnaTAgPSBncmFkUFtpICsgcGVybVtqICsgcGVybVtrXV1dO1xyXG4gICAgbGV0IGdpMSA9IGdyYWRQW2kgKyBpMSArIHBlcm1baiArIGoxICsgcGVybVtrICsgazFdXV07XHJcbiAgICBsZXQgZ2kyID0gZ3JhZFBbaSArIGkyICsgcGVybVtqICsgajIgKyBwZXJtW2sgKyBrMl1dXTtcclxuICAgIGxldCBnaTMgPSBncmFkUFtpICsgMSArIHBlcm1baiArIDEgKyBwZXJtW2sgKyAxXV1dO1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIGZvdXIgY29ybmVyc1xyXG4gICAgbGV0IHQwID0gMC42IC0geDAgKiB4MCAtIHkwICogeTAgLSB6MCAqIHowO1xyXG4gICAgaWYgKHQwIDwgMCkge1xyXG4gICAgICAgIG4wID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdDAgKj0gdDA7XHJcbiAgICAgICAgbjAgPSB0MCAqIHQwICogZ2kwLmRvdDMoeDAsIHkwLCB6MCk7ICAvLyAoeCx5KSBvZiBncmFkMyB1c2VkIGZvciAyRCBncmFkaWVudFxyXG4gICAgfVxyXG4gICAgbGV0IHQxID0gMC42IC0geDEgKiB4MSAtIHkxICogeTEgLSB6MSAqIHoxO1xyXG4gICAgaWYgKHQxIDwgMCkge1xyXG4gICAgICAgIG4xID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdDEgKj0gdDE7XHJcbiAgICAgICAgbjEgPSB0MSAqIHQxICogZ2kxLmRvdDMoeDEsIHkxLCB6MSk7XHJcbiAgICB9XHJcbiAgICBsZXQgdDIgPSAwLjYgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejI7XHJcbiAgICBpZiAodDIgPCAwKSB7XHJcbiAgICAgICAgbjIgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0MiAqPSB0MjtcclxuICAgICAgICBuMiA9IHQyICogdDIgKiBnaTIuZG90Myh4MiwgeTIsIHoyKTtcclxuICAgIH1cclxuICAgIGxldCB0MyA9IDAuNiAtIHgzICogeDMgLSB5MyAqIHkzIC0gejMgKiB6MztcclxuICAgIGlmICh0MyA8IDApIHtcclxuICAgICAgICBuMyA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHQzICo9IHQzO1xyXG4gICAgICAgIG4zID0gdDMgKiB0MyAqIGdpMy5kb3QzKHgzLCB5MywgejMpO1xyXG4gICAgfVxyXG4gICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxyXG4gICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLlxyXG4gICAgcmV0dXJuIDMyICogKG4wICsgbjEgKyBuMiArIG4zKTtcclxuXHJcbn07XHJcblxyXG4vLyAjIyMjIyBQZXJsaW4gbm9pc2Ugc3R1ZmZcclxuXHJcbmZ1bmN0aW9uIGZhZGUodCkge1xyXG4gICAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2IC0gMTUpICsgMTApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsZXJwKGEsIGIsIHQpIHtcclxuICAgIHJldHVybiAoMSAtIHQpICogYSArIHQgKiBiO1xyXG59XHJcblxyXG4vLyAyRCBQZXJsaW4gTm9pc2Vcclxubm9pc2UucGVybGluMiA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcclxuICAgIGxldCBYID0gTWF0aC5mbG9vcih4KSwgWSA9IE1hdGguZmxvb3IoeSk7XHJcbiAgICAvLyBHZXQgcmVsYXRpdmUgeHkgY29vcmRpbmF0ZXMgb2YgcG9pbnQgd2l0aGluIHRoYXQgY2VsbFxyXG4gICAgeCA9IHggLSBYOyB5ID0geSAtIFk7XHJcbiAgICAvLyBXcmFwIHRoZSBpbnRlZ2VyIGNlbGxzIGF0IDI1NSAoc21hbGxlciBpbnRlZ2VyIHBlcmlvZCBjYW4gYmUgaW50cm9kdWNlZCBoZXJlKVxyXG4gICAgWCA9IFggJiAyNTU7IFkgPSBZICYgMjU1O1xyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBub2lzZSBjb250cmlidXRpb25zIGZyb20gZWFjaCBvZiB0aGUgZm91ciBjb3JuZXJzXHJcbiAgICBsZXQgbjAwID0gZ3JhZFBbWCArIHBlcm1bWV1dLmRvdDIoeCwgeSk7XHJcbiAgICBsZXQgbjAxID0gZ3JhZFBbWCArIHBlcm1bWSArIDFdXS5kb3QyKHgsIHkgLSAxKTtcclxuICAgIGxldCBuMTAgPSBncmFkUFtYICsgMSArIHBlcm1bWV1dLmRvdDIoeCAtIDEsIHkpO1xyXG4gICAgbGV0IG4xMSA9IGdyYWRQW1ggKyAxICsgcGVybVtZICsgMV1dLmRvdDIoeCAtIDEsIHkgLSAxKTtcclxuXHJcbiAgICAvLyBDb21wdXRlIHRoZSBmYWRlIGN1cnZlIHZhbHVlIGZvciB4XHJcbiAgICBsZXQgdSA9IGZhZGUoeCk7XHJcblxyXG4gICAgLy8gSW50ZXJwb2xhdGUgdGhlIGZvdXIgcmVzdWx0c1xyXG4gICAgcmV0dXJuIGxlcnAoXHJcbiAgICAgICAgbGVycChuMDAsIG4xMCwgdSksXHJcbiAgICAgICAgbGVycChuMDEsIG4xMSwgdSksXHJcbiAgICAgICAgZmFkZSh5KSk7XHJcbn07XHJcblxyXG4vLyAzRCBQZXJsaW4gTm9pc2Vcclxubm9pc2UucGVybGluMyA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XHJcbiAgICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcclxuICAgIGxldCBYID0gTWF0aC5mbG9vcih4KSwgWSA9IE1hdGguZmxvb3IoeSksIFogPSBNYXRoLmZsb29yKHopO1xyXG4gICAgLy8gR2V0IHJlbGF0aXZlIHh5eiBjb29yZGluYXRlcyBvZiBwb2ludCB3aXRoaW4gdGhhdCBjZWxsXHJcbiAgICB4ID0geCAtIFg7IHkgPSB5IC0gWTsgeiA9IHogLSBaO1xyXG4gICAgLy8gV3JhcCB0aGUgaW50ZWdlciBjZWxscyBhdCAyNTUgKHNtYWxsZXIgaW50ZWdlciBwZXJpb2QgY2FuIGJlIGludHJvZHVjZWQgaGVyZSlcclxuICAgIFggPSBYICYgMjU1OyBZID0gWSAmIDI1NTsgWiA9IFogJiAyNTU7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIG5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIG9mIHRoZSBlaWdodCBjb3JuZXJzXHJcbiAgICBsZXQgbjAwMCA9IGdyYWRQW1ggKyBwZXJtW1kgKyBwZXJtW1pdXV0uZG90Myh4LCB5LCB6KTtcclxuICAgIGxldCBuMDAxID0gZ3JhZFBbWCArIHBlcm1bWSArIHBlcm1bWiArIDFdXV0uZG90Myh4LCB5LCB6IC0gMSk7XHJcbiAgICBsZXQgbjAxMCA9IGdyYWRQW1ggKyBwZXJtW1kgKyAxICsgcGVybVtaXV1dLmRvdDMoeCwgeSAtIDEsIHopO1xyXG4gICAgbGV0IG4wMTEgPSBncmFkUFtYICsgcGVybVtZICsgMSArIHBlcm1bWiArIDFdXV0uZG90Myh4LCB5IC0gMSwgeiAtIDEpO1xyXG4gICAgbGV0IG4xMDAgPSBncmFkUFtYICsgMSArIHBlcm1bWSArIHBlcm1bWl1dXS5kb3QzKHggLSAxLCB5LCB6KTtcclxuICAgIGxldCBuMTAxID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyBwZXJtW1ogKyAxXV1dLmRvdDMoeCAtIDEsIHksIHogLSAxKTtcclxuICAgIGxldCBuMTEwID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyAxICsgcGVybVtaXV1dLmRvdDMoeCAtIDEsIHkgLSAxLCB6KTtcclxuICAgIGxldCBuMTExID0gZ3JhZFBbWCArIDEgKyBwZXJtW1kgKyAxICsgcGVybVtaICsgMV1dXS5kb3QzKHggLSAxLCB5IC0gMSwgeiAtIDEpO1xyXG5cclxuICAgIC8vIENvbXB1dGUgdGhlIGZhZGUgY3VydmUgdmFsdWUgZm9yIHgsIHksIHpcclxuICAgIGxldCB1ID0gZmFkZSh4KTtcclxuICAgIGxldCB2ID0gZmFkZSh5KTtcclxuICAgIGxldCB3ID0gZmFkZSh6KTtcclxuXHJcbiAgICAvLyBJbnRlcnBvbGF0ZVxyXG4gICAgcmV0dXJuIGxlcnAoXHJcbiAgICAgICAgbGVycChcclxuICAgICAgICAgICAgbGVycChuMDAwLCBuMTAwLCB1KSxcclxuICAgICAgICAgICAgbGVycChuMDAxLCBuMTAxLCB1KSwgdyksXHJcbiAgICAgICAgbGVycChcclxuICAgICAgICAgICAgbGVycChuMDEwLCBuMTEwLCB1KSxcclxuICAgICAgICAgICAgbGVycChuMDExLCBuMTExLCB1KSwgdyksXHJcbiAgICAgICAgdik7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBub2lzZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///417\n")}}]);