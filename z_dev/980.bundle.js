"use strict";(self.webpackChunkomniserver=self.webpackChunkomniserver||[]).push([[980],{980:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n// ONLY thing the api does is copy over the canvas to a webgl canvas\r\n// with shader effects. This means to draw anything we must draw it\r\n// on the canvas first and then do 1 draw call per each transformation.\r\n// This is the best even though drawing on webgl directly would be faster,\r\n// all our obstacles are tied to the canvas anyways and canvas can do pretty\r\n// much everything besides nonlinear transformations.\r\n\r\n// For the notable exception of doing something with some parameters not encoded\r\n// in the 2d image (e.g. z-coordinate) we should eventually implement a system\r\n// to get a dynamic buffer\r\n\r\nconst placeholder = document.getElementById('webglplaceholder');\r\nlet webGlCanvas, gtx;\r\nlet fragmentShader, vertexShader, glProgram;\r\nlet vertexBuff, triangleBuff;\r\nlet vloc, tloc, uloc/*, sloc*/;\r\nlet tex;\r\n\r\n// // Example vs, fs\r\n// const vs = `\r\n// \tattribute vec2 aVertex;\r\n// \tattribute vec2 aUV;\r\n// \tvarying vec2 vTex;\r\n// \tuniform vec2 pos;\r\n//  precision mediump float;\r\n//  uniform vec2 res;\r\n// \tvoid main(void) {\r\n// \t\tgl_Position = vec4(aVertex + pos, 0.0, 1.0);\r\n// \t\tvTex = aUV;\r\n// \t}`;//aVertex.x + pos.x, (aVertex.y + pos.y)*0.5\r\n\r\n// const fs = `\r\n// \tprecision highp float;\r\n// \tvarying vec2 vTex;\r\n// \tuniform sampler2D sampler0;\r\n// \tvoid main(void){\r\n// \t\tgl_FragColor = vec4(1,1,1,1) - texture2D(sampler0, vTex);\r\n// \t}`;\r\n\r\n// should not be called directly. Instead, call window.initDistortions from render.js\r\n// which will make sure the file is imported\r\nwindow._initDistortions = (vs, fs) => {\r\n    webGlCanvas = document.createElement('canvas');\r\n    gtx = webGlCanvas.getContext('webgl2');\r\n    placeholder.appendChild(webGlCanvas);\r\n    window.distortionsActive = true;\r\n\r\n    // window.resizeFns.push(resizeGtx);\r\n    resizeGtx();\r\n\r\n    _createImageBuffers();\r\n\r\n    setVertexShader(vs, false);\r\n    setFragmentShader(fs, true);\r\n}\r\n\r\nwindow.unInitDistortions = () => {\r\n    window.distortionsActive = false;\r\n    webGlCanvas = gtx = undefined;\r\n    fragmentShader = vertexShader = glProgram = undefined;\r\n    vertexBuff = triangleBuff = undefined;\r\n    vloc = tloc = uloc = /*sloc =*/ undefined;\r\n    tex = undefined;\r\n    placeholder.firstChild.remove();\r\n\r\n    // window.resizeFns = window.resizeFns.filter(f => f !== resizeGtx);\r\n}\r\n\r\n// these are unchanging since we're just drawing a static image\r\n// for now assume a constant resolution, maybe far far future in\r\n// a galaxy far far away we'll let mapmaker customize resolution\r\nlet vertexLen = 0;\r\nfunction _createImageBuffers(){\r\n    // let vertexData = [\r\n    //     -1, 1, -1, -1, 1, -1, 1, 1\r\n    // ];\r\n    // let indicies = [0, 1, 0, 0, 1, 0, 1, 1];\r\n\r\n    let vertexData = [\r\n        -1, -1,// 0\r\n        -1, +1,// 1\r\n        +1, -1,// 2\r\n        +1, +1 // 3\r\n    ];\r\n\r\n    let triangleData = [\r\n        0,1,2,\r\n        1,2,3\r\n    ]\r\n\r\n    // let vertexData = [];// [-1, 1, -1, -1, 1, -1, 1, 1];\r\n    // let indicies = [];// [0, 1, 0, 0, 1, 0, 1, 1]\r\n\r\n    // // 10x10 pixel grid will be represented by 4 verticies (square)\r\n    // const jmp = 10;\r\n    // const resX = Math.floor(canvas.w / jmp);\r\n    // const resY = Math.floor(canvas.h / jmp);\r\n\r\n    // // forming verticies\r\n    // for(let y = 0; y <= resY; y++){\r\n    //     for(let x = 0; x <= resX; x++){\r\n    //         // vertex positions in space. Scaled from -1 to 1\r\n    //         vertexData.push(\r\n    //             (x*jmp)/canvas.w*2-1,\r\n    //             (y*jmp)/canvas.h*2-1\r\n    //         );\r\n    //     }\r\n    // }\r\n\r\n    // // forming triangles\r\n    // // we form triangles from y layer n to y layer n+1\r\n    // let curIndex = 0;\r\n    // for(let y = 0; y <= resY-1; y++){\r\n    //     for(let x = 0; x <= resX-1; x++){\r\n    //         indicies.push(\r\n    //             curIndex,\r\n    //             curIndex+1,\r\n    //             curIndex+resX,\r\n    //         );\r\n    //         indicies.push(\r\n    //             curIndex+1,\r\n    //             curIndex+resX,\r\n    //             curIndex+resX+1,\r\n    //         );\r\n    //         curIndex++;\r\n    //     }\r\n    // }\r\n\r\n    vertexLen = vertexData.length;\r\n\r\n    vertexData = new Float32Array(vertexData);\r\n    triangleData = new Uint32Array(triangleData);\r\n\r\n    vertexBuff = gtx.createBuffer();\r\n    gtx.bindBuffer(gtx.ARRAY_BUFFER, vertexBuff);\r\n    gtx.bufferData(gtx.ARRAY_BUFFER, vertexData, gtx.STATIC_DRAW);\r\n\r\n    triangleBuff = gtx.createBuffer();\r\n    gtx.bindBuffer(gtx.ARRAY_BUFFER, triangleBuff);\r\n    gtx.bufferData(gtx.ARRAY_BUFFER, triangleData, gtx.STATIC_DRAW);\r\n}\r\n\r\nwindow.setVertexShader = (str, toUpdate=true) => {\r\n    vertexShader = gtx.createShader(gtx.VERTEX_SHADER);\r\n    gtx.shaderSource(vertexShader, str);\r\n    gtx.compileShader(vertexShader);\r\n\r\n    if(toUpdate === true) _updateProgram();\r\n}\r\n\r\nwindow.setFragmentShader = (str, toUpdate=true) => {\r\n    fragmentShader = gtx.createShader(gtx.FRAGMENT_SHADER);\r\n    gtx.shaderSource(fragmentShader, str);\r\n    gtx.compileShader(fragmentShader);\r\n\r\n    if(toUpdate === true) _updateProgram();\r\n}\r\n\r\nfunction _updateProgram(){\r\n    glProgram = gtx.createProgram();\r\n    gtx.attachShader(glProgram, vertexShader);\r\n    gtx.attachShader(glProgram, fragmentShader);\r\n\r\n    gtx.linkProgram(glProgram);\r\n    gtx.useProgram(glProgram);\r\n\r\n    vloc = gtx.getAttribLocation(glProgram, \"aVertex\"); \r\n    tloc = gtx.getAttribLocation(glProgram, \"aUV\");\r\n    uloc = gtx.getUniformLocation(glProgram, \"pos\");\r\n    // sloc = gtx.getUniformLocation(glProgram, \"res\");\r\n}\r\n\r\nfunction _tellGlLocations(){\r\n    gtx.enableVertexAttribArray(vloc);\r\n    gtx.bindBuffer(gtx.ARRAY_BUFFER, vertexBuff);\r\n    gtx.vertexAttribPointer(vloc, 2, gtx.FLOAT, false, 0, 0);\r\n\r\n    gtx.enableVertexAttribArray(tloc);\r\n    gtx.bindBuffer(gtx.ARRAY_BUFFER, triangleBuff);\r\n    gtx.bindTexture(gtx.TEXTURE_2D, tex);\r\n    gtx.vertexAttribPointer(tloc, 2, gtx.UNSIGNED_INT, false, 0, 0);\r\n}\r\n\r\n// copies the canvas contents onto webgl\r\nwindow.drawGtx = (img=canvas) => {\r\n    // setting texture\r\n    tex = gtx.createTexture();\r\n    gtx.bindTexture(gtx.TEXTURE_2D, tex);\r\n    \r\n    gtx.texParameteri(gtx.TEXTURE_2D, gtx.TEXTURE_WRAP_S, gtx.CLAMP_TO_EDGE);\r\n    gtx.texParameteri(gtx.TEXTURE_2D, gtx.TEXTURE_WRAP_T, gtx.CLAMP_TO_EDGE);\r\n    gtx.texParameteri(gtx.TEXTURE_2D, gtx.TEXTURE_MIN_FILTER, gtx.NEAREST);// gtx.LINEAR\r\n\r\n    gtx.texImage2D(gtx.TEXTURE_2D, 0,  gtx.RGBA,  gtx.RGBA, gtx.UNSIGNED_BYTE, img);\r\n\r\n\r\n    // gtx.enableVertexAttribArray(sloc);\r\n    // gtx.uniform2f(sloc, canvas.width, canvas.height);\r\n\r\n    // gtx.drawArrays(gtx.TRIANGLE_FAN, 0, 4);\r\n    // gtx.clearColor(0, 0, 0, 1.0);\r\n    // gtx.clear(gtx.COLOR_BUFFER_BIT);\r\n    \r\n    gtx.drawElements(\r\n        gtx.TRIANGLES,\r\n        vertexLen,\r\n        gtx.UNSIGNED_INT,\r\n        0,\r\n    )\r\n    // gtx.drawArrays(gtx.TRIANGLE_FAN, 0, 4);\r\n}\r\n\r\nwindow.resizeGtx = () => {\r\n    window.resizeElements([webGlCanvas]);\r\n    gtx.viewport(0, 0, webGlCanvas.width, webGlCanvas.height);\r\n}\r\n\r\n\r\n// () => {\r\n// // const vs = `\r\n// // \tattribute vec2 aVertex;\r\n// // \tattribute vec2 aUV;\r\n// // \tvarying vec2 vTex;\r\n// // \tuniform vec2 pos;\r\n// //     // precision mediump float;\r\n// //     // uniform vec2 res;\r\n// // \tvoid main(void) {\r\n// //         // // coords go from -1 to 1\r\n// //         // float angle = 0.;//atan(pos.y, pos.x + 1e-10);\r\n\r\n// //         // float dist = sqrt(pos.x*pos.x+pos.y*pos.y);\r\n// //         // float p = max(abs(cos(angle)), abs(sin(angle)));\r\n        \r\n// //         // // maxDistAlongAngle = 1. / (p * p);\r\n// //         // // mag = 0.2 * dist / maxDistAlongAngle;\r\n// //         // float mag = 0.1;//0.2 * dist * p * p;\r\n\r\n// //         // gl_Position = vec4(aVertex.x + pos.x., aVertex.y + pos.y, 0.0, 1.0);\r\n// // \t\t// gl_Position = vec4(cos(angle) * mag, sin(angle) * mag, 0.0, 1.0);\r\n// //         gl_Position = vec4(aVertex + pos, 0.0, 1.0);\r\n// // \t\tvTex = aUV;\r\n// // \t}`;\r\n\r\n// const vs = `\r\n// \tattribute vec2 aVertex;\r\n// \tattribute vec2 aUV;\r\n// \tvarying vec2 vTex;\r\n// \tuniform vec2 pos;\r\n// \tvoid main(void) {\r\n//         float angle = atan(aVertex.y + pos.y, aVertex.x + pos.x + 1e-10);\r\n\r\n//         gl_Position = vec4((aVertex.x + pos.x)*(cos(angle)+1.), aVertex.y + pos.y, 0.0, 1.0);\r\n// \t\tvTex = aUV;\r\n// \t}`;\r\n\r\n// const fs = `\r\n// \tprecision highp float;\r\n// \tvarying vec2 vTex;\r\n// \tuniform sampler2D sampler0;\r\n// \tvoid main(void){\r\n// \t\tgl_FragColor = texture2D(sampler0, vTex);\r\n// \t}`;// vec4(1,1,1,1) - \r\n// initDistortions(vs, fs);\r\n// }\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgwLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbW5pc2VydmVyLy4vZVhjbGllbnQvZGlzdG9ydC5qcz82ZWNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE9OTFkgdGhpbmcgdGhlIGFwaSBkb2VzIGlzIGNvcHkgb3ZlciB0aGUgY2FudmFzIHRvIGEgd2ViZ2wgY2FudmFzXHJcbi8vIHdpdGggc2hhZGVyIGVmZmVjdHMuIFRoaXMgbWVhbnMgdG8gZHJhdyBhbnl0aGluZyB3ZSBtdXN0IGRyYXcgaXRcclxuLy8gb24gdGhlIGNhbnZhcyBmaXJzdCBhbmQgdGhlbiBkbyAxIGRyYXcgY2FsbCBwZXIgZWFjaCB0cmFuc2Zvcm1hdGlvbi5cclxuLy8gVGhpcyBpcyB0aGUgYmVzdCBldmVuIHRob3VnaCBkcmF3aW5nIG9uIHdlYmdsIGRpcmVjdGx5IHdvdWxkIGJlIGZhc3RlcixcclxuLy8gYWxsIG91ciBvYnN0YWNsZXMgYXJlIHRpZWQgdG8gdGhlIGNhbnZhcyBhbnl3YXlzIGFuZCBjYW52YXMgY2FuIGRvIHByZXR0eVxyXG4vLyBtdWNoIGV2ZXJ5dGhpbmcgYmVzaWRlcyBub25saW5lYXIgdHJhbnNmb3JtYXRpb25zLlxyXG5cclxuLy8gRm9yIHRoZSBub3RhYmxlIGV4Y2VwdGlvbiBvZiBkb2luZyBzb21ldGhpbmcgd2l0aCBzb21lIHBhcmFtZXRlcnMgbm90IGVuY29kZWRcclxuLy8gaW4gdGhlIDJkIGltYWdlIChlLmcuIHotY29vcmRpbmF0ZSkgd2Ugc2hvdWxkIGV2ZW50dWFsbHkgaW1wbGVtZW50IGEgc3lzdGVtXHJcbi8vIHRvIGdldCBhIGR5bmFtaWMgYnVmZmVyXHJcblxyXG5jb25zdCBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3ZWJnbHBsYWNlaG9sZGVyJyk7XHJcbmxldCB3ZWJHbENhbnZhcywgZ3R4O1xyXG5sZXQgZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlciwgZ2xQcm9ncmFtO1xyXG5sZXQgdmVydGV4QnVmZiwgdHJpYW5nbGVCdWZmO1xyXG5sZXQgdmxvYywgdGxvYywgdWxvYy8qLCBzbG9jKi87XHJcbmxldCB0ZXg7XHJcblxyXG4vLyAvLyBFeGFtcGxlIHZzLCBmc1xyXG4vLyBjb25zdCB2cyA9IGBcclxuLy8gXHRhdHRyaWJ1dGUgdmVjMiBhVmVydGV4O1xyXG4vLyBcdGF0dHJpYnV0ZSB2ZWMyIGFVVjtcclxuLy8gXHR2YXJ5aW5nIHZlYzIgdlRleDtcclxuLy8gXHR1bmlmb3JtIHZlYzIgcG9zO1xyXG4vLyAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbi8vICB1bmlmb3JtIHZlYzIgcmVzO1xyXG4vLyBcdHZvaWQgbWFpbih2b2lkKSB7XHJcbi8vIFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleCArIHBvcywgMC4wLCAxLjApO1xyXG4vLyBcdFx0dlRleCA9IGFVVjtcclxuLy8gXHR9YDsvL2FWZXJ0ZXgueCArIHBvcy54LCAoYVZlcnRleC55ICsgcG9zLnkpKjAuNVxyXG5cclxuLy8gY29uc3QgZnMgPSBgXHJcbi8vIFx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG4vLyBcdHZhcnlpbmcgdmVjMiB2VGV4O1xyXG4vLyBcdHVuaWZvcm0gc2FtcGxlcjJEIHNhbXBsZXIwO1xyXG4vLyBcdHZvaWQgbWFpbih2b2lkKXtcclxuLy8gXHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoMSwxLDEsMSkgLSB0ZXh0dXJlMkQoc2FtcGxlcjAsIHZUZXgpO1xyXG4vLyBcdH1gO1xyXG5cclxuLy8gc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuIEluc3RlYWQsIGNhbGwgd2luZG93LmluaXREaXN0b3J0aW9ucyBmcm9tIHJlbmRlci5qc1xyXG4vLyB3aGljaCB3aWxsIG1ha2Ugc3VyZSB0aGUgZmlsZSBpcyBpbXBvcnRlZFxyXG53aW5kb3cuX2luaXREaXN0b3J0aW9ucyA9ICh2cywgZnMpID0+IHtcclxuICAgIHdlYkdsQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBndHggPSB3ZWJHbENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcclxuICAgIHBsYWNlaG9sZGVyLmFwcGVuZENoaWxkKHdlYkdsQ2FudmFzKTtcclxuICAgIHdpbmRvdy5kaXN0b3J0aW9uc0FjdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgLy8gd2luZG93LnJlc2l6ZUZucy5wdXNoKHJlc2l6ZUd0eCk7XHJcbiAgICByZXNpemVHdHgoKTtcclxuXHJcbiAgICBfY3JlYXRlSW1hZ2VCdWZmZXJzKCk7XHJcblxyXG4gICAgc2V0VmVydGV4U2hhZGVyKHZzLCBmYWxzZSk7XHJcbiAgICBzZXRGcmFnbWVudFNoYWRlcihmcywgdHJ1ZSk7XHJcbn1cclxuXHJcbndpbmRvdy51bkluaXREaXN0b3J0aW9ucyA9ICgpID0+IHtcclxuICAgIHdpbmRvdy5kaXN0b3J0aW9uc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgd2ViR2xDYW52YXMgPSBndHggPSB1bmRlZmluZWQ7XHJcbiAgICBmcmFnbWVudFNoYWRlciA9IHZlcnRleFNoYWRlciA9IGdsUHJvZ3JhbSA9IHVuZGVmaW5lZDtcclxuICAgIHZlcnRleEJ1ZmYgPSB0cmlhbmdsZUJ1ZmYgPSB1bmRlZmluZWQ7XHJcbiAgICB2bG9jID0gdGxvYyA9IHVsb2MgPSAvKnNsb2MgPSovIHVuZGVmaW5lZDtcclxuICAgIHRleCA9IHVuZGVmaW5lZDtcclxuICAgIHBsYWNlaG9sZGVyLmZpcnN0Q2hpbGQucmVtb3ZlKCk7XHJcblxyXG4gICAgLy8gd2luZG93LnJlc2l6ZUZucyA9IHdpbmRvdy5yZXNpemVGbnMuZmlsdGVyKGYgPT4gZiAhPT0gcmVzaXplR3R4KTtcclxufVxyXG5cclxuLy8gdGhlc2UgYXJlIHVuY2hhbmdpbmcgc2luY2Ugd2UncmUganVzdCBkcmF3aW5nIGEgc3RhdGljIGltYWdlXHJcbi8vIGZvciBub3cgYXNzdW1lIGEgY29uc3RhbnQgcmVzb2x1dGlvbiwgbWF5YmUgZmFyIGZhciBmdXR1cmUgaW5cclxuLy8gYSBnYWxheHkgZmFyIGZhciBhd2F5IHdlJ2xsIGxldCBtYXBtYWtlciBjdXN0b21pemUgcmVzb2x1dGlvblxyXG5sZXQgdmVydGV4TGVuID0gMDtcclxuZnVuY3Rpb24gX2NyZWF0ZUltYWdlQnVmZmVycygpe1xyXG4gICAgLy8gbGV0IHZlcnRleERhdGEgPSBbXHJcbiAgICAvLyAgICAgLTEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDFcclxuICAgIC8vIF07XHJcbiAgICAvLyBsZXQgaW5kaWNpZXMgPSBbMCwgMSwgMCwgMCwgMSwgMCwgMSwgMV07XHJcblxyXG4gICAgbGV0IHZlcnRleERhdGEgPSBbXHJcbiAgICAgICAgLTEsIC0xLC8vIDBcclxuICAgICAgICAtMSwgKzEsLy8gMVxyXG4gICAgICAgICsxLCAtMSwvLyAyXHJcbiAgICAgICAgKzEsICsxIC8vIDNcclxuICAgIF07XHJcblxyXG4gICAgbGV0IHRyaWFuZ2xlRGF0YSA9IFtcclxuICAgICAgICAwLDEsMixcclxuICAgICAgICAxLDIsM1xyXG4gICAgXVxyXG5cclxuICAgIC8vIGxldCB2ZXJ0ZXhEYXRhID0gW107Ly8gWy0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxXTtcclxuICAgIC8vIGxldCBpbmRpY2llcyA9IFtdOy8vIFswLCAxLCAwLCAwLCAxLCAwLCAxLCAxXVxyXG5cclxuICAgIC8vIC8vIDEweDEwIHBpeGVsIGdyaWQgd2lsbCBiZSByZXByZXNlbnRlZCBieSA0IHZlcnRpY2llcyAoc3F1YXJlKVxyXG4gICAgLy8gY29uc3Qgam1wID0gMTA7XHJcbiAgICAvLyBjb25zdCByZXNYID0gTWF0aC5mbG9vcihjYW52YXMudyAvIGptcCk7XHJcbiAgICAvLyBjb25zdCByZXNZID0gTWF0aC5mbG9vcihjYW52YXMuaCAvIGptcCk7XHJcblxyXG4gICAgLy8gLy8gZm9ybWluZyB2ZXJ0aWNpZXNcclxuICAgIC8vIGZvcihsZXQgeSA9IDA7IHkgPD0gcmVzWTsgeSsrKXtcclxuICAgIC8vICAgICBmb3IobGV0IHggPSAwOyB4IDw9IHJlc1g7IHgrKyl7XHJcbiAgICAvLyAgICAgICAgIC8vIHZlcnRleCBwb3NpdGlvbnMgaW4gc3BhY2UuIFNjYWxlZCBmcm9tIC0xIHRvIDFcclxuICAgIC8vICAgICAgICAgdmVydGV4RGF0YS5wdXNoKFxyXG4gICAgLy8gICAgICAgICAgICAgKHgqam1wKS9jYW52YXMudyoyLTEsXHJcbiAgICAvLyAgICAgICAgICAgICAoeSpqbXApL2NhbnZhcy5oKjItMVxyXG4gICAgLy8gICAgICAgICApO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyAvLyBmb3JtaW5nIHRyaWFuZ2xlc1xyXG4gICAgLy8gLy8gd2UgZm9ybSB0cmlhbmdsZXMgZnJvbSB5IGxheWVyIG4gdG8geSBsYXllciBuKzFcclxuICAgIC8vIGxldCBjdXJJbmRleCA9IDA7XHJcbiAgICAvLyBmb3IobGV0IHkgPSAwOyB5IDw9IHJlc1ktMTsgeSsrKXtcclxuICAgIC8vICAgICBmb3IobGV0IHggPSAwOyB4IDw9IHJlc1gtMTsgeCsrKXtcclxuICAgIC8vICAgICAgICAgaW5kaWNpZXMucHVzaChcclxuICAgIC8vICAgICAgICAgICAgIGN1ckluZGV4LFxyXG4gICAgLy8gICAgICAgICAgICAgY3VySW5kZXgrMSxcclxuICAgIC8vICAgICAgICAgICAgIGN1ckluZGV4K3Jlc1gsXHJcbiAgICAvLyAgICAgICAgICk7XHJcbiAgICAvLyAgICAgICAgIGluZGljaWVzLnB1c2goXHJcbiAgICAvLyAgICAgICAgICAgICBjdXJJbmRleCsxLFxyXG4gICAgLy8gICAgICAgICAgICAgY3VySW5kZXgrcmVzWCxcclxuICAgIC8vICAgICAgICAgICAgIGN1ckluZGV4K3Jlc1grMSxcclxuICAgIC8vICAgICAgICAgKTtcclxuICAgIC8vICAgICAgICAgY3VySW5kZXgrKztcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9XHJcblxyXG4gICAgdmVydGV4TGVuID0gdmVydGV4RGF0YS5sZW5ndGg7XHJcblxyXG4gICAgdmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4RGF0YSk7XHJcbiAgICB0cmlhbmdsZURhdGEgPSBuZXcgVWludDMyQXJyYXkodHJpYW5nbGVEYXRhKTtcclxuXHJcbiAgICB2ZXJ0ZXhCdWZmID0gZ3R4LmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgZ3R4LmJpbmRCdWZmZXIoZ3R4LkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZik7XHJcbiAgICBndHguYnVmZmVyRGF0YShndHguQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhEYXRhLCBndHguU1RBVElDX0RSQVcpO1xyXG5cclxuICAgIHRyaWFuZ2xlQnVmZiA9IGd0eC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIGd0eC5iaW5kQnVmZmVyKGd0eC5BUlJBWV9CVUZGRVIsIHRyaWFuZ2xlQnVmZik7XHJcbiAgICBndHguYnVmZmVyRGF0YShndHguQVJSQVlfQlVGRkVSLCB0cmlhbmdsZURhdGEsIGd0eC5TVEFUSUNfRFJBVyk7XHJcbn1cclxuXHJcbndpbmRvdy5zZXRWZXJ0ZXhTaGFkZXIgPSAoc3RyLCB0b1VwZGF0ZT10cnVlKSA9PiB7XHJcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBndHguY3JlYXRlU2hhZGVyKGd0eC5WRVJURVhfU0hBREVSKTtcclxuICAgIGd0eC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCBzdHIpO1xyXG4gICAgZ3R4LmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcclxuXHJcbiAgICBpZih0b1VwZGF0ZSA9PT0gdHJ1ZSkgX3VwZGF0ZVByb2dyYW0oKTtcclxufVxyXG5cclxud2luZG93LnNldEZyYWdtZW50U2hhZGVyID0gKHN0ciwgdG9VcGRhdGU9dHJ1ZSkgPT4ge1xyXG4gICAgZnJhZ21lbnRTaGFkZXIgPSBndHguY3JlYXRlU2hhZGVyKGd0eC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgZ3R4LnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgc3RyKTtcclxuICAgIGd0eC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcclxuXHJcbiAgICBpZih0b1VwZGF0ZSA9PT0gdHJ1ZSkgX3VwZGF0ZVByb2dyYW0oKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX3VwZGF0ZVByb2dyYW0oKXtcclxuICAgIGdsUHJvZ3JhbSA9IGd0eC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICBndHguYXR0YWNoU2hhZGVyKGdsUHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcclxuICAgIGd0eC5hdHRhY2hTaGFkZXIoZ2xQcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcblxyXG4gICAgZ3R4LmxpbmtQcm9ncmFtKGdsUHJvZ3JhbSk7XHJcbiAgICBndHgudXNlUHJvZ3JhbShnbFByb2dyYW0pO1xyXG5cclxuICAgIHZsb2MgPSBndHguZ2V0QXR0cmliTG9jYXRpb24oZ2xQcm9ncmFtLCBcImFWZXJ0ZXhcIik7IFxyXG4gICAgdGxvYyA9IGd0eC5nZXRBdHRyaWJMb2NhdGlvbihnbFByb2dyYW0sIFwiYVVWXCIpO1xyXG4gICAgdWxvYyA9IGd0eC5nZXRVbmlmb3JtTG9jYXRpb24oZ2xQcm9ncmFtLCBcInBvc1wiKTtcclxuICAgIC8vIHNsb2MgPSBndHguZ2V0VW5pZm9ybUxvY2F0aW9uKGdsUHJvZ3JhbSwgXCJyZXNcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF90ZWxsR2xMb2NhdGlvbnMoKXtcclxuICAgIGd0eC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2bG9jKTtcclxuICAgIGd0eC5iaW5kQnVmZmVyKGd0eC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmYpO1xyXG4gICAgZ3R4LnZlcnRleEF0dHJpYlBvaW50ZXIodmxvYywgMiwgZ3R4LkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcblxyXG4gICAgZ3R4LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRsb2MpO1xyXG4gICAgZ3R4LmJpbmRCdWZmZXIoZ3R4LkFSUkFZX0JVRkZFUiwgdHJpYW5nbGVCdWZmKTtcclxuICAgIGd0eC5iaW5kVGV4dHVyZShndHguVEVYVFVSRV8yRCwgdGV4KTtcclxuICAgIGd0eC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRsb2MsIDIsIGd0eC5VTlNJR05FRF9JTlQsIGZhbHNlLCAwLCAwKTtcclxufVxyXG5cclxuLy8gY29waWVzIHRoZSBjYW52YXMgY29udGVudHMgb250byB3ZWJnbFxyXG53aW5kb3cuZHJhd0d0eCA9IChpbWc9Y2FudmFzKSA9PiB7XHJcbiAgICAvLyBzZXR0aW5nIHRleHR1cmVcclxuICAgIHRleCA9IGd0eC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICBndHguYmluZFRleHR1cmUoZ3R4LlRFWFRVUkVfMkQsIHRleCk7XHJcbiAgICBcclxuICAgIGd0eC50ZXhQYXJhbWV0ZXJpKGd0eC5URVhUVVJFXzJELCBndHguVEVYVFVSRV9XUkFQX1MsIGd0eC5DTEFNUF9UT19FREdFKTtcclxuICAgIGd0eC50ZXhQYXJhbWV0ZXJpKGd0eC5URVhUVVJFXzJELCBndHguVEVYVFVSRV9XUkFQX1QsIGd0eC5DTEFNUF9UT19FREdFKTtcclxuICAgIGd0eC50ZXhQYXJhbWV0ZXJpKGd0eC5URVhUVVJFXzJELCBndHguVEVYVFVSRV9NSU5fRklMVEVSLCBndHguTkVBUkVTVCk7Ly8gZ3R4LkxJTkVBUlxyXG5cclxuICAgIGd0eC50ZXhJbWFnZTJEKGd0eC5URVhUVVJFXzJELCAwLCAgZ3R4LlJHQkEsICBndHguUkdCQSwgZ3R4LlVOU0lHTkVEX0JZVEUsIGltZyk7XHJcblxyXG5cclxuICAgIC8vIGd0eC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzbG9jKTtcclxuICAgIC8vIGd0eC51bmlmb3JtMmYoc2xvYywgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuXHJcbiAgICAvLyBndHguZHJhd0FycmF5cyhndHguVFJJQU5HTEVfRkFOLCAwLCA0KTtcclxuICAgIC8vIGd0eC5jbGVhckNvbG9yKDAsIDAsIDAsIDEuMCk7XHJcbiAgICAvLyBndHguY2xlYXIoZ3R4LkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgXHJcbiAgICBndHguZHJhd0VsZW1lbnRzKFxyXG4gICAgICAgIGd0eC5UUklBTkdMRVMsXHJcbiAgICAgICAgdmVydGV4TGVuLFxyXG4gICAgICAgIGd0eC5VTlNJR05FRF9JTlQsXHJcbiAgICAgICAgMCxcclxuICAgIClcclxuICAgIC8vIGd0eC5kcmF3QXJyYXlzKGd0eC5UUklBTkdMRV9GQU4sIDAsIDQpO1xyXG59XHJcblxyXG53aW5kb3cucmVzaXplR3R4ID0gKCkgPT4ge1xyXG4gICAgd2luZG93LnJlc2l6ZUVsZW1lbnRzKFt3ZWJHbENhbnZhc10pO1xyXG4gICAgZ3R4LnZpZXdwb3J0KDAsIDAsIHdlYkdsQ2FudmFzLndpZHRoLCB3ZWJHbENhbnZhcy5oZWlnaHQpO1xyXG59XHJcblxyXG5cclxuLy8gKCkgPT4ge1xyXG4vLyAvLyBjb25zdCB2cyA9IGBcclxuLy8gLy8gXHRhdHRyaWJ1dGUgdmVjMiBhVmVydGV4O1xyXG4vLyAvLyBcdGF0dHJpYnV0ZSB2ZWMyIGFVVjtcclxuLy8gLy8gXHR2YXJ5aW5nIHZlYzIgdlRleDtcclxuLy8gLy8gXHR1bmlmb3JtIHZlYzIgcG9zO1xyXG4vLyAvLyAgICAgLy8gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbi8vIC8vICAgICAvLyB1bmlmb3JtIHZlYzIgcmVzO1xyXG4vLyAvLyBcdHZvaWQgbWFpbih2b2lkKSB7XHJcbi8vIC8vICAgICAgICAgLy8gLy8gY29vcmRzIGdvIGZyb20gLTEgdG8gMVxyXG4vLyAvLyAgICAgICAgIC8vIGZsb2F0IGFuZ2xlID0gMC47Ly9hdGFuKHBvcy55LCBwb3MueCArIDFlLTEwKTtcclxuXHJcbi8vIC8vICAgICAgICAgLy8gZmxvYXQgZGlzdCA9IHNxcnQocG9zLngqcG9zLngrcG9zLnkqcG9zLnkpO1xyXG4vLyAvLyAgICAgICAgIC8vIGZsb2F0IHAgPSBtYXgoYWJzKGNvcyhhbmdsZSkpLCBhYnMoc2luKGFuZ2xlKSkpO1xyXG4gICAgICAgIFxyXG4vLyAvLyAgICAgICAgIC8vIC8vIG1heERpc3RBbG9uZ0FuZ2xlID0gMS4gLyAocCAqIHApO1xyXG4vLyAvLyAgICAgICAgIC8vIC8vIG1hZyA9IDAuMiAqIGRpc3QgLyBtYXhEaXN0QWxvbmdBbmdsZTtcclxuLy8gLy8gICAgICAgICAvLyBmbG9hdCBtYWcgPSAwLjE7Ly8wLjIgKiBkaXN0ICogcCAqIHA7XHJcblxyXG4vLyAvLyAgICAgICAgIC8vIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4LnggKyBwb3MueC4sIGFWZXJ0ZXgueSArIHBvcy55LCAwLjAsIDEuMCk7XHJcbi8vIC8vIFx0XHQvLyBnbF9Qb3NpdGlvbiA9IHZlYzQoY29zKGFuZ2xlKSAqIG1hZywgc2luKGFuZ2xlKSAqIG1hZywgMC4wLCAxLjApO1xyXG4vLyAvLyAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4ICsgcG9zLCAwLjAsIDEuMCk7XHJcbi8vIC8vIFx0XHR2VGV4ID0gYVVWO1xyXG4vLyAvLyBcdH1gO1xyXG5cclxuLy8gY29uc3QgdnMgPSBgXHJcbi8vIFx0YXR0cmlidXRlIHZlYzIgYVZlcnRleDtcclxuLy8gXHRhdHRyaWJ1dGUgdmVjMiBhVVY7XHJcbi8vIFx0dmFyeWluZyB2ZWMyIHZUZXg7XHJcbi8vIFx0dW5pZm9ybSB2ZWMyIHBvcztcclxuLy8gXHR2b2lkIG1haW4odm9pZCkge1xyXG4vLyAgICAgICAgIGZsb2F0IGFuZ2xlID0gYXRhbihhVmVydGV4LnkgKyBwb3MueSwgYVZlcnRleC54ICsgcG9zLnggKyAxZS0xMCk7XHJcblxyXG4vLyAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgoYVZlcnRleC54ICsgcG9zLngpKihjb3MoYW5nbGUpKzEuKSwgYVZlcnRleC55ICsgcG9zLnksIDAuMCwgMS4wKTtcclxuLy8gXHRcdHZUZXggPSBhVVY7XHJcbi8vIFx0fWA7XHJcblxyXG4vLyBjb25zdCBmcyA9IGBcclxuLy8gXHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcbi8vIFx0dmFyeWluZyB2ZWMyIHZUZXg7XHJcbi8vIFx0dW5pZm9ybSBzYW1wbGVyMkQgc2FtcGxlcjA7XHJcbi8vIFx0dm9pZCBtYWluKHZvaWQpe1xyXG4vLyBcdFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHNhbXBsZXIwLCB2VGV4KTtcclxuLy8gXHR9YDsvLyB2ZWM0KDEsMSwxLDEpIC0gXHJcbi8vIGluaXREaXN0b3J0aW9ucyh2cywgZnMpO1xyXG4vLyB9XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///980\n")}}]);