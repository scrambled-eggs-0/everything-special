"use strict";(self.webpackChunkomniserver=self.webpackChunkomniserver||[]).push([[78],{78:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction importMap(str){\r\n    obstacles.length = 0;\r\n\r\n    const o = JSON.parse(str);\r\n\r\n    let {arena, safes, spawns, playerSpawn, tileColor, bgColor, texts} = o;\r\n\r\n    // arena.width, arena.height\r\n\r\n    mapDimensions.x=arena.width * 2;\r\n    mapDimensions.y=arena.height * 2;\r\n\r\n    spawnPosition.x=playerSpawn.x*2;\r\n    spawnPosition.y=playerSpawn.y*2;\r\n    window.respawnPlayer();\r\n    colors.background=tileColor; colors.tile=bgColor;\r\n\r\n    let counter = 0;\r\n\r\n    let obs = o.obstacles;\r\n    let enemies = o.enemy;\r\n\r\n    safes = safes.map(p => {\r\n        p.type = "safe";\r\n        return p;\r\n    });\r\n\r\n    texts = texts.map(p => {\r\n        p.type = "text";\r\n        return p;\r\n    });\r\n\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n\r\n    const typeMap = {\r\n        \'normal\': {\r\n            type: [1,[],[0]],\r\n        },\r\n        // \'trans\': {\r\n        //     type: [1,[],[20]],\r\n        //     customMap: (params) => {\r\n        //         return {hex: \'#000000\', alpha: params.opaq};\r\n        //     }\r\n        // },\r\n        // \'block\': {\r\n        //     type: [1,[],[20]],\r\n        //     customMap: (params) => {\r\n        //         return {hex: params.color, alpha: 1};\r\n        //     }\r\n        // },\r\n        \'grav\': {\r\n            type: [1,[],[13]],\r\n            customMap: (params) => {\r\n                const p = {};\r\n                if(params.direction === \'right\'){\r\n                    p.conveyorAngle = 0\r\n                } else if(params.direction === \'down\'){\r\n                    p.conveyorAngle = 90;\r\n                } else if(params.direction === \'left\'){\r\n                    p.conveyorAngle = 180;\r\n                } else {\r\n                    p.conveyorAngle = 270;\r\n                }\r\n                p.conveyorFriction = 0.8;\r\n                p.conveyorAngleRotateSpeed = 0;\r\n                p.conveyorForce = params.force / 10000 * 7.08 * 5 / 16.66;\r\n                return p;\r\n            }\r\n        },\r\n        \'circle-normal\': {\r\n            type: [0,[],[0]],\r\n            radius: \'r\' // this means map radius to r\r\n            // all other params filled in 1:1, so x will be filled in from x, y from y, etc.\r\n        },\r\n        \'circle-lava\': {\r\n            type: [0,[],[1]],\r\n            radius: \'r\',\r\n            customMap: (params) => {\r\n                return {\r\n                    boundPlayer: true,\r\n                }\r\n            }\r\n        },\r\n        \'circle-tp\': {\r\n            type: [0,[],[12]],\r\n            customMap: (params) => {\r\n                return {\r\n                    tpx: params.tpx * 2,\r\n                    tpy: params.tpy * 2\r\n                }\r\n            }\r\n        },\r\n        \'lava\': {\r\n            type: [1,[],[1]],\r\n            customMap: (params) => {\r\n                return {\r\n                    boundPlayer: params.canCollide\r\n                };\r\n            }\r\n        },\r\n        \'poly\': {\r\n            type: [2,[],[0]],\r\n            customMap: (params) => {\r\n                const p = {points: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                return p;\r\n            }\r\n        },\r\n        \'poly-tp\': {\r\n            type: [2,[],[12]],\r\n            customMap: (params) => {\r\n                const p = {points: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                p.tpx = params.tpx * 2;\r\n                p.tpy = params.tpy * 2;\r\n                return p;\r\n            }\r\n        },\r\n        \'poly-safe\': {\r\n            type: [2,[],[11]],\r\n            customMap: (params) => {\r\n                const p = {points: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                return p;\r\n            }\r\n        },\r\n        \'poly-vinette\': {\r\n            type: [2,[],[24]],\r\n            customMap: (params) => {\r\n                const p = {points: [],\r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o\r\n                };\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                return p;\r\n            }\r\n        },\r\n        \'poly-lava\': {\r\n            type: [2,[],[1]],\r\n            customMap: (params) => {\r\n                const p = {points: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                p.boundPlayer = true;//params.canCollide;\r\n                return p;\r\n            }\r\n        },\r\n        \'move\': {\r\n            type: [1,[0],[0]],\r\n            customMap: (params) => {\r\n                const p = {path: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n    \r\n                p.currentPoint = params.currentPoint;\r\n    \r\n                const currentPoint = p.path[p.currentPoint];\r\n                let nextPointIndex = p.currentPoint+1;\r\n                if(nextPointIndex === p.path.length) nextPointIndex = 0;\r\n                const nextPoint = p.path[nextPointIndex];\r\n    \r\n                const totalDist = Math.sqrt((nextPoint[0]-currentPoint[0])**2+(nextPoint[1]-currentPoint[1])**2);\r\n                const fractionCovered = Math.sqrt((params.x*2-currentPoint[0])**2+(params.y*2-currentPoint[1])**2);\r\n                \r\n                p.currentPoint += fractionCovered / totalDist;\r\n    \r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n                return p;\r\n            }\r\n        },\r\n        \'lavamove\': {\r\n            type: [1,[0],[1]],\r\n            customMap: (params) => {\r\n                const p = {path: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n    \r\n                p.currentPoint = params.currentPoint;\r\n    \r\n                const currentPoint = p.path[p.currentPoint];\r\n                let nextPointIndex = p.currentPoint+1;\r\n                if(nextPointIndex === p.path.length) nextPointIndex = 0;\r\n                const nextPoint = p.path[nextPointIndex];\r\n    \r\n                const totalDist = Math.sqrt((nextPoint[0]-currentPoint[0])**2+(nextPoint[1]-currentPoint[1])**2);\r\n                const fractionCovered = Math.sqrt((params.x*2-currentPoint[0])**2+(params.y*2-currentPoint[1])**2);\r\n                \r\n                p.currentPoint += fractionCovered / totalDist;\r\n    \r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n    \r\n                p.boundPlayer = false;\r\n                if(params.collidable) p.boundPlayer = true;\r\n                return p;\r\n            }\r\n        },\r\n        \'tornado\': {\r\n            type: [1,[],[23]],\r\n            spinRadius: \'tornadoStrength\' \r\n        },\r\n        \'vinette\': {\r\n            type: [1,[],[24]],\r\n            customMap: (params) => {\r\n                return {\r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o\r\n                }\r\n            }\r\n        },\r\n        \'tpmove\': {\r\n            type: [1,[0],[12]],\r\n            customMap: (params) => {\r\n                const p = {path: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n                \r\n                p.currentPoint = params.currentPoint;\r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n                p.tpx = params.tpx * 2; p.tpy = params.tpy * 2;\r\n                return p;\r\n            }\r\n        },\r\n        \'movingsafe\': {\r\n            type: [1,[0],[11]],\r\n            customMap: (params) => {\r\n                const p = {path: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n                p.currentPoint = params.currentPoint;\r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n                return p;\r\n            }\r\n        },\r\n        \'movingvinette\': {\r\n            type: [1,[0],[24]],\r\n            customMap: (params) => {\r\n                const p = {path: [],\r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o\r\n                };\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n                p.currentPoint = params.currentPoint;\r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n                return p;\r\n            }\r\n        },\r\n        \'timetrap\': {\r\n            type: [1,[],[17]],\r\n            customMap: (params) => {\r\n                //C(1,[],[17],{h:200,w:300,y:700,x:300,timeTrapToShowTenth:true,timeTrapToKill:true,timeTrapRecoverySpeed:1.5,timeTrapMaxTime:300,});\r\n                const p = {timeTrapToShowTenth:false,timeTrapToKill:true,timeTrapRecoverySpeed:params.cdmult};\r\n    \r\n                p.timeTrapMaxTime = params.maxTime * 1000;\r\n                return p;\r\n            }\r\n        },\r\n        \'oval\': {\r\n            type: [0,[],[0]],\r\n            customMap: (params) => {\r\n                return {r: Math.min(params.radius, params.radius2)*2};\r\n            }\r\n        },\r\n        \'lava-oval\': {\r\n            type: [0,[],[1]],\r\n            customMap: (params) => {\r\n                return {r: Math.min(params.radius, params.radius2)*2, boundPlayer: true};\r\n            }\r\n        },\r\n        \'safe\': {\r\n            type: [1,[],[11]],\r\n        },\r\n        \'circle-safe\': {\r\n            type: [0,[],[11]],\r\n            r: \'r\'\r\n        },\r\n        \'circle-vinette\': {\r\n            type: [0,[],[24]],\r\n            customMap: (params) => {\r\n                return {\r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o,\r\n                    r: params.r ?? params.radius\r\n                }\r\n            }\r\n        },\r\n        \'circle-coin\': {\r\n            radius: \'r\',\r\n            type: [0,[],[7]],\r\n            customMap: (params) => {\r\n                return {\r\n                    color: \'#d5d612\',\r\n                    coinAmount: 1\r\n                }\r\n            }\r\n        },\r\n        \'bounce\': {\r\n            type: [1,[],[2]],\r\n            customMap: (params) => {\r\n                return {bounciness: params.effect/3/10, decay: 0.5};\r\n            }\r\n        },\r\n        \'rotate-normal\': {\r\n            type: [1,[1],[0]],\r\n            customMap: (params) => {\r\n                params.x = params.distToPivot + params.pivotX;\r\n                params.y = params.pivotY;\r\n                return {\r\n                    x: params.x * 2 - params.w,\r\n                    y: params.y * 2 - params.h,\r\n                    initialRotation: params.angle * 180 / Math.PI,\r\n                    rotateSpeed: params.rotateSpeed / 360 / 220 * 1.36,\r\n                    pivotX: params.pivotX * 2,\r\n                    pivotY: params.pivotY * 2\r\n                };\r\n            }\r\n        },\r\n        \'rotate-lava\': {\r\n            type: [1,[1],[1]],\r\n            customMap: (params) => {\r\n                params.x = params.distToPivot + params.pivotX;\r\n                params.y = params.pivotY;\r\n                return {\r\n                    x: params.x * 2 - params.w,\r\n                    y: params.y * 2 - params.h,\r\n                    initialRotation: params.angle,\r\n                    rotateSpeed: params.rotateSpeed / 360 / 220 * 1.36,\r\n                    pivotX: params.pivotX * 2,\r\n                    pivotY: params.pivotY * 2,\r\n                    boundPlayer: params.canCollide\r\n                };\r\n            }\r\n        },\r\n        \'rotatingsafe\': {\r\n            type: [1,[1],[11]],\r\n            customMap: (params) => {\r\n                // console.log(params.angle - lastRotAngle);\r\n                // lastRotAngle = params.angle;\r\n                // lastRotAngle += Math.PI * 3/2;\r\n    \r\n                // 0: params.y += 1, x += 0\r\n                // 90: params.x -= 1, y += 0\r\n    \r\n                // params.angle = 0;\r\n    \r\n                // const rotation = params.angle * Math.PI / 180;\r\n    \r\n                // {\r\n                //     "x": 896.5984655296048,\r\n                //     "y": 1720.8819734868184,\r\n                //     "w": 25,\r\n                //     "h": 25,\r\n                //     "type": "rotatingsafe",\r\n                //     "angle": -66493.5,\r\n                //     "rotateSpeed": -90,\r\n                //     "pivotX": 925,\r\n                //     "pivotY": 1625,\r\n                //     "distToPivot": 100,\r\n                //     "canCollide": true,\r\n                //     "cullingRadius": 117.67766952966369,\r\n                //     "unSim": 0,\r\n                //     "inView": false\r\n                // },\r\n    \r\n                // in eX, position is set like this\r\n            //     obj.x =\r\n            //     Math.cos((obj.angle * Math.PI) / 180) *\r\n            //         obj.distToPivot +\r\n            //     obj.pivotX;\r\n            // obj.y =\r\n            //     Math.sin((obj.angle * Math.PI) / 180) *\r\n            //         obj.distToPivot +\r\n            //     obj.pivotY;\r\n    \r\n                // and we render like this\r\n    \r\n                // ctx.translate(center.x, center.y);\r\n                // ctx.rotate(degToRad(obstacle.angle));\r\n                // ctx.rect(\r\n                //     -obstacle.w / 2,\r\n                //     -obstacle.h / 2,\r\n                //     obstacle.w,\r\n                //     obstacle.h\r\n                // );\r\n    \r\n                // so obj.x, obj.y = centerX. \r\n    \r\n                // let angle = params.angle;\r\n    \r\n                // lets try setting angle to 0 and see what happens\r\n                // params.angle = 45;\r\n                params.x = params.distToPivot + params.pivotX;\r\n                params.y = params.pivotY;\r\n    \r\n                // they\'re in a straight line like o - ---\r\n    \r\n                // so now, lets rotate the angle around the obs center. We know that the center point of the safe is its center so lets calculate our own distToPivot from that\r\n    \r\n                // const middleX = params.x + params.w / 2;\r\n                // const middleY = params.y + params.h / 2\r\n    \r\n                // const realDistToPivot = Math.sqrt((params.x - params.pivotX) ** 2 + (params.y - params.pivotY) ** 2);\r\n    \r\n                // // // now we have that, we can set the x and y\r\n    \r\n                // // // params.angle = angle;\r\n                // const x = Math.cos(params.angle * Math.PI / 180) * dist + params.pivotX - params.w / 2;\r\n                // const y = Math.sin(params.angle * Math.PI / 180) * dist + params.pivotY - params.h / 2;\r\n    \r\n                return {\r\n                    // x:x*2,y:y*2,initialRotation: 0,\r\n                    x: params.x * 2 - params.w,\r\n                    y: params.y * 2 - params.h,\r\n                    initialRotation: params.angle,\r\n                    rotateSpeed: params.rotateSpeed / 360 / 220 * 1.36,\r\n                    pivotX: params.pivotX * 2,\r\n                    pivotY: params.pivotY * 2\r\n                };\r\n            }\r\n        },\r\n        \'rotatingvinette\': {\r\n            type: [1,[1],[24]],\r\n            customMap: (params) => {\r\n                params.x = params.distToPivot + params.pivotX;\r\n                params.y = params.pivotY;\r\n    \r\n                return {\r\n                    x: params.x * 2 - params.w,\r\n                    y: params.y * 2 - params.h,\r\n                    initialRotation: params.angle,\r\n                    rotateSpeed: params.rotateSpeed / 360 / 220 * 1.36,\r\n                    pivotX: params.pivotX * 2,\r\n                    pivotY: params.pivotY * 2,\r\n                    \r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o\r\n                \r\n                };\r\n            }\r\n        },\r\n        \'check\': {\r\n            type: [1,[],[9]],\r\n            customMap: (params) => {\r\n                return {\r\n                    checkpointOffsetX: 0,\r\n                    checkpointOffsetY: 0\r\n                }\r\n            }\r\n        },\r\n        \'tp\': {\r\n            type: [1,[],[12]],\r\n            customMap: (params) => {\r\n                return {\r\n                    tpx: params.tpx * 2,\r\n                    tpy: params.tpy * 2\r\n                }\r\n            }\r\n        },\r\n        \'winpad\': {\r\n            type: [1,[],[6]]\r\n        },\r\n        \'speed\': {\r\n            type: [1,[],[19]],\r\n            customMap: (params) => {\r\n                return {\r\n                    speedChangePermanent: false,\r\n                    speedMult: params.speedInc\r\n                }\r\n            }\r\n        },\r\n        \'size\': {\r\n            type: [1,[],[18]],\r\n            customMap: (params) => {\r\n                return {\r\n                    sizeChangePermanent: false,\r\n                    sizeMult: params.size / 24.5\r\n                }\r\n            }\r\n            //C(1,[],[18],{h:200,w:300,y:700,x:300,sizeChangePermanent:false,sizeMult:1.5,});\r\n        },\r\n        \'snap\': {\r\n            type: [1,[],[16]],\r\n            customMap: (params) => {\r\n                return {\r\n                    snapAngleRotateSpeed: 0,\r\n                    snapAngle: 0,\r\n                    snapCooldown: params.snapWait,\r\n                    snapDistanceY: params.snapDistance,\r\n                    snapDistanceX: params.snapDistance,\r\n                    toSnapX: params.snapX,\r\n                    toSnapY: params.snapY\r\n                }\r\n            }\r\n            // {\r\n            //     "x": 11050,\r\n            //     "y": 1550,\r\n            //     "w": 900,\r\n            //     "h": 500,\r\n            //     "type": "snap",\r\n            //     "snapDistance": 50,\r\n            //     "snapWait": 0.4,\r\n            //     "snapX": true,\r\n            //     "snapY": true,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        \'coin\': {\r\n            type: [1,[],[7]],\r\n            customMap: (params) => {\r\n                return {\r\n                    color: \'#d5d612\',\r\n                    coinAmount: 1\r\n                }\r\n            }\r\n        },\r\n        \'coindoor\': {\r\n            type: [1,[],[8]],\r\n            customMap: (params) => {\r\n                return {\r\n                    coinDoorColor: \'#d5d612\',\r\n                    coindoorCoinAmount: params.coins\r\n                }\r\n            }\r\n        },\r\n        \'button\': {\r\n            type: [1,[],[7]],\r\n            customMap: (params) => {\r\n                const top = {\r\n                    "x": 14941.438100925527,\r\n                    "y": 5495.870128796381\r\n                };\r\n                const bottom = {\r\n                    "x": 18420.158621406357,\r\n                    "y": 8873.08670452917\r\n                };\r\n                const x = params.x * 2;\r\n                const y = params.y * 2;\r\n                const inside = x > top.x && x < bottom.x && y > top.y && y < bottom.y;\r\n                return {\r\n                    color: inside ? \'#00FF00\' : \'#d6d612\',\r\n                    coinAmount: 1\r\n                }\r\n            }\r\n        },\r\n        \'door\': {\r\n            type: [1,[],[8]],\r\n            customMap: (params) => {\r\n                const id = params.id;\r\n                let coinAmount = 0;\r\n                for(let i = 0; i < obs.length; i++){\r\n                    if(obs[i].type === \'button\' && obs[i].id === id){\r\n                        coinAmount++;\r\n                    }\r\n                }\r\n                const top = {\r\n                    "x": 14941.438100925527,\r\n                    "y": 5495.870128796381\r\n                };\r\n                const bottom = {\r\n                    "x": 18420.158621406357,\r\n                    "y": 8873.08670452917\r\n                };\r\n                const x = params.x * 2;\r\n                const y = params.y * 2;\r\n                const inside = x > top.x && x < bottom.x && y > top.y && y < bottom.y;\r\n                return {\r\n                    coinDoorColor: inside ? \'#00FF00\' : \'#d6d612\',\r\n                    coindoorCoinAmount: inside ? 5 : coinAmount\r\n                }\r\n            }\r\n        },\r\n        \'raxis\': {\r\n            type: [1,[],[15]],\r\n            customMap: (params) => {\r\n                return {\r\n                    axisSpeedMultY: params.ry === true ? 0 : 1,\r\n                    axisSpeedMultX: params.rx === true ? 0 : 1\r\n                }\r\n            }\r\n        },\r\n        \'push\': {\r\n            type: [1,[],[25]],\r\n            customMap: (params) => {\r\n                return {\r\n                    pushAngle: {\'right\': 180, \'down\': 270, \'left\': 0, \'right\': 90}[params.dir],\r\n                    maxPushDistance: params.max * 2,\r\n                    idlePushBackSpeed: params.pushBack / 20,\r\n                    positiveDirectionOnly: true,\r\n                    pushConversionRatio: 0.86\r\n                }\r\n            }\r\n        },//C(3,[],[20],{fontSize:80,text:\'I am a text :D\',y:800,x:450,hex:colourRgb(100,100,100),});\r\n        \'text\': {\r\n            customMap: (params) => {\r\n                // {\r\n                //     "x": 300,\r\n                //     "y": 75,\r\n                //     "angle": 0,\r\n                //     "text": "Welcome to the",\r\n                //     "size": 30,\r\n                //     "story": false,\r\n                //     "element": {\r\n                //         "tWidth": 0,\r\n                //         "tHeight": 0\r\n                //     }\r\n                // },\r\n                if(params.angle !== 0) {\r\n                    return {\r\n                        type: [3,[1],[20]],\r\n                        fontSize: params.size * 2,\r\n                        text: params.text,\r\n                        hex: \'#FFFFFF\',\r\n                        pivotX: params.x * 2,\r\n                        pivotY: params.y * 2,\r\n                        rotateSpeed: 0,\r\n                        initialRotation: params.angle,\r\n                    }\r\n                }//"C(3,[1],[20],{fontSize:80,text:\'I am a text :D\',y:800,x:450,pivotY:800,pivotX:450,rotateSpeed:0,initialRotation:45,hex:colourRgb(100,100,100),});"\r\n                else {\r\n                    return {\r\n                        type: [3,[],[20]],\r\n                        fontSize: params.size * 2,\r\n                        text: params.text,\r\n                        hex: \'#FFFFFF\'\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \'platformer\': {\r\n            type: [1,[],[14]],\r\n            customMap: (params) => {\r\n                const p = {};\r\n                if(params.direction === \'right\'){\r\n                    p.platformerAngle = 0\r\n                } else if(params.direction === \'down\'){\r\n                    p.platformerAngle = 90;\r\n                } else if(params.direction === \'left\'){\r\n                    p.platformerAngle = 180;\r\n                } else {\r\n                    p.platformerAngle = 270;\r\n                }\r\n                p.platformerFriction = 0.9;\r\n                p.platformerAngleRotateSpeed = 0;\r\n                p.platformerForce = params.force / 10000 * 1.5 * 1.8 * 1.6 * 10 / 16.66;\r\n                p.jumpForce = params.jumpHeight / 10 / 8.2 * 2.32 / 1.2 / 2;\r\n                p.jumpDecay = 0.9525;\r\n                p.maxJumpCooldown = 20 * 16.6;\r\n                return p;\r\n            }\r\n            // {\r\n            //     "x": 6600,\r\n            //     "y": 300,\r\n            //     "w": 500,\r\n            //     "h": 350,\r\n            //     "type": "platformer",\r\n            //     "force": 1500,\r\n            //     "dir": {\r\n            //         "x": 0,\r\n            //         "y": 1500\r\n            //     },\r\n            //     "direction": "down",\r\n            //     "jumpHeight": 145,\r\n            //     "maxForce": 1000,\r\n            //     "variableJumpHeight": false,\r\n            //     "platformerFriction": 0.8,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        \'breakable\': {\r\n            type: [1,[],[10]],\r\n            customMap: (params) => {\r\n                return {\r\n                    maxStrength: Math.max(200,params.maxStrength * Math.max(1,params.timer * 1000 / 60)),\r\n                    regenTime: params.regenTime * 1000 / 15,\r\n                    healSpeed: 1\r\n                }\r\n            }\r\n        },\r\n        // C(1,[],[10],{h:200,w:300,y:700,x:300,healSpeed:1,regenTime:100,maxStrength:60,});\r\n        // {\r\n        //     "x": 2950,\r\n        //     "y": 2650,\r\n        //     "w": 200,\r\n        //     "h": 50,\r\n        //     "type": "breakable",\r\n        //     "maxStrength": 40,\r\n        //     "currentStrength": 40,\r\n        //     "time": 0,\r\n        //     "timer": 0,\r\n        //     "regenTime": 3,\r\n        //     "inView": false\r\n        // },\r\n        \r\n    \r\n        // {\r\n        //     "x": 8550,\r\n        //     "y": 9500,\r\n        //     "radius": 300,\r\n        //     "type": "circle-hollow-slice",\r\n        //     "startAngle": 1.5707963267948966,\r\n        //     "endAngle": -1.5707963267948966,\r\n        //     "startPolygon": {\r\n        //         "points": [\r\n        //             [\r\n        //                 8550,\r\n        //                 9650\r\n        //             ],\r\n        //             [\r\n        //                 8550,\r\n        //                 9800\r\n        //             ]\r\n        //         ],\r\n        //         "type": "poly",\r\n        //         "props": {}\r\n        //     },\r\n        //     "endPolygon": {\r\n        //         "points": [\r\n        //             [\r\n        //                 8550,\r\n        //                 9350\r\n        //             ],\r\n        //             [\r\n        //                 8550,\r\n        //                 9200\r\n        //             ]\r\n        //         ],\r\n        //         "type": "poly",\r\n        //         "props": {}\r\n        //     },\r\n        //     "innerRadius": 150,\r\n        //     "toRotate": false,\r\n        //     "rotateSpeed": 0,\r\n        //     "renderType": "circle",\r\n        //     "inView": false\r\n        // },\r\n        \'circle-hollow-slice\': {\r\n            type: [4,[],[0]],\r\n            customMap: (params) => {\r\n                return {\r\n                    r: params.radius * 2,\r\n                    innerRadius: params.innerRadius * 2,\r\n                    startSliceAngle: params.startAngle,\r\n                    endSliceAngle: params.endAngle,\r\n                    startSliceAngleRotateSpeed: params.rotateSpeed / 2000,\r\n                    endSliceAngleRotateSpeed: params.rotateSpeed / 2000\r\n                }\r\n            }\r\n        },\r\n    \r\n        \'circle-slice\': {\r\n            type: [4,[],[0]],\r\n            customMap: (params) => {\r\n                return {\r\n                    r: params.radius * 2,\r\n                    innerRadius: 0,\r\n                    startSliceAngle: params.startAngle,\r\n                    endSliceAngle: params.endAngle,\r\n                    startSliceAngleRotateSpeed: 0,\r\n                    endSliceAngleRotateSpeed: 0\r\n                }\r\n            }\r\n        },\r\n    \r\n        \'ship\': {\r\n            type: [1,[],[27]],\r\n            customMap: (params) => {\r\n                return {\r\n                    changeShipStateTo: params.state,\r\n                    initialShipAngle: -Math.PI / 2,\r\n                    shipTurnSpeed: Math.PI / 20 / 16.66 / 2\r\n                }\r\n            }\r\n        },\r\n    \r\n        \'musicchange\': {\r\n            type: [1,[],[26]],\r\n            customMap: (params) => {\r\n                return {\r\n                    x: params.x * 2,\r\n                    y: params.y * 2,\r\n                    w: params.w * 2,\r\n                    h: params.h * 2,\r\n                    musicPath: params.musicPath\r\n                };\r\n            }\r\n        },\r\n    \r\n        \'grpu\': {\r\n            type: [1,[],[28]],\r\n            customMap: (params) => {\r\n                return {\r\n                    changeGrappleStateTo: params.state,       \r\n                    grappleRange: 488,\r\n                    grappleForce: 0.06,\r\n                    grappleFric: 0.8,\r\n                };\r\n            }\r\n        },\r\n    }\r\n    \r\n    const enemyTypeMap = {\r\n        normal: (params) => {\r\n            const bounds = {\r\n                x: params.bound.x * 2,\r\n                y: params.bound.y * 2,\r\n                w: params.bound.w * 2,\r\n                h: params.bound.h * 2\r\n            };\r\n            counter++;\r\n            return `\r\n            var xv${counter} = ${params.xv/30};\r\n            var yv${counter} = ${params.yv/30};\r\n            C(0,[3],[1],{r:${params.radius*2},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n            e.pos.y += yv${counter};\r\n            e.pos.x += xv${counter};\r\n            if ((e.pos.x - e.sat.r) < ${bounds.x} || e.pos.x + e.sat.r > ${bounds.x + bounds.w}) {\r\n                xv${counter} = xv${counter} * -1;\r\n            }\r\n            if ((e.pos.y - e.sat.r) < ${bounds.y} || e.pos.y + e.sat.r > ${bounds.y + bounds.h}) {\r\n                yv${counter} = yv${counter} * -1;\r\n            }\r\n            },});\r\n            `\r\n            // {\r\n            //     "type": "normal",\r\n            //     "angle": 5.874603837535309,\r\n            //     "radius": 16,\r\n            //     "speed": 85,\r\n            //     "x": 6898.622849512051,\r\n            //     "y": 4711.556031428228,\r\n            //     "renderX": 6898.622849512051,\r\n            //     "renderY": 4711.556031428228,\r\n            //     "xv": 78.00325384310767,\r\n            //     "yv": 33.77117691001763,\r\n            //     "bound": {\r\n            //         "x": 6400,\r\n            //         "y": 4250,\r\n            //         "w": 600,\r\n            //         "h": 700\r\n            //     },\r\n            //     "isLava": false,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        square: (params) => {\r\n            const bounds = {\r\n                x: params.bound.x * 2,\r\n                y: params.bound.y * 2,\r\n                w: params.bound.w * 2,\r\n                h: params.bound.h * 2\r\n            };\r\n            const size = params.size;\r\n            counter++;\r\n            return `\r\n            var xv${counter} = ${params.xv/42};\r\n            var yv${counter} = ${params.yv/42};\r\n            C(1,[3],[1],{w:${size},h:${size},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n            e.pos.y += yv${counter};\r\n            e.pos.x += xv${counter};\r\n            if ((e.pos.x) < ${bounds.x} || e.pos.x + ${size} > ${bounds.x + bounds.w}) {\r\n                xv${counter} = xv${counter} * -1;\r\n            }\r\n            if ((e.pos.y) < ${bounds.y} || e.pos.y + ${size} > ${bounds.y + bounds.h}) {\r\n                yv${counter} = yv${counter} * -1;\r\n            }\r\n            },});\r\n            `\r\n            // {\r\n            //     "type": "normal",\r\n            //     "angle": 5.874603837535309,\r\n            //     "radius": 16,\r\n            //     "speed": 85,\r\n            //     "x": 6898.622849512051,\r\n            //     "y": 4711.556031428228,\r\n            //     "renderX": 6898.622849512051,\r\n            //     "renderY": 4711.556031428228,\r\n            //     "xv": 78.00325384310767,\r\n            //     "yv": 33.77117691001763,\r\n            //     "bound": {\r\n            //         "x": 6400,\r\n            //         "y": 4250,\r\n            //         "w": 600,\r\n            //         "h": 700\r\n            //     },\r\n            //     "isLava": false,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        turret: (params) => {\r\n            // {\r\n            //     "type": "turret",\r\n            //     "angle": 3.6232766945442836,\r\n            //     "shootSpeed": 3.58,\r\n            //     "timer": 2.2316666666694256,\r\n            //     "pRadius": 32,\r\n            //     "pSpeed": 120,\r\n            //     "projectiles": [\r\n            //         {\r\n            //             "x": 4291,\r\n            //             "y": 3450,\r\n            //             "angle": 0\r\n            //         },\r\n            //         {\r\n            //             "x": 3862,\r\n            //             "y": 3450,\r\n            //             "angle": 0\r\n            //         }\r\n            //     ],\r\n            //     "shootDirections": [\r\n            //         0\r\n            //     ],\r\n            //     "csd": 0,\r\n            //     "deadProjectiles": [],\r\n            //     "radius": 32,\r\n            //     "speed": 0,\r\n            //     "x": 3700,\r\n            //     "y": 3450,\r\n            //     "renderX": 3700,\r\n            //     "renderY": 3450,\r\n            //     "xv": 0,\r\n            //     "yv": 0,\r\n            //     "bound": {\r\n            //         "x": 3650,\r\n            //         "y": 3400,\r\n            //         "w": 850,\r\n            //         "h": 100\r\n            //     },\r\n            //     "inView": true\r\n            // },\r\n            const bounds = {\r\n                x: params.bound.x * 2,\r\n                y: params.bound.y * 2,\r\n                w: params.bound.w * 2,\r\n                h: params.bound.h * 2\r\n            };\r\n            counter++;\r\n            const shootSpeed = params.shootSpeed * 1000 / 15;\r\n            const projectileParams = {\r\n                speed: params.pSpeed / 42,\r\n                radius: params.pRadius * 2,\r\n                shootDirections: params.shootDirections,\r\n            }\r\n            const c = counter;\r\n            return `\r\n            var xv${c} = ${params.xv/42};\r\n            var yv${c} = ${params.yv/42};\r\n            var shootDirectionIndex${c} = 0;\r\n            var timer${c} = ${shootSpeed};\r\n            C(0,[3],[1],{r:${params.radius},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n            e.pos.y += yv${c};\r\n            e.pos.x += xv${c};\r\n            if ((e.pos.x - e.sat.r) < ${bounds.x} || e.pos.x + e.sat.r > ${bounds.x + bounds.w}) {\r\n                xv${c} = xv${c} * -1;\r\n            }\r\n            if ((e.pos.y - e.sat.r) < ${bounds.y} || e.pos.y + e.sat.r > ${bounds.y + bounds.h}) {\r\n                yv${c} = yv${c} * -1;\r\n            }\r\n    \r\n            timer${c}--;\r\n            if(timer${c} < 0){\r\n                timer${c} = ${shootSpeed};\r\n    \r\n                shootDirectionIndex${c}++;\r\n                const shootDirections = [${projectileParams.shootDirections.toString()}];\r\n                if(shootDirectionIndex${c} >= shootDirections.length){\r\n                    shootDirectionIndex${c} = 0;\r\n                }\r\n                let dir = shootDirections[shootDirectionIndex${c}];\r\n    \r\n                counter++;\r\n                /*scoped using let*/\r\n                let xv${counter} = Math.cos(dir) * ${projectileParams.speed};\r\n                let yv${counter} = Math.sin(dir) * ${projectileParams.speed};\r\n                C(0,[3],[1],{r:${projectileParams.radius},y:e.pos.y,x:e.pos.x,sf:(e)=>{\r\n                e.pos.y += yv${counter};\r\n                e.pos.x += xv${counter};\r\n                /*delete obstacle*/\r\n                if ((e.pos.x - e.sat.r) < ${bounds.x} || e.pos.x + e.sat.r > ${bounds.x + bounds.w} || (e.pos.y - e.sat.r) < ${bounds.y} || e.pos.y + e.sat.r > ${bounds.y + bounds.h}) {\r\n                    window.tickFns.push(()=>{\r\n                        for(let i = 0; i < obstacles.length; i++){\r\n                            if(obstacles[i] === e) {obstacles.splice(i,1); break;}\r\n                        }\r\n                        /*for(let key in window.idToObs){\r\n                            if(window.idToObs[key] === e){delete window.idToObs[key]; break;}\r\n                        }*/\r\n                    });\r\n                }\r\n                },});\r\n            }\r\n    \r\n            },});\r\n            `\r\n        },\r\n        switch: (params) => {\r\n            // {\r\n            //     "type": "switch",\r\n            //     "angle": 0.6586898029125109,\r\n            //     "switchTime": 3.2,\r\n            //     "switchTimer": 2.3083333333306277,\r\n            //     "currentSwitch": true,\r\n            //     "radius": 25,\r\n            //     "speed": 22,\r\n            //     "x": 2557.5655869230604,\r\n            //     "y": 4628.602260600484,\r\n            //     "renderX": 2557.5655869230604,\r\n            //     "renderY": 4628.602260600484,\r\n            //     "xv": -17.397486856740482,\r\n            //     "yv": 13.465788171122483,\r\n            //     "bound": {\r\n            //         "x": 2400,\r\n            //         "y": 4150,\r\n            //         "w": 350,\r\n            //         "h": 650\r\n            //     },\r\n            //     "inView": false\r\n            // },\r\n            const bounds = {\r\n                x: params.bound.x * 2,\r\n                y: params.bound.y * 2,\r\n                w: params.bound.w * 2,\r\n                h: params.bound.h * 2\r\n            };\r\n            counter++;\r\n            const maxSwitchTime = params.switchTime*1000/16; \r\n            return `\r\n            var xv${counter} = ${params.xv/42*4};\r\n            var yv${counter} = ${params.yv/42*4};\r\n            var switchTime${counter} = ${maxSwitchTime*Math.random()*2};\r\n            var switchState${counter} = true;\r\n            var pos${counter} = {\r\n                x: ${params.x*2}, y: ${params.y*2} \r\n            }\r\n            C(0,[3],[1],{r:${params.radius},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n                pos${counter}.y += yv${counter};\r\n                pos${counter}.x += xv${counter};\r\n                if ((pos${counter}.x - e.sat.r) < ${bounds.x} || pos${counter}.x + e.sat.r > ${bounds.x + bounds.w}) {\r\n                    xv${counter} = xv${counter} * -1;\r\n                }\r\n                if ((pos${counter}.y - e.sat.r) < ${bounds.y} || pos${counter}.y + e.sat.r > ${bounds.y + bounds.h}) {\r\n                    yv${counter} = yv${counter} * -1;\r\n                }\r\n    \r\n                if(switchState${counter} === true){\r\n                    e.pos.x = pos${counter}.x;\r\n                    e.pos.y = pos${counter}.y;\r\n                } else {\r\n                    e.pos.x = -100000;\r\n                }\r\n    \r\n                switchTime${counter}--;\r\n                if(switchTime${counter} <= 0){\r\n                    switchTime${counter} = ${params.switchTimer*1000/15};\r\n                    switchState${counter} = !switchState${counter};\r\n                    if(switchState${counter} === true){\r\n                        /*if we\'re switching on, reset to pos we were on. This wasn\'t how the enemy worked before but it\'s ok*/\r\n                        e.pos.x = pos${counter}.x;\r\n                        e.pos.y = pos${counter}.y;\r\n                    }\r\n                }\r\n            }});\r\n            C(0,[3],[0],{r:${params.radius},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n                if(switchState${counter} === true){\r\n                    e.pos.x = -100000;\r\n                } else {\r\n                    e.pos.x = pos${counter}.x;\r\n                    e.pos.y = pos${counter}.y;\r\n                }\r\n            }});\r\n            `\r\n            // {\r\n            //     "type": "normal",\r\n            //     "angle": 5.874603837535309,\r\n            //     "radius": 16,\r\n            //     "speed": 85,\r\n            //     "x": 6898.622849512051,\r\n            //     "y": 4711.556031428228,\r\n            //     "renderX": 6898.622849512051,\r\n            //     "renderY": 4711.556031428228,\r\n            //     "xv": 78.00325384310767,\r\n            //     "yv": 33.77117691001763,\r\n            //     "bound": {\r\n            //         "x": 6400,\r\n            //         "y": 4250,\r\n            //         "w": 600,\r\n            //         "h": 700\r\n            //     },\r\n            //     "isLava": false,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        flashlight: (params) => {\r\n            if(Math.random() < 0.5) return \'\';\r\n            return enemyTypeMap.turret({\r\n                "type": "turret",\r\n                "angle": params.angle,\r\n                "shootSpeed": 1.54,\r\n                "timer": 0,\r\n                "pRadius": params.radius * (Math.random()*0.8 + 0.2),\r\n                "pSpeed": params.speed * (1.65+Math.random()),\r\n                "projectiles": [],\r\n                "shootDirections": [\r\n                    0, Math.PI / 2, Math.PI, Math.PI * 3/2\r\n                ],\r\n                "csd": 0,\r\n                "deadProjectiles": [],\r\n                "radius": params.radius,\r\n                "speed": params.speed,\r\n                "x": params.x,\r\n                "y": params.y,\r\n                "renderX": params.renderX,\r\n                "renderY": params.renderY,\r\n                "xv": params.xv,\r\n                "yv": params.yv,\r\n                "bound": params.bound,\r\n                "inView": false\r\n            },)\r\n        }\r\n    }\r\n\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n\r\n    const alreadyLogged = {};\r\n\r\n    var str = \'\';\r\n\r\n    let alreadyLoggedEnemy = {};\r\n    for(let i = 0; i < enemies.length; i++){\r\n        if(enemyTypeMap[enemies[i].type] !== undefined){\r\n            str += \'\\n\' + enemyTypeMap[enemies[i].type](enemies[i]);\r\n        } else if(alreadyLoggedEnemy[enemies[i].type] === undefined){\r\n            alreadyLoggedEnemy[enemies[i].type] = true;\r\n            console.log(`no enemy type def for ${enemies[i].type}`);\r\n        }\r\n    }\r\n\r\n    for(let i = 0; i < obs.length; i++){\r\n        const o = obs[i];\r\n        const typeDef = typeMap[o.type];\r\n\r\n        if(o.type === \'roundedcorners\' || o.type === \'roundedlava\'){\r\n            const circleType = o.type === \'roundedcorners\' ? \'circle-normal\' : \'circle-lava\';\r\n            for(let i = 0; i < o.circles.length; i++){\r\n                obs.push({\r\n                    x: o.circles[i].x,\r\n                    y: o.circles[i].y,\r\n                    radius: o.circles[i].radius,\r\n                    "renderType": "circle",\r\n                    "inView": false,\r\n                    type: circleType\r\n                })\r\n            }\r\n            const rectType = o.type === \'roundedcorners\' ? \'normal\' : \'lava\';\r\n            for(let i = 0; i < o.rects.length; i++){\r\n                obs.push({\r\n                    x: o.rects[i].x,\r\n                    y: o.rects[i].y,\r\n                    w: o.rects[i].w,\r\n                    h: o.rects[i].h,\r\n                    type: rectType\r\n                })\r\n            }\r\n            continue;\r\n        } else if(o.type === \'color\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            const minX = o.x - 100;\r\n            const minY = o.y - 100;\r\n            const maxX = o.x + o.w + 100;\r\n            const maxY = o.y + o.h + 100;\r\n            str += `var minX${counter}, minY${counter}, maxX${counter}, maxY${counter};\r\n            minX${counter} = ${minX};minY${counter} = ${minY};maxX${counter} = ${maxX};maxY${counter} = ${maxY};\r\n            C(1,[3],[0],{h:1,w:1,y:0,x:-10000,sf:(e)=>{\r\n                const player = window.players[window.selfId];\r\n                if ((player.pos.x) > md(minX${counter}) && (player.pos.x) < md(maxX${counter}) && (player.pos.y) > md(minY${counter}) && (player.pos.y) < md(maxY${counter})) {\r\n                    colors.background="${o.tileColor}"; colors.tile="${o.bgColor}";\r\n                }\r\n            },});\\n`;\r\n            counter++;\r\n        } else if(o.type === \'switchlava\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            str += `var timer${counter} = ${o.timer}; var state${counter} =${o.state}; var x${counter} = ${o.x}; \r\n            C(1,[],[1],{h:${o.h},w:${o.w},y:${o.y},x:${o.x},sf:(e)=>{\r\n                    timer${counter} -= dt / 1000;\r\n                    if(timer${counter} < 0){\r\n                        state${counter} = !state${counter};\r\n                        if(state${counter} === true){\r\n                            // on\r\n                            timer${counter} += ${o.onTime};\r\n                            e.pos.x = x${counter};\r\n                        } else {\r\n                            // off\r\n                            timer${counter} += ${o.offTime};\r\n                            e.pos.x = -1E9;\r\n                        }\r\n                    }\r\n                },\r\n                cr:(e)=>{\r\n                    ctx.beginPath();\r\n                    \r\n                    if (state${counter}) {\r\n                        if (timer${counter} < 0.2 && ${o.onTime} > 0.2) {\r\n                            ctx.globalAlpha = timer${counter} / 0.2;\r\n                        }\r\n                    } else {\r\n                        ctx.globalAlpha = 0.3;\r\n                        if (timer${counter} < 0.2 && ${o.offTime} > 0.2) {\r\n                            ctx.globalAlpha = 0.9 * (1 - timer${counter} / 0.2) + 0.1;\r\n                        }\r\n                    }\r\n                    ctx.fillStyle = ${o.collidable} ? \'#c70000\' : \'#9e0000\';\r\n                    /*if (obstacle.collidable) {\r\n                        ctx.fillStyle = \'#c70000\';\r\n                    }*/ \r\n\r\n                    ctx.lineWidth = 4;\r\n                    ctx.strokeStyle = \'black\';\r\n                    ctx.rect(x${counter}, e.pos.y, e.dimensions.x, e.dimensions.y);\r\n                    ctx.fill();\r\n                    ctx.stroke();\r\n                    ctx.closePath();\r\n                    ctx.globalAlpha = 1;\r\n                }\r\n            });\\n`;\r\n            counter++;\r\n        } else if(o.type === \'block\' || o.type === \'trans\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            str += `C(1,[],[20],{h:${o.h},w:${o.w},y:${o.y},x:${o.x},\r\n                cr:(e)=>{\r\n                    ctx.beginPath();\r\n                    ctx.lineWidth = 2;\r\n                    ctx.strokeStyle = ctx.fillStyle = ${o.type === \'trans\' ? "colors.background" : "\'" + (o.hex ?? o.color) + "\'"};\r\n                    ctx.globalAlpha = ${o.opaq ?? 1};\r\n                    ctx.rect(e.pos.x, e.pos.y, e.dimensions.x, e.dimensions.y);\r\n                    ctx.fill();\r\n                    ctx.stroke();\r\n                    ctx.closePath();\r\n                    ctx.globalAlpha = 1;\r\n                }\r\n            });\\n`;\r\n            counter++;\r\n            continue;\r\n        } else if(o.type === \'grapplepoint\' || o.type === \'movinggrapplepoint\'){\r\n            o.x *= 2; o.y *= 2;\r\n            if(o.type === \'grapplepoint\'){\r\n                str += `C(0,[],[0],{r:20+12/2,y:${o.y},x:${o.x},\r\n                    cr:(e)=>{\r\n                        e.isGrapplePoint = true;\r\n                        ctx.strokeStyle = \'#c9c9c9\';\r\n                        ctx.lineWidth = 12;\r\n                        ctx.globalAlpha = 0.5;\r\n                        ctx.beginPath();\r\n                        ctx.arc(e.pos.x, e.pos.y, 20, 0, Math.PI * 2);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        ctx.globalAlpha = 1;\r\n                    }\r\n                });\\n`;\r\n            } else {\r\n                const params = o;\r\n                const p = {path: \'[\'};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path += `[${params.points[i][0]*2},[${params.points[i][1]*2}],${params.speed * 2 / 1000}],`;\r\n                }\r\n\r\n                p.currentPoint = params.currentPoint;\r\n                p.x = params.points[0][0] * 2;\r\n                p.y = params.points[0][1] * 2;\r\n\r\n                p.path = p.path.substring(0, p.path.length-1);\r\n                p.path += \']\';\r\n                str += `C(0,[0],[0],{r:20+12/2,\r\n                    cr:(e)=>{\r\n                        e.isGrapplePoint = true;\r\n                        ctx.strokeStyle = \'#c9c9c9\';\r\n                        ctx.lineWidth = 12;\r\n                        ctx.globalAlpha = 0.5;\r\n                        ctx.beginPath();\r\n                        ctx.arc(e.pos.x, e.pos.y, 20, 0, Math.PI * 2);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        ctx.globalAlpha = 1;\r\n                    },currentPoint:${p.currentPoint},x:${p.x},y:${p.y},path:${p.path}\r\n                });\\n`;\r\n            }\r\n            counter++;\r\n            continue;\r\n        } else if(o.type === \'circle-sentry\'){\r\n            o.x *= 2; o.y *= 2; o.r *= 2;\r\n            o.laser.x *= 2; o.laser.y *= 2; o.laser.w *= 2; o.laser.h *= 2;\r\n            str += `C(1,[5],[1],{h:${o.laser.h},w:${o.laser.w},y:${o.y-o.laser.h/2},x:${o.x-o.laser.w/2},\r\n                boundPlayer: true,\r\n                restAngles: [${o.rest*Math.PI/180}, ${o.rest*Math.PI/180+Math.PI}],\r\n                toRest: true,\r\n                homingRotateSpeed: ${o.speed / 86000},\r\n                detectionRadius: ${Math.sqrt(o.laser.w**2+o.laser.h**2)/2},\r\n                spokeAngles: [0, Math.PI],\r\n                pivotX: ${o.x},\r\n                pivotY: ${o.y}\r\n            });\r\n            C(0,[],[0],{x:${o.x},y:${o.y},r:${o.r},cr:(e)=>{\r\n                ctx.fillStyle = window.colors.tile;\r\n                ctx.beginPath();\r\n                ctx.arc(e.pos.x, e.pos.y, e.sat.r, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                ctx.closePath();\r\n\r\n                ctx.strokeStyle = \'red\';\r\n                ctx.lineWidth = 15;\r\n                ctx.beginPath();\r\n                ctx.arc(\r\n                    e.pos.x,\r\n                    e.pos.y,\r\n                    Math.max(e.sat.r - 30, 0),\r\n                    0,\r\n                    Math.PI * 2\r\n                );\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            }});`\r\n            counter++;\r\n            continue;\r\n        } else if(o.type === \'resetcoins\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            str += `C(1,[],[20],{x:${o.x},y:${o.y},w:${o.w},h:${o.h},hex:\'#000000\',alpha:0,cr:()=>{},ef:()=>{\r\n                for(let i = 0; i < obstacles.length; i++){\r\n                    if(obstacles[i].collected !== undefined){\r\n                        obstacles[i].collected = false;\r\n                    } else if(obstacles[i].isCoindoor === true){\r\n                        obstacles[i].coins = obstacles[i].maxCoins; \r\n                    }\r\n                }    \r\n            }});`;\r\n            continue;\r\n        } else if(o.type === \'resettimetraps\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            str += `C(1,[],[20],{x:${o.x},y:${o.y},w:${o.w},h:${o.h},hex:\'#000000\',alpha:0,cr:()=>{},ef:()=>{\r\n                for(let i = 0; i < obstacles.length; i++){\r\n                    if(obstacles[i].timeTrapTime !== undefined){\r\n                        obstacles[i].timeTrapTime = obstacles[i].timeTrapMaxTime;\r\n                    }\r\n                }    \r\n            }});`;\r\n            continue;\r\n        }\r\n\r\n        if(typeDef === undefined) {\r\n            if(alreadyLogged[o.type] === undefined){\r\n                alreadyLogged[o.type] = true;\r\n                console.log(\'no type def for \' + o.type);\r\n            }\r\n            \r\n            continue;\r\n        }\r\n\r\n        const params = {type: typeDef.type};\r\n\r\n        for(let key in o){\r\n            if(key === \'type\') continue;\r\n            if(typeDef[key] !== undefined) {\r\n                params[typeDef[key]] = o[key];// o.r instead of o.radius set to o[key] \r\n            } else {\r\n                params[key] = o[key];\r\n            }\r\n        }\r\n\r\n        params.x *= 2;\r\n        params.y *= 2;\r\n        if(params.w) params.w *= 2;\r\n        if(params.h) params.h *= 2;\r\n        if(params.r !== undefined) params.r *= 2;\r\n\r\n        if(typeDef.customMap !== undefined){\r\n            const moreParams = typeDef.customMap(o);\r\n            for(let key in moreParams){\r\n                params[key] = moreParams[key];\r\n            }\r\n        }\r\n        \r\n        let paramString = `{`;\r\n        for(let key in params){\r\n            paramString += `${key}:${JSON.stringify(params[key])},`;\r\n        }\r\n        paramString += \'}\';\r\n\r\n        let typeString = JSON.stringify(params.type);\r\n        typeString = typeString.slice(1, typeString.length-1);\r\n\r\n        //C(1,[],[0],{h:100,w:1100,y:4300,x:4600,});\r\n        str += `C(${typeString},${paramString})\\n`;\r\n    }\r\n\r\n    eval(str);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (importMap);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29tbmlzZXJ2ZXIvLi9lWGNsaWVudC9leHRyYXMvaW1wb3J0TWFwLmpzPzRiYmEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaW1wb3J0TWFwKHN0cil7XHJcbiAgICBvYnN0YWNsZXMubGVuZ3RoID0gMDtcclxuXHJcbiAgICBjb25zdCBvID0gSlNPTi5wYXJzZShzdHIpO1xyXG5cclxuICAgIGxldCB7YXJlbmEsIHNhZmVzLCBzcGF3bnMsIHBsYXllclNwYXduLCB0aWxlQ29sb3IsIGJnQ29sb3IsIHRleHRzfSA9IG87XHJcblxyXG4gICAgLy8gYXJlbmEud2lkdGgsIGFyZW5hLmhlaWdodFxyXG5cclxuICAgIG1hcERpbWVuc2lvbnMueD1hcmVuYS53aWR0aCAqIDI7XHJcbiAgICBtYXBEaW1lbnNpb25zLnk9YXJlbmEuaGVpZ2h0ICogMjtcclxuXHJcbiAgICBzcGF3blBvc2l0aW9uLng9cGxheWVyU3Bhd24ueCoyO1xyXG4gICAgc3Bhd25Qb3NpdGlvbi55PXBsYXllclNwYXduLnkqMjtcclxuICAgIHdpbmRvdy5yZXNwYXduUGxheWVyKCk7XHJcbiAgICBjb2xvcnMuYmFja2dyb3VuZD10aWxlQ29sb3I7IGNvbG9ycy50aWxlPWJnQ29sb3I7XHJcblxyXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xyXG5cclxuICAgIGxldCBvYnMgPSBvLm9ic3RhY2xlcztcclxuICAgIGxldCBlbmVtaWVzID0gby5lbmVteTtcclxuXHJcbiAgICBzYWZlcyA9IHNhZmVzLm1hcChwID0+IHtcclxuICAgICAgICBwLnR5cGUgPSBcInNhZmVcIjtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH0pO1xyXG5cclxuICAgIHRleHRzID0gdGV4dHMubWFwKHAgPT4ge1xyXG4gICAgICAgIHAudHlwZSA9IFwidGV4dFwiO1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBjb25zdCB0eXBlTWFwID0ge1xyXG4gICAgICAgICdub3JtYWwnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFswXV0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyAndHJhbnMnOiB7XHJcbiAgICAgICAgLy8gICAgIHR5cGU6IFsxLFtdLFsyMF1dLFxyXG4gICAgICAgIC8vICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVybiB7aGV4OiAnIzAwMDAwMCcsIGFscGhhOiBwYXJhbXMub3BhcX07XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vICdibG9jayc6IHtcclxuICAgICAgICAvLyAgICAgdHlwZTogWzEsW10sWzIwXV0sXHJcbiAgICAgICAgLy8gICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIHtoZXg6IHBhcmFtcy5jb2xvciwgYWxwaGE6IDF9O1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAnZ3Jhdic6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzEzXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYocGFyYW1zLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5jb252ZXlvckFuZ2xlID0gMFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHBhcmFtcy5kaXJlY3Rpb24gPT09ICdkb3duJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5jb252ZXlvckFuZ2xlID0gOTA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYocGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2xlZnQnKXtcclxuICAgICAgICAgICAgICAgICAgICBwLmNvbnZleW9yQW5nbGUgPSAxODA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAuY29udmV5b3JBbmdsZSA9IDI3MDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAuY29udmV5b3JGcmljdGlvbiA9IDAuODtcclxuICAgICAgICAgICAgICAgIHAuY29udmV5b3JBbmdsZVJvdGF0ZVNwZWVkID0gMDtcclxuICAgICAgICAgICAgICAgIHAuY29udmV5b3JGb3JjZSA9IHBhcmFtcy5mb3JjZSAvIDEwMDAwICogNy4wOCAqIDUgLyAxNi42NjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY2lyY2xlLW5vcm1hbCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzBdXSxcclxuICAgICAgICAgICAgcmFkaXVzOiAncicgLy8gdGhpcyBtZWFucyBtYXAgcmFkaXVzIHRvIHJcclxuICAgICAgICAgICAgLy8gYWxsIG90aGVyIHBhcmFtcyBmaWxsZWQgaW4gMToxLCBzbyB4IHdpbGwgYmUgZmlsbGVkIGluIGZyb20geCwgeSBmcm9tIHksIGV0Yy5cclxuICAgICAgICB9LFxyXG4gICAgICAgICdjaXJjbGUtbGF2YSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzFdXSxcclxuICAgICAgICAgICAgcmFkaXVzOiAncicsXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZFBsYXllcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NpcmNsZS10cCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzEyXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0cHg6IHBhcmFtcy50cHggKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRweTogcGFyYW1zLnRweSAqIDJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2xhdmEnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsxXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZFBsYXllcjogcGFyYW1zLmNhbkNvbGxpZGVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdwb2x5Jzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMixbXSxbMF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cG9pbnRzOiBbXX07XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFyYW1zLnBvaW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wb2ludHMucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wb2ludHNbaV1bMF0qMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVsxXSoyXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAncG9seS10cCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzIsW10sWzEyXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwb2ludHM6IFtdfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjJcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcC50cHggPSBwYXJhbXMudHB4ICogMjtcclxuICAgICAgICAgICAgICAgIHAudHB5ID0gcGFyYW1zLnRweSAqIDI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3BvbHktc2FmZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzIsW10sWzExXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwb2ludHM6IFtdfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjJcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdwb2x5LXZpbmV0dGUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsyLFtdLFsyNF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cG9pbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclI6IHBhcmFtcy52Yy5yLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRzogcGFyYW1zLnZjLmcsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJCOiBwYXJhbXMudmMuYixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclNpemU6IHBhcmFtcy5pcixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlclI6IHBhcmFtcy52Yy5yLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyRzogcGFyYW1zLnZjLmcsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJCOiBwYXJhbXMudmMuYixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlclNpemU6IHBhcmFtcy5vcixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lck9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJPcGFjaXR5OiBwYXJhbXMub1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjJcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdwb2x5LWxhdmEnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsyLFtdLFsxXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwb2ludHM6IFtdfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjJcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcC5ib3VuZFBsYXllciA9IHRydWU7Ly9wYXJhbXMuY2FuQ29sbGlkZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnbW92ZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzBdLFswXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwYXRoOiBbXX07XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFyYW1zLnBvaW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wYXRoLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzBdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wb2ludHNbaV1bMV0qMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNwZWVkICogMiAvIDEwMDBcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBwLmN1cnJlbnRQb2ludCA9IHBhcmFtcy5jdXJyZW50UG9pbnQ7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHAucGF0aFtwLmN1cnJlbnRQb2ludF07XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvaW50SW5kZXggPSBwLmN1cnJlbnRQb2ludCsxO1xyXG4gICAgICAgICAgICAgICAgaWYobmV4dFBvaW50SW5kZXggPT09IHAucGF0aC5sZW5ndGgpIG5leHRQb2ludEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQb2ludCA9IHAucGF0aFtuZXh0UG9pbnRJbmRleF07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsRGlzdCA9IE1hdGguc3FydCgobmV4dFBvaW50WzBdLWN1cnJlbnRQb2ludFswXSkqKjIrKG5leHRQb2ludFsxXS1jdXJyZW50UG9pbnRbMV0pKioyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uQ292ZXJlZCA9IE1hdGguc3FydCgocGFyYW1zLngqMi1jdXJyZW50UG9pbnRbMF0pKioyKyhwYXJhbXMueSoyLWN1cnJlbnRQb2ludFsxXSkqKjIpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBwLmN1cnJlbnRQb2ludCArPSBmcmFjdGlvbkNvdmVyZWQgLyB0b3RhbERpc3Q7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHAueCA9IHAucGF0aFswXVswXTtcclxuICAgICAgICAgICAgICAgIHAueSA9IHAucGF0aFswXVsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnbGF2YW1vdmUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFswXSxbMV1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogW119O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcmFtcy5wb2ludHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGF0aC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zcGVlZCAqIDIgLyAxMDAwXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgPSBwYXJhbXMuY3VycmVudFBvaW50O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBwLnBhdGhbcC5jdXJyZW50UG9pbnRdO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb2ludEluZGV4ID0gcC5jdXJyZW50UG9pbnQrMTtcclxuICAgICAgICAgICAgICAgIGlmKG5leHRQb2ludEluZGV4ID09PSBwLnBhdGgubGVuZ3RoKSBuZXh0UG9pbnRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9pbnQgPSBwLnBhdGhbbmV4dFBvaW50SW5kZXhdO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbERpc3QgPSBNYXRoLnNxcnQoKG5leHRQb2ludFswXS1jdXJyZW50UG9pbnRbMF0pKioyKyhuZXh0UG9pbnRbMV0tY3VycmVudFBvaW50WzFdKSoqMik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFjdGlvbkNvdmVyZWQgPSBNYXRoLnNxcnQoKHBhcmFtcy54KjItY3VycmVudFBvaW50WzBdKSoqMisocGFyYW1zLnkqMi1jdXJyZW50UG9pbnRbMV0pKioyKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgKz0gZnJhY3Rpb25Db3ZlcmVkIC8gdG90YWxEaXN0O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBwLnggPSBwLnBhdGhbMF1bMF07XHJcbiAgICAgICAgICAgICAgICBwLnkgPSBwLnBhdGhbMF1bMV07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHAuYm91bmRQbGF5ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmKHBhcmFtcy5jb2xsaWRhYmxlKSBwLmJvdW5kUGxheWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAndG9ybmFkbyc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzIzXV0sXHJcbiAgICAgICAgICAgIHNwaW5SYWRpdXM6ICd0b3JuYWRvU3RyZW5ndGgnIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3ZpbmV0dGUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsyNF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTaXplOiBwYXJhbXMuaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJTaXplOiBwYXJhbXMub3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyT3BhY2l0eTogcGFyYW1zLm9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3RwbW92ZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzBdLFsxMl1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogW119O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcmFtcy5wb2ludHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGF0aC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zcGVlZCAqIDIgLyAxMDAwXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgPSBwYXJhbXMuY3VycmVudFBvaW50O1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcC5wYXRoWzBdWzBdO1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcC5wYXRoWzBdWzFdO1xyXG4gICAgICAgICAgICAgICAgcC50cHggPSBwYXJhbXMudHB4ICogMjsgcC50cHkgPSBwYXJhbXMudHB5ICogMjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnbW92aW5nc2FmZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzBdLFsxMV1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogW119O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcmFtcy5wb2ludHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGF0aC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zcGVlZCAqIDIgLyAxMDAwXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAuY3VycmVudFBvaW50ID0gcGFyYW1zLmN1cnJlbnRQb2ludDtcclxuICAgICAgICAgICAgICAgIHAueCA9IHAucGF0aFswXVswXTtcclxuICAgICAgICAgICAgICAgIHAueSA9IHAucGF0aFswXVsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnbW92aW5ndmluZXR0ZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzBdLFsyNF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTaXplOiBwYXJhbXMuaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJTaXplOiBwYXJhbXMub3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyT3BhY2l0eTogcGFyYW1zLm9cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFyYW1zLnBvaW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wYXRoLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzBdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wb2ludHNbaV1bMV0qMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNwZWVkICogMiAvIDEwMDBcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgPSBwYXJhbXMuY3VycmVudFBvaW50O1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcC5wYXRoWzBdWzBdO1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcC5wYXRoWzBdWzFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICd0aW1ldHJhcCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzE3XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy9DKDEsW10sWzE3XSx7aDoyMDAsdzozMDAseTo3MDAseDozMDAsdGltZVRyYXBUb1Nob3dUZW50aDp0cnVlLHRpbWVUcmFwVG9LaWxsOnRydWUsdGltZVRyYXBSZWNvdmVyeVNwZWVkOjEuNSx0aW1lVHJhcE1heFRpbWU6MzAwLH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHt0aW1lVHJhcFRvU2hvd1RlbnRoOmZhbHNlLHRpbWVUcmFwVG9LaWxsOnRydWUsdGltZVRyYXBSZWNvdmVyeVNwZWVkOnBhcmFtcy5jZG11bHR9O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBwLnRpbWVUcmFwTWF4VGltZSA9IHBhcmFtcy5tYXhUaW1lICogMTAwMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnb3ZhbCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzBdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3I6IE1hdGgubWluKHBhcmFtcy5yYWRpdXMsIHBhcmFtcy5yYWRpdXMyKSoyfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2xhdmEtb3ZhbCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzFdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3I6IE1hdGgubWluKHBhcmFtcy5yYWRpdXMsIHBhcmFtcy5yYWRpdXMyKSoyLCBib3VuZFBsYXllcjogdHJ1ZX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdzYWZlJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbMTFdXSxcclxuICAgICAgICB9LFxyXG4gICAgICAgICdjaXJjbGUtc2FmZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzExXV0sXHJcbiAgICAgICAgICAgIHI6ICdyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NpcmNsZS12aW5ldHRlJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMCxbXSxbMjRdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyUjogcGFyYW1zLnZjLnIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJHOiBwYXJhbXMudmMuZyxcclxuICAgICAgICAgICAgICAgICAgICBpbm5lckI6IHBhcmFtcy52Yy5iLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyU2l6ZTogcGFyYW1zLmlyLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyUjogcGFyYW1zLnZjLnIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJHOiBwYXJhbXMudmMuZyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckI6IHBhcmFtcy52Yy5iLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyU2l6ZTogcGFyYW1zLm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyT3BhY2l0eTogMCxcclxuICAgICAgICAgICAgICAgICAgICBvdXRlck9wYWNpdHk6IHBhcmFtcy5vLFxyXG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcmFtcy5yID8/IHBhcmFtcy5yYWRpdXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NpcmNsZS1jb2luJzoge1xyXG4gICAgICAgICAgICByYWRpdXM6ICdyJyxcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzddXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2Q1ZDYxMicsXHJcbiAgICAgICAgICAgICAgICAgICAgY29pbkFtb3VudDogMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnYm91bmNlJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbMl1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7Ym91bmNpbmVzczogcGFyYW1zLmVmZmVjdC8zLzEwLCBkZWNheTogMC41fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3JvdGF0ZS1ub3JtYWwnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFsxXSxbMF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy54ID0gcGFyYW1zLmRpc3RUb1Bpdm90ICsgcGFyYW1zLnBpdm90WDtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy55ID0gcGFyYW1zLnBpdm90WTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcGFyYW1zLnggKiAyIC0gcGFyYW1zLncsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogcGFyYW1zLnkgKiAyIC0gcGFyYW1zLmgsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJvdGF0aW9uOiBwYXJhbXMuYW5nbGUgKiAxODAgLyBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZVNwZWVkOiBwYXJhbXMucm90YXRlU3BlZWQgLyAzNjAgLyAyMjAgKiAxLjM2LFxyXG4gICAgICAgICAgICAgICAgICAgIHBpdm90WDogcGFyYW1zLnBpdm90WCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGl2b3RZOiBwYXJhbXMucGl2b3RZICogMlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3JvdGF0ZS1sYXZhJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbMV0sWzFdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMueCA9IHBhcmFtcy5kaXN0VG9QaXZvdCArIHBhcmFtcy5waXZvdFg7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMueSA9IHBhcmFtcy5waXZvdFk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHBhcmFtcy54ICogMiAtIHBhcmFtcy53LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcmFtcy55ICogMiAtIHBhcmFtcy5oLFxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxSb3RhdGlvbjogcGFyYW1zLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZVNwZWVkOiBwYXJhbXMucm90YXRlU3BlZWQgLyAzNjAgLyAyMjAgKiAxLjM2LFxyXG4gICAgICAgICAgICAgICAgICAgIHBpdm90WDogcGFyYW1zLnBpdm90WCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGl2b3RZOiBwYXJhbXMucGl2b3RZICogMixcclxuICAgICAgICAgICAgICAgICAgICBib3VuZFBsYXllcjogcGFyYW1zLmNhbkNvbGxpZGVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdyb3RhdGluZ3NhZmUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFsxXSxbMTFdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhwYXJhbXMuYW5nbGUgLSBsYXN0Um90QW5nbGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gbGFzdFJvdEFuZ2xlID0gcGFyYW1zLmFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgLy8gbGFzdFJvdEFuZ2xlICs9IE1hdGguUEkgKiAzLzI7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIDA6IHBhcmFtcy55ICs9IDEsIHggKz0gMFxyXG4gICAgICAgICAgICAgICAgLy8gOTA6IHBhcmFtcy54IC09IDEsIHkgKz0gMFxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJhbXMuYW5nbGUgPSAwO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCByb3RhdGlvbiA9IHBhcmFtcy5hbmdsZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBcInhcIjogODk2LjU5ODQ2NTUyOTYwNDgsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJ5XCI6IDE3MjAuODgxOTczNDg2ODE4NCxcclxuICAgICAgICAgICAgICAgIC8vICAgICBcIndcIjogMjUsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJoXCI6IDI1LFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwidHlwZVwiOiBcInJvdGF0aW5nc2FmZVwiLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwiYW5nbGVcIjogLTY2NDkzLjUsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJyb3RhdGVTcGVlZFwiOiAtOTAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJwaXZvdFhcIjogOTI1LFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwicGl2b3RZXCI6IDE2MjUsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJkaXN0VG9QaXZvdFwiOiAxMDAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJjYW5Db2xsaWRlXCI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJjdWxsaW5nUmFkaXVzXCI6IDExNy42Nzc2Njk1Mjk2NjM2OSxcclxuICAgICAgICAgICAgICAgIC8vICAgICBcInVuU2ltXCI6IDAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJpblZpZXdcIjogZmFsc2VcclxuICAgICAgICAgICAgICAgIC8vIH0sXHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIGluIGVYLCBwb3NpdGlvbiBpcyBzZXQgbGlrZSB0aGlzXHJcbiAgICAgICAgICAgIC8vICAgICBvYmoueCA9XHJcbiAgICAgICAgICAgIC8vICAgICBNYXRoLmNvcygob2JqLmFuZ2xlICogTWF0aC5QSSkgLyAxODApICpcclxuICAgICAgICAgICAgLy8gICAgICAgICBvYmouZGlzdFRvUGl2b3QgK1xyXG4gICAgICAgICAgICAvLyAgICAgb2JqLnBpdm90WDtcclxuICAgICAgICAgICAgLy8gb2JqLnkgPVxyXG4gICAgICAgICAgICAvLyAgICAgTWF0aC5zaW4oKG9iai5hbmdsZSAqIE1hdGguUEkpIC8gMTgwKSAqXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgb2JqLmRpc3RUb1Bpdm90ICtcclxuICAgICAgICAgICAgLy8gICAgIG9iai5waXZvdFk7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSByZW5kZXIgbGlrZSB0aGlzXHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIGN0eC50cmFuc2xhdGUoY2VudGVyLngsIGNlbnRlci55KTtcclxuICAgICAgICAgICAgICAgIC8vIGN0eC5yb3RhdGUoZGVnVG9SYWQob2JzdGFjbGUuYW5nbGUpKTtcclxuICAgICAgICAgICAgICAgIC8vIGN0eC5yZWN0KFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIC1vYnN0YWNsZS53IC8gMixcclxuICAgICAgICAgICAgICAgIC8vICAgICAtb2JzdGFjbGUuaCAvIDIsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgb2JzdGFjbGUudyxcclxuICAgICAgICAgICAgICAgIC8vICAgICBvYnN0YWNsZS5oXHJcbiAgICAgICAgICAgICAgICAvLyApO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBvYmoueCwgb2JqLnkgPSBjZW50ZXJYLiBcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gbGV0IGFuZ2xlID0gcGFyYW1zLmFuZ2xlO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBsZXRzIHRyeSBzZXR0aW5nIGFuZ2xlIHRvIDAgYW5kIHNlZSB3aGF0IGhhcHBlbnNcclxuICAgICAgICAgICAgICAgIC8vIHBhcmFtcy5hbmdsZSA9IDQ1O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnggPSBwYXJhbXMuZGlzdFRvUGl2b3QgKyBwYXJhbXMucGl2b3RYO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnkgPSBwYXJhbXMucGl2b3RZO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyB0aGV5J3JlIGluIGEgc3RyYWlnaHQgbGluZSBsaWtlIG8gLSAtLS1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gc28gbm93LCBsZXRzIHJvdGF0ZSB0aGUgYW5nbGUgYXJvdW5kIHRoZSBvYnMgY2VudGVyLiBXZSBrbm93IHRoYXQgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgc2FmZSBpcyBpdHMgY2VudGVyIHNvIGxldHMgY2FsY3VsYXRlIG91ciBvd24gZGlzdFRvUGl2b3QgZnJvbSB0aGF0XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IG1pZGRsZVggPSBwYXJhbXMueCArIHBhcmFtcy53IC8gMjtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IG1pZGRsZVkgPSBwYXJhbXMueSArIHBhcmFtcy5oIC8gMlxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCByZWFsRGlzdFRvUGl2b3QgPSBNYXRoLnNxcnQoKHBhcmFtcy54IC0gcGFyYW1zLnBpdm90WCkgKiogMiArIChwYXJhbXMueSAtIHBhcmFtcy5waXZvdFkpICoqIDIpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyAvLyAvLyBub3cgd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gc2V0IHRoZSB4IGFuZCB5XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIC8vIC8vIHBhcmFtcy5hbmdsZSA9IGFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgeCA9IE1hdGguY29zKHBhcmFtcy5hbmdsZSAqIE1hdGguUEkgLyAxODApICogZGlzdCArIHBhcmFtcy5waXZvdFggLSBwYXJhbXMudyAvIDI7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB5ID0gTWF0aC5zaW4ocGFyYW1zLmFuZ2xlICogTWF0aC5QSSAvIDE4MCkgKiBkaXN0ICsgcGFyYW1zLnBpdm90WSAtIHBhcmFtcy5oIC8gMjtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB4OngqMix5OnkqMixpbml0aWFsUm90YXRpb246IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeDogcGFyYW1zLnggKiAyIC0gcGFyYW1zLncsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogcGFyYW1zLnkgKiAyIC0gcGFyYW1zLmgsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJvdGF0aW9uOiBwYXJhbXMuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlU3BlZWQ6IHBhcmFtcy5yb3RhdGVTcGVlZCAvIDM2MCAvIDIyMCAqIDEuMzYsXHJcbiAgICAgICAgICAgICAgICAgICAgcGl2b3RYOiBwYXJhbXMucGl2b3RYICogMixcclxuICAgICAgICAgICAgICAgICAgICBwaXZvdFk6IHBhcmFtcy5waXZvdFkgKiAyXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAncm90YXRpbmd2aW5ldHRlJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbMV0sWzI0XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnggPSBwYXJhbXMuZGlzdFRvUGl2b3QgKyBwYXJhbXMucGl2b3RYO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnkgPSBwYXJhbXMucGl2b3RZO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHBhcmFtcy54ICogMiAtIHBhcmFtcy53LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcmFtcy55ICogMiAtIHBhcmFtcy5oLFxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxSb3RhdGlvbjogcGFyYW1zLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZVNwZWVkOiBwYXJhbXMucm90YXRlU3BlZWQgLyAzNjAgLyAyMjAgKiAxLjM2LFxyXG4gICAgICAgICAgICAgICAgICAgIHBpdm90WDogcGFyYW1zLnBpdm90WCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGl2b3RZOiBwYXJhbXMucGl2b3RZICogMixcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclI6IHBhcmFtcy52Yy5yLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRzogcGFyYW1zLnZjLmcsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJCOiBwYXJhbXMudmMuYixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclNpemU6IHBhcmFtcy5pcixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlclI6IHBhcmFtcy52Yy5yLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyRzogcGFyYW1zLnZjLmcsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJCOiBwYXJhbXMudmMuYixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlclNpemU6IHBhcmFtcy5vcixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lck9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJPcGFjaXR5OiBwYXJhbXMub1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY2hlY2snOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFs5XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50T2Zmc2V0WDogMCxcclxuICAgICAgICAgICAgICAgICAgICBjaGVja3BvaW50T2Zmc2V0WTogMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAndHAnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsxMl1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHB4OiBwYXJhbXMudHB4ICogMixcclxuICAgICAgICAgICAgICAgICAgICB0cHk6IHBhcmFtcy50cHkgKiAyXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICd3aW5wYWQnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFs2XV1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdzcGVlZCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzE5XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVlZENoYW5nZVBlcm1hbmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc3BlZWRNdWx0OiBwYXJhbXMuc3BlZWRJbmNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3NpemUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsxOF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZUNoYW5nZVBlcm1hbmVudDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZU11bHQ6IHBhcmFtcy5zaXplIC8gMjQuNVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vQygxLFtdLFsxOF0se2g6MjAwLHc6MzAwLHk6NzAwLHg6MzAwLHNpemVDaGFuZ2VQZXJtYW5lbnQ6ZmFsc2Usc2l6ZU11bHQ6MS41LH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3NuYXAnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsxNl1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc25hcEFuZ2xlUm90YXRlU3BlZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcEFuZ2xlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHNuYXBDb29sZG93bjogcGFyYW1zLnNuYXBXYWl0LFxyXG4gICAgICAgICAgICAgICAgICAgIHNuYXBEaXN0YW5jZVk6IHBhcmFtcy5zbmFwRGlzdGFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcERpc3RhbmNlWDogcGFyYW1zLnNuYXBEaXN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICB0b1NuYXBYOiBwYXJhbXMuc25hcFgsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9TbmFwWTogcGFyYW1zLnNuYXBZXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDExMDUwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ5XCI6IDE1NTAsXHJcbiAgICAgICAgICAgIC8vICAgICBcIndcIjogOTAwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJoXCI6IDUwMCxcclxuICAgICAgICAgICAgLy8gICAgIFwidHlwZVwiOiBcInNuYXBcIixcclxuICAgICAgICAgICAgLy8gICAgIFwic25hcERpc3RhbmNlXCI6IDUwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJzbmFwV2FpdFwiOiAwLjQsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNuYXBYXCI6IHRydWUsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNuYXBZXCI6IHRydWUsXHJcbiAgICAgICAgICAgIC8vICAgICBcImluVmlld1wiOiBmYWxzZVxyXG4gICAgICAgICAgICAvLyB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NvaW4nOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFs3XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNkNWQ2MTInLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvaW5BbW91bnQ6IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NvaW5kb29yJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbOF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29pbkRvb3JDb2xvcjogJyNkNWQ2MTInLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvaW5kb29yQ29pbkFtb3VudDogcGFyYW1zLmNvaW5zXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdidXR0b24nOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFs3XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9wID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwieFwiOiAxNDk0MS40MzgxMDA5MjU1MjcsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IDU0OTUuODcwMTI4Nzk2MzgxXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm90dG9tID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwieFwiOiAxODQyMC4xNTg2MjE0MDYzNTcsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IDg4NzMuMDg2NzA0NTI5MTdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcGFyYW1zLnggKiAyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHBhcmFtcy55ICogMjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc2lkZSA9IHggPiB0b3AueCAmJiB4IDwgYm90dG9tLnggJiYgeSA+IHRvcC55ICYmIHkgPCBib3R0b20ueTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGluc2lkZSA/ICcjMDBGRjAwJyA6ICcjZDZkNjEyJyxcclxuICAgICAgICAgICAgICAgICAgICBjb2luQW1vdW50OiAxXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdkb29yJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbOF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvaW5BbW91bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG9icy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob2JzW2ldLnR5cGUgPT09ICdidXR0b24nICYmIG9ic1tpXS5pZCA9PT0gaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2luQW1vdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9wID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwieFwiOiAxNDk0MS40MzgxMDA5MjU1MjcsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IDU0OTUuODcwMTI4Nzk2MzgxXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm90dG9tID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwieFwiOiAxODQyMC4xNTg2MjE0MDYzNTcsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ5XCI6IDg4NzMuMDg2NzA0NTI5MTdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gcGFyYW1zLnggKiAyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHBhcmFtcy55ICogMjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc2lkZSA9IHggPiB0b3AueCAmJiB4IDwgYm90dG9tLnggJiYgeSA+IHRvcC55ICYmIHkgPCBib3R0b20ueTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29pbkRvb3JDb2xvcjogaW5zaWRlID8gJyMwMEZGMDAnIDogJyNkNmQ2MTInLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvaW5kb29yQ29pbkFtb3VudDogaW5zaWRlID8gNSA6IGNvaW5BbW91bnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3JheGlzJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbMTVdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNTcGVlZE11bHRZOiBwYXJhbXMucnkgPT09IHRydWUgPyAwIDogMSxcclxuICAgICAgICAgICAgICAgICAgICBheGlzU3BlZWRNdWx0WDogcGFyYW1zLnJ4ID09PSB0cnVlID8gMCA6IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3B1c2gnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsyNV1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaEFuZ2xlOiB7J3JpZ2h0JzogMTgwLCAnZG93bic6IDI3MCwgJ2xlZnQnOiAwLCAncmlnaHQnOiA5MH1bcGFyYW1zLmRpcl0sXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4UHVzaERpc3RhbmNlOiBwYXJhbXMubWF4ICogMixcclxuICAgICAgICAgICAgICAgICAgICBpZGxlUHVzaEJhY2tTcGVlZDogcGFyYW1zLnB1c2hCYWNrIC8gMjAsXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVEaXJlY3Rpb25Pbmx5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hDb252ZXJzaW9uUmF0aW86IDAuODZcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sLy9DKDMsW10sWzIwXSx7Zm9udFNpemU6ODAsdGV4dDonSSBhbSBhIHRleHQgOkQnLHk6ODAwLHg6NDUwLGhleDpjb2xvdXJSZ2IoMTAwLDEwMCwxMDApLH0pO1xyXG4gICAgICAgICd0ZXh0Jzoge1xyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBcInhcIjogMzAwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwieVwiOiA3NSxcclxuICAgICAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJ0ZXh0XCI6IFwiV2VsY29tZSB0byB0aGVcIixcclxuICAgICAgICAgICAgICAgIC8vICAgICBcInNpemVcIjogMzAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJzdG9yeVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIC8vICAgICBcImVsZW1lbnRcIjoge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBcInRXaWR0aFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBcInRIZWlnaHRcIjogMFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgICAgICAgICBpZihwYXJhbXMuYW5nbGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBbMyxbMV0sWzIwXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBwYXJhbXMuc2l6ZSAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcmFtcy50ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZXg6ICcjRkZGRkZGJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGl2b3RYOiBwYXJhbXMueCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpdm90WTogcGFyYW1zLnkgKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVTcGVlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJvdGF0aW9uOiBwYXJhbXMuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS8vXCJDKDMsWzFdLFsyMF0se2ZvbnRTaXplOjgwLHRleHQ6J0kgYW0gYSB0ZXh0IDpEJyx5OjgwMCx4OjQ1MCxwaXZvdFk6ODAwLHBpdm90WDo0NTAscm90YXRlU3BlZWQ6MCxpbml0aWFsUm90YXRpb246NDUsaGV4OmNvbG91clJnYigxMDAsMTAwLDEwMCksfSk7XCJcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFszLFtdLFsyMF1dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogcGFyYW1zLnNpemUgKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhbXMudGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGV4OiAnI0ZGRkZGRidcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdwbGF0Zm9ybWVyJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbMTRdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwID0ge307XHJcbiAgICAgICAgICAgICAgICBpZihwYXJhbXMuZGlyZWN0aW9uID09PSAncmlnaHQnKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBsYXRmb3JtZXJBbmdsZSA9IDBcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihwYXJhbXMuZGlyZWN0aW9uID09PSAnZG93bicpe1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGxhdGZvcm1lckFuZ2xlID0gOTA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYocGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2xlZnQnKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBsYXRmb3JtZXJBbmdsZSA9IDE4MDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wbGF0Zm9ybWVyQW5nbGUgPSAyNzA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwLnBsYXRmb3JtZXJGcmljdGlvbiA9IDAuOTtcclxuICAgICAgICAgICAgICAgIHAucGxhdGZvcm1lckFuZ2xlUm90YXRlU3BlZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgcC5wbGF0Zm9ybWVyRm9yY2UgPSBwYXJhbXMuZm9yY2UgLyAxMDAwMCAqIDEuNSAqIDEuOCAqIDEuNiAqIDEwIC8gMTYuNjY7XHJcbiAgICAgICAgICAgICAgICBwLmp1bXBGb3JjZSA9IHBhcmFtcy5qdW1wSGVpZ2h0IC8gMTAgLyA4LjIgKiAyLjMyIC8gMS4yIC8gMjtcclxuICAgICAgICAgICAgICAgIHAuanVtcERlY2F5ID0gMC45NTI1O1xyXG4gICAgICAgICAgICAgICAgcC5tYXhKdW1wQ29vbGRvd24gPSAyMCAqIDE2LjY7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgIC8vICAgICBcInhcIjogNjYwMCxcclxuICAgICAgICAgICAgLy8gICAgIFwieVwiOiAzMDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcIndcIjogNTAwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJoXCI6IDM1MCxcclxuICAgICAgICAgICAgLy8gICAgIFwidHlwZVwiOiBcInBsYXRmb3JtZXJcIixcclxuICAgICAgICAgICAgLy8gICAgIFwiZm9yY2VcIjogMTUwMCxcclxuICAgICAgICAgICAgLy8gICAgIFwiZGlyXCI6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInhcIjogMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInlcIjogMTUwMFxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIFwiZGlyZWN0aW9uXCI6IFwiZG93blwiLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJqdW1wSGVpZ2h0XCI6IDE0NSxcclxuICAgICAgICAgICAgLy8gICAgIFwibWF4Rm9yY2VcIjogMTAwMCxcclxuICAgICAgICAgICAgLy8gICAgIFwidmFyaWFibGVKdW1wSGVpZ2h0XCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJwbGF0Zm9ybWVyRnJpY3Rpb25cIjogMC44LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJpblZpZXdcIjogZmFsc2VcclxuICAgICAgICAgICAgLy8gfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgICdicmVha2FibGUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsxMF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4U3RyZW5ndGg6IE1hdGgubWF4KDIwMCxwYXJhbXMubWF4U3RyZW5ndGggKiBNYXRoLm1heCgxLHBhcmFtcy50aW1lciAqIDEwMDAgLyA2MCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2VuVGltZTogcGFyYW1zLnJlZ2VuVGltZSAqIDEwMDAgLyAxNSxcclxuICAgICAgICAgICAgICAgICAgICBoZWFsU3BlZWQ6IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQygxLFtdLFsxMF0se2g6MjAwLHc6MzAwLHk6NzAwLHg6MzAwLGhlYWxTcGVlZDoxLHJlZ2VuVGltZToxMDAsbWF4U3RyZW5ndGg6NjAsfSk7XHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgICBcInhcIjogMjk1MCxcclxuICAgICAgICAvLyAgICAgXCJ5XCI6IDI2NTAsXHJcbiAgICAgICAgLy8gICAgIFwid1wiOiAyMDAsXHJcbiAgICAgICAgLy8gICAgIFwiaFwiOiA1MCxcclxuICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwiYnJlYWthYmxlXCIsXHJcbiAgICAgICAgLy8gICAgIFwibWF4U3RyZW5ndGhcIjogNDAsXHJcbiAgICAgICAgLy8gICAgIFwiY3VycmVudFN0cmVuZ3RoXCI6IDQwLFxyXG4gICAgICAgIC8vICAgICBcInRpbWVcIjogMCxcclxuICAgICAgICAvLyAgICAgXCJ0aW1lclwiOiAwLFxyXG4gICAgICAgIC8vICAgICBcInJlZ2VuVGltZVwiOiAzLFxyXG4gICAgICAgIC8vICAgICBcImluVmlld1wiOiBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgXHJcbiAgICBcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIFwieFwiOiA4NTUwLFxyXG4gICAgICAgIC8vICAgICBcInlcIjogOTUwMCxcclxuICAgICAgICAvLyAgICAgXCJyYWRpdXNcIjogMzAwLFxyXG4gICAgICAgIC8vICAgICBcInR5cGVcIjogXCJjaXJjbGUtaG9sbG93LXNsaWNlXCIsXHJcbiAgICAgICAgLy8gICAgIFwic3RhcnRBbmdsZVwiOiAxLjU3MDc5NjMyNjc5NDg5NjYsXHJcbiAgICAgICAgLy8gICAgIFwiZW5kQW5nbGVcIjogLTEuNTcwNzk2MzI2Nzk0ODk2NixcclxuICAgICAgICAvLyAgICAgXCJzdGFydFBvbHlnb25cIjoge1xyXG4gICAgICAgIC8vICAgICAgICAgXCJwb2ludHNcIjogW1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIFtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgODU1MCxcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgOTY1MFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgW1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICA4NTUwLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICA5ODAwXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgXVxyXG4gICAgICAgIC8vICAgICAgICAgXSxcclxuICAgICAgICAvLyAgICAgICAgIFwidHlwZVwiOiBcInBvbHlcIixcclxuICAgICAgICAvLyAgICAgICAgIFwicHJvcHNcIjoge31cclxuICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAvLyAgICAgXCJlbmRQb2x5Z29uXCI6IHtcclxuICAgICAgICAvLyAgICAgICAgIFwicG9pbnRzXCI6IFtcclxuICAgICAgICAvLyAgICAgICAgICAgICBbXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIDg1NTAsXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIDkzNTBcclxuICAgICAgICAvLyAgICAgICAgICAgICBdLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIFtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgODU1MCxcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgOTIwMFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIF1cclxuICAgICAgICAvLyAgICAgICAgIF0sXHJcbiAgICAgICAgLy8gICAgICAgICBcInR5cGVcIjogXCJwb2x5XCIsXHJcbiAgICAgICAgLy8gICAgICAgICBcInByb3BzXCI6IHt9XHJcbiAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgLy8gICAgIFwiaW5uZXJSYWRpdXNcIjogMTUwLFxyXG4gICAgICAgIC8vICAgICBcInRvUm90YXRlXCI6IGZhbHNlLFxyXG4gICAgICAgIC8vICAgICBcInJvdGF0ZVNwZWVkXCI6IDAsXHJcbiAgICAgICAgLy8gICAgIFwicmVuZGVyVHlwZVwiOiBcImNpcmNsZVwiLFxyXG4gICAgICAgIC8vICAgICBcImluVmlld1wiOiBmYWxzZVxyXG4gICAgICAgIC8vIH0sXHJcbiAgICAgICAgJ2NpcmNsZS1ob2xsb3ctc2xpY2UnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFs0LFtdLFswXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByOiBwYXJhbXMucmFkaXVzICogMixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclJhZGl1czogcGFyYW1zLmlubmVyUmFkaXVzICogMixcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFNsaWNlQW5nbGU6IHBhcmFtcy5zdGFydEFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFNsaWNlQW5nbGU6IHBhcmFtcy5lbmRBbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFNsaWNlQW5nbGVSb3RhdGVTcGVlZDogcGFyYW1zLnJvdGF0ZVNwZWVkIC8gMjAwMCxcclxuICAgICAgICAgICAgICAgICAgICBlbmRTbGljZUFuZ2xlUm90YXRlU3BlZWQ6IHBhcmFtcy5yb3RhdGVTcGVlZCAvIDIwMDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICBcclxuICAgICAgICAnY2lyY2xlLXNsaWNlJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbNCxbXSxbMF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcjogcGFyYW1zLnJhZGl1cyAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJSYWRpdXM6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRTbGljZUFuZ2xlOiBwYXJhbXMuc3RhcnRBbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBlbmRTbGljZUFuZ2xlOiBwYXJhbXMuZW5kQW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRTbGljZUFuZ2xlUm90YXRlU3BlZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kU2xpY2VBbmdsZVJvdGF0ZVNwZWVkOiAwXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgXHJcbiAgICAgICAgJ3NoaXAnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsyN11dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2hpcFN0YXRlVG86IHBhcmFtcy5zdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsU2hpcEFuZ2xlOiAtTWF0aC5QSSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hpcFR1cm5TcGVlZDogTWF0aC5QSSAvIDIwIC8gMTYuNjYgLyAyXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgXHJcbiAgICAgICAgJ211c2ljY2hhbmdlJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbMjZdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHBhcmFtcy54ICogMixcclxuICAgICAgICAgICAgICAgICAgICB5OiBwYXJhbXMueSAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgdzogcGFyYW1zLncgKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIGg6IHBhcmFtcy5oICogMixcclxuICAgICAgICAgICAgICAgICAgICBtdXNpY1BhdGg6IHBhcmFtcy5tdXNpY1BhdGhcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgXHJcbiAgICAgICAgJ2dycHUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsyOF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlR3JhcHBsZVN0YXRlVG86IHBhcmFtcy5zdGF0ZSwgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcHBsZVJhbmdlOiA0ODgsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcHBsZUZvcmNlOiAwLjA2LFxyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBwbGVGcmljOiAwLjgsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgZW5lbXlUeXBlTWFwID0ge1xyXG4gICAgICAgIG5vcm1hbDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBwYXJhbXMuYm91bmQueCAqIDIsXHJcbiAgICAgICAgICAgICAgICB5OiBwYXJhbXMuYm91bmQueSAqIDIsXHJcbiAgICAgICAgICAgICAgICB3OiBwYXJhbXMuYm91bmQudyAqIDIsXHJcbiAgICAgICAgICAgICAgICBoOiBwYXJhbXMuYm91bmQuaCAqIDJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICB2YXIgeHYke2NvdW50ZXJ9ID0gJHtwYXJhbXMueHYvMzB9O1xyXG4gICAgICAgICAgICB2YXIgeXYke2NvdW50ZXJ9ID0gJHtwYXJhbXMueXYvMzB9O1xyXG4gICAgICAgICAgICBDKDAsWzNdLFsxXSx7cjoke3BhcmFtcy5yYWRpdXMqMn0seToke3BhcmFtcy55KjJ9LHg6JHtwYXJhbXMueCoyfSxzZjooZSk9PntcclxuICAgICAgICAgICAgZS5wb3MueSArPSB5diR7Y291bnRlcn07XHJcbiAgICAgICAgICAgIGUucG9zLnggKz0geHYke2NvdW50ZXJ9O1xyXG4gICAgICAgICAgICBpZiAoKGUucG9zLnggLSBlLnNhdC5yKSA8ICR7Ym91bmRzLnh9IHx8IGUucG9zLnggKyBlLnNhdC5yID4gJHtib3VuZHMueCArIGJvdW5kcy53fSkge1xyXG4gICAgICAgICAgICAgICAgeHYke2NvdW50ZXJ9ID0geHYke2NvdW50ZXJ9ICogLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChlLnBvcy55IC0gZS5zYXQucikgPCAke2JvdW5kcy55fSB8fCBlLnBvcy55ICsgZS5zYXQuciA+ICR7Ym91bmRzLnkgKyBib3VuZHMuaH0pIHtcclxuICAgICAgICAgICAgICAgIHl2JHtjb3VudGVyfSA9IHl2JHtjb3VudGVyfSAqIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sfSk7XHJcbiAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwibm9ybWFsXCIsXHJcbiAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDUuODc0NjAzODM3NTM1MzA5LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyYWRpdXNcIjogMTYsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNwZWVkXCI6IDg1LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDY4OTguNjIyODQ5NTEyMDUxLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ5XCI6IDQ3MTEuNTU2MDMxNDI4MjI4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJYXCI6IDY4OTguNjIyODQ5NTEyMDUxLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJZXCI6IDQ3MTEuNTU2MDMxNDI4MjI4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4dlwiOiA3OC4wMDMyNTM4NDMxMDc2NyxcclxuICAgICAgICAgICAgLy8gICAgIFwieXZcIjogMzMuNzcxMTc2OTEwMDE3NjMsXHJcbiAgICAgICAgICAgIC8vICAgICBcImJvdW5kXCI6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInhcIjogNjQwMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInlcIjogNDI1MCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcIndcIjogNjAwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwiaFwiOiA3MDBcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICBcImlzTGF2YVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcXVhcmU6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYm91bmRzID0ge1xyXG4gICAgICAgICAgICAgICAgeDogcGFyYW1zLmJvdW5kLnggKiAyLFxyXG4gICAgICAgICAgICAgICAgeTogcGFyYW1zLmJvdW5kLnkgKiAyLFxyXG4gICAgICAgICAgICAgICAgdzogcGFyYW1zLmJvdW5kLncgKiAyLFxyXG4gICAgICAgICAgICAgICAgaDogcGFyYW1zLmJvdW5kLmggKiAyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJhbXMuc2l6ZTtcclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICB2YXIgeHYke2NvdW50ZXJ9ID0gJHtwYXJhbXMueHYvNDJ9O1xyXG4gICAgICAgICAgICB2YXIgeXYke2NvdW50ZXJ9ID0gJHtwYXJhbXMueXYvNDJ9O1xyXG4gICAgICAgICAgICBDKDEsWzNdLFsxXSx7dzoke3NpemV9LGg6JHtzaXplfSx5OiR7cGFyYW1zLnkqMn0seDoke3BhcmFtcy54KjJ9LHNmOihlKT0+e1xyXG4gICAgICAgICAgICBlLnBvcy55ICs9IHl2JHtjb3VudGVyfTtcclxuICAgICAgICAgICAgZS5wb3MueCArPSB4diR7Y291bnRlcn07XHJcbiAgICAgICAgICAgIGlmICgoZS5wb3MueCkgPCAke2JvdW5kcy54fSB8fCBlLnBvcy54ICsgJHtzaXplfSA+ICR7Ym91bmRzLnggKyBib3VuZHMud30pIHtcclxuICAgICAgICAgICAgICAgIHh2JHtjb3VudGVyfSA9IHh2JHtjb3VudGVyfSAqIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoZS5wb3MueSkgPCAke2JvdW5kcy55fSB8fCBlLnBvcy55ICsgJHtzaXplfSA+ICR7Ym91bmRzLnkgKyBib3VuZHMuaH0pIHtcclxuICAgICAgICAgICAgICAgIHl2JHtjb3VudGVyfSA9IHl2JHtjb3VudGVyfSAqIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sfSk7XHJcbiAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwibm9ybWFsXCIsXHJcbiAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDUuODc0NjAzODM3NTM1MzA5LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyYWRpdXNcIjogMTYsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNwZWVkXCI6IDg1LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDY4OTguNjIyODQ5NTEyMDUxLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ5XCI6IDQ3MTEuNTU2MDMxNDI4MjI4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJYXCI6IDY4OTguNjIyODQ5NTEyMDUxLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJZXCI6IDQ3MTEuNTU2MDMxNDI4MjI4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4dlwiOiA3OC4wMDMyNTM4NDMxMDc2NyxcclxuICAgICAgICAgICAgLy8gICAgIFwieXZcIjogMzMuNzcxMTc2OTEwMDE3NjMsXHJcbiAgICAgICAgICAgIC8vICAgICBcImJvdW5kXCI6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInhcIjogNjQwMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInlcIjogNDI1MCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcIndcIjogNjAwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwiaFwiOiA3MDBcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICBcImlzTGF2YVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0dXJyZXQ6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwidHVycmV0XCIsXHJcbiAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDMuNjIzMjc2Njk0NTQ0MjgzNixcclxuICAgICAgICAgICAgLy8gICAgIFwic2hvb3RTcGVlZFwiOiAzLjU4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ0aW1lclwiOiAyLjIzMTY2NjY2NjY2OTQyNTYsXHJcbiAgICAgICAgICAgIC8vICAgICBcInBSYWRpdXNcIjogMzIsXHJcbiAgICAgICAgICAgIC8vICAgICBcInBTcGVlZFwiOiAxMjAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInByb2plY3RpbGVzXCI6IFtcclxuICAgICAgICAgICAgLy8gICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIFwieFwiOiA0MjkxLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBcInlcIjogMzQ1MCxcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgXCJhbmdsZVwiOiAwXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIFwieFwiOiAzODYyLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBcInlcIjogMzQ1MCxcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgXCJhbmdsZVwiOiAwXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgXSxcclxuICAgICAgICAgICAgLy8gICAgIFwic2hvb3REaXJlY3Rpb25zXCI6IFtcclxuICAgICAgICAgICAgLy8gICAgICAgICAwXHJcbiAgICAgICAgICAgIC8vICAgICBdLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJjc2RcIjogMCxcclxuICAgICAgICAgICAgLy8gICAgIFwiZGVhZFByb2plY3RpbGVzXCI6IFtdLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyYWRpdXNcIjogMzIsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNwZWVkXCI6IDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInhcIjogMzcwMCxcclxuICAgICAgICAgICAgLy8gICAgIFwieVwiOiAzNDUwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJYXCI6IDM3MDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInJlbmRlcllcIjogMzQ1MCxcclxuICAgICAgICAgICAgLy8gICAgIFwieHZcIjogMCxcclxuICAgICAgICAgICAgLy8gICAgIFwieXZcIjogMCxcclxuICAgICAgICAgICAgLy8gICAgIFwiYm91bmRcIjoge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwieFwiOiAzNjUwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwieVwiOiAzNDAwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwid1wiOiA4NTAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJoXCI6IDEwMFxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IHRydWVcclxuICAgICAgICAgICAgLy8gfSxcclxuICAgICAgICAgICAgY29uc3QgYm91bmRzID0ge1xyXG4gICAgICAgICAgICAgICAgeDogcGFyYW1zLmJvdW5kLnggKiAyLFxyXG4gICAgICAgICAgICAgICAgeTogcGFyYW1zLmJvdW5kLnkgKiAyLFxyXG4gICAgICAgICAgICAgICAgdzogcGFyYW1zLmJvdW5kLncgKiAyLFxyXG4gICAgICAgICAgICAgICAgaDogcGFyYW1zLmJvdW5kLmggKiAyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAgICAgY29uc3Qgc2hvb3RTcGVlZCA9IHBhcmFtcy5zaG9vdFNwZWVkICogMTAwMCAvIDE1O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aWxlUGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgc3BlZWQ6IHBhcmFtcy5wU3BlZWQgLyA0MixcclxuICAgICAgICAgICAgICAgIHJhZGl1czogcGFyYW1zLnBSYWRpdXMgKiAyLFxyXG4gICAgICAgICAgICAgICAgc2hvb3REaXJlY3Rpb25zOiBwYXJhbXMuc2hvb3REaXJlY3Rpb25zLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb3VudGVyO1xyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICB2YXIgeHYke2N9ID0gJHtwYXJhbXMueHYvNDJ9O1xyXG4gICAgICAgICAgICB2YXIgeXYke2N9ID0gJHtwYXJhbXMueXYvNDJ9O1xyXG4gICAgICAgICAgICB2YXIgc2hvb3REaXJlY3Rpb25JbmRleCR7Y30gPSAwO1xyXG4gICAgICAgICAgICB2YXIgdGltZXIke2N9ID0gJHtzaG9vdFNwZWVkfTtcclxuICAgICAgICAgICAgQygwLFszXSxbMV0se3I6JHtwYXJhbXMucmFkaXVzfSx5OiR7cGFyYW1zLnkqMn0seDoke3BhcmFtcy54KjJ9LHNmOihlKT0+e1xyXG4gICAgICAgICAgICBlLnBvcy55ICs9IHl2JHtjfTtcclxuICAgICAgICAgICAgZS5wb3MueCArPSB4diR7Y307XHJcbiAgICAgICAgICAgIGlmICgoZS5wb3MueCAtIGUuc2F0LnIpIDwgJHtib3VuZHMueH0gfHwgZS5wb3MueCArIGUuc2F0LnIgPiAke2JvdW5kcy54ICsgYm91bmRzLnd9KSB7XHJcbiAgICAgICAgICAgICAgICB4diR7Y30gPSB4diR7Y30gKiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGUucG9zLnkgLSBlLnNhdC5yKSA8ICR7Ym91bmRzLnl9IHx8IGUucG9zLnkgKyBlLnNhdC5yID4gJHtib3VuZHMueSArIGJvdW5kcy5ofSkge1xyXG4gICAgICAgICAgICAgICAgeXYke2N9ID0geXYke2N9ICogLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICB0aW1lciR7Y30tLTtcclxuICAgICAgICAgICAgaWYodGltZXIke2N9IDwgMCl7XHJcbiAgICAgICAgICAgICAgICB0aW1lciR7Y30gPSAke3Nob290U3BlZWR9O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBzaG9vdERpcmVjdGlvbkluZGV4JHtjfSsrO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvb3REaXJlY3Rpb25zID0gWyR7cHJvamVjdGlsZVBhcmFtcy5zaG9vdERpcmVjdGlvbnMudG9TdHJpbmcoKX1dO1xyXG4gICAgICAgICAgICAgICAgaWYoc2hvb3REaXJlY3Rpb25JbmRleCR7Y30gPj0gc2hvb3REaXJlY3Rpb25zLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvb3REaXJlY3Rpb25JbmRleCR7Y30gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGRpciA9IHNob290RGlyZWN0aW9uc1tzaG9vdERpcmVjdGlvbkluZGV4JHtjfV07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgIC8qc2NvcGVkIHVzaW5nIGxldCovXHJcbiAgICAgICAgICAgICAgICBsZXQgeHYke2NvdW50ZXJ9ID0gTWF0aC5jb3MoZGlyKSAqICR7cHJvamVjdGlsZVBhcmFtcy5zcGVlZH07XHJcbiAgICAgICAgICAgICAgICBsZXQgeXYke2NvdW50ZXJ9ID0gTWF0aC5zaW4oZGlyKSAqICR7cHJvamVjdGlsZVBhcmFtcy5zcGVlZH07XHJcbiAgICAgICAgICAgICAgICBDKDAsWzNdLFsxXSx7cjoke3Byb2plY3RpbGVQYXJhbXMucmFkaXVzfSx5OmUucG9zLnkseDplLnBvcy54LHNmOihlKT0+e1xyXG4gICAgICAgICAgICAgICAgZS5wb3MueSArPSB5diR7Y291bnRlcn07XHJcbiAgICAgICAgICAgICAgICBlLnBvcy54ICs9IHh2JHtjb3VudGVyfTtcclxuICAgICAgICAgICAgICAgIC8qZGVsZXRlIG9ic3RhY2xlKi9cclxuICAgICAgICAgICAgICAgIGlmICgoZS5wb3MueCAtIGUuc2F0LnIpIDwgJHtib3VuZHMueH0gfHwgZS5wb3MueCArIGUuc2F0LnIgPiAke2JvdW5kcy54ICsgYm91bmRzLnd9IHx8IChlLnBvcy55IC0gZS5zYXQucikgPCAke2JvdW5kcy55fSB8fCBlLnBvcy55ICsgZS5zYXQuciA+ICR7Ym91bmRzLnkgKyBib3VuZHMuaH0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cudGlja0Zucy5wdXNoKCgpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBvYnN0YWNsZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JzdGFjbGVzW2ldID09PSBlKSB7b2JzdGFjbGVzLnNwbGljZShpLDEpOyBicmVhazt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypmb3IobGV0IGtleSBpbiB3aW5kb3cuaWRUb09icyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih3aW5kb3cuaWRUb09ic1trZXldID09PSBlKXtkZWxldGUgd2luZG93LmlkVG9PYnNba2V5XTsgYnJlYWs7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9Ki9cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICB9LH0pO1xyXG4gICAgICAgICAgICBgXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzd2l0Y2g6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwic3dpdGNoXCIsXHJcbiAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDAuNjU4Njg5ODAyOTEyNTEwOSxcclxuICAgICAgICAgICAgLy8gICAgIFwic3dpdGNoVGltZVwiOiAzLjIsXHJcbiAgICAgICAgICAgIC8vICAgICBcInN3aXRjaFRpbWVyXCI6IDIuMzA4MzMzMzMzMzMwNjI3NyxcclxuICAgICAgICAgICAgLy8gICAgIFwiY3VycmVudFN3aXRjaFwiOiB0cnVlLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyYWRpdXNcIjogMjUsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNwZWVkXCI6IDIyLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDI1NTcuNTY1NTg2OTIzMDYwNCxcclxuICAgICAgICAgICAgLy8gICAgIFwieVwiOiA0NjI4LjYwMjI2MDYwMDQ4NCxcclxuICAgICAgICAgICAgLy8gICAgIFwicmVuZGVyWFwiOiAyNTU3LjU2NTU4NjkyMzA2MDQsXHJcbiAgICAgICAgICAgIC8vICAgICBcInJlbmRlcllcIjogNDYyOC42MDIyNjA2MDA0ODQsXHJcbiAgICAgICAgICAgIC8vICAgICBcInh2XCI6IC0xNy4zOTc0ODY4NTY3NDA0ODIsXHJcbiAgICAgICAgICAgIC8vICAgICBcInl2XCI6IDEzLjQ2NTc4ODE3MTEyMjQ4MyxcclxuICAgICAgICAgICAgLy8gICAgIFwiYm91bmRcIjoge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwieFwiOiAyNDAwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwieVwiOiA0MTUwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwid1wiOiAzNTAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJoXCI6IDY1MFxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgICAgIHg6IHBhcmFtcy5ib3VuZC54ICogMixcclxuICAgICAgICAgICAgICAgIHk6IHBhcmFtcy5ib3VuZC55ICogMixcclxuICAgICAgICAgICAgICAgIHc6IHBhcmFtcy5ib3VuZC53ICogMixcclxuICAgICAgICAgICAgICAgIGg6IHBhcmFtcy5ib3VuZC5oICogMlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heFN3aXRjaFRpbWUgPSBwYXJhbXMuc3dpdGNoVGltZSoxMDAwLzE2OyBcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgdmFyIHh2JHtjb3VudGVyfSA9ICR7cGFyYW1zLnh2LzQyKjR9O1xyXG4gICAgICAgICAgICB2YXIgeXYke2NvdW50ZXJ9ID0gJHtwYXJhbXMueXYvNDIqNH07XHJcbiAgICAgICAgICAgIHZhciBzd2l0Y2hUaW1lJHtjb3VudGVyfSA9ICR7bWF4U3dpdGNoVGltZSpNYXRoLnJhbmRvbSgpKjJ9O1xyXG4gICAgICAgICAgICB2YXIgc3dpdGNoU3RhdGUke2NvdW50ZXJ9ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHBvcyR7Y291bnRlcn0gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiAke3BhcmFtcy54KjJ9LCB5OiAke3BhcmFtcy55KjJ9IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEMoMCxbM10sWzFdLHtyOiR7cGFyYW1zLnJhZGl1c30seToke3BhcmFtcy55KjJ9LHg6JHtwYXJhbXMueCoyfSxzZjooZSk9PntcclxuICAgICAgICAgICAgICAgIHBvcyR7Y291bnRlcn0ueSArPSB5diR7Y291bnRlcn07XHJcbiAgICAgICAgICAgICAgICBwb3Mke2NvdW50ZXJ9LnggKz0geHYke2NvdW50ZXJ9O1xyXG4gICAgICAgICAgICAgICAgaWYgKChwb3Mke2NvdW50ZXJ9LnggLSBlLnNhdC5yKSA8ICR7Ym91bmRzLnh9IHx8IHBvcyR7Y291bnRlcn0ueCArIGUuc2F0LnIgPiAke2JvdW5kcy54ICsgYm91bmRzLnd9KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeHYke2NvdW50ZXJ9ID0geHYke2NvdW50ZXJ9ICogLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHBvcyR7Y291bnRlcn0ueSAtIGUuc2F0LnIpIDwgJHtib3VuZHMueX0gfHwgcG9zJHtjb3VudGVyfS55ICsgZS5zYXQuciA+ICR7Ym91bmRzLnkgKyBib3VuZHMuaH0pIHtcclxuICAgICAgICAgICAgICAgICAgICB5diR7Y291bnRlcn0gPSB5diR7Y291bnRlcn0gKiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgaWYoc3dpdGNoU3RhdGUke2NvdW50ZXJ9ID09PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICBlLnBvcy54ID0gcG9zJHtjb3VudGVyfS54O1xyXG4gICAgICAgICAgICAgICAgICAgIGUucG9zLnkgPSBwb3Mke2NvdW50ZXJ9Lnk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucG9zLnggPSAtMTAwMDAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2hUaW1lJHtjb3VudGVyfS0tO1xyXG4gICAgICAgICAgICAgICAgaWYoc3dpdGNoVGltZSR7Y291bnRlcn0gPD0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoVGltZSR7Y291bnRlcn0gPSAke3BhcmFtcy5zd2l0Y2hUaW1lcioxMDAwLzE1fTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hTdGF0ZSR7Y291bnRlcn0gPSAhc3dpdGNoU3RhdGUke2NvdW50ZXJ9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN3aXRjaFN0YXRlJHtjb3VudGVyfSA9PT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qaWYgd2UncmUgc3dpdGNoaW5nIG9uLCByZXNldCB0byBwb3Mgd2Ugd2VyZSBvbi4gVGhpcyB3YXNuJ3QgaG93IHRoZSBlbmVteSB3b3JrZWQgYmVmb3JlIGJ1dCBpdCdzIG9rKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wb3MueCA9IHBvcyR7Y291bnRlcn0ueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wb3MueSA9IHBvcyR7Y291bnRlcn0ueTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH19KTtcclxuICAgICAgICAgICAgQygwLFszXSxbMF0se3I6JHtwYXJhbXMucmFkaXVzfSx5OiR7cGFyYW1zLnkqMn0seDoke3BhcmFtcy54KjJ9LHNmOihlKT0+e1xyXG4gICAgICAgICAgICAgICAgaWYoc3dpdGNoU3RhdGUke2NvdW50ZXJ9ID09PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICBlLnBvcy54ID0gLTEwMDAwMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wb3MueCA9IHBvcyR7Y291bnRlcn0ueDtcclxuICAgICAgICAgICAgICAgICAgICBlLnBvcy55ID0gcG9zJHtjb3VudGVyfS55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9fSk7XHJcbiAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwibm9ybWFsXCIsXHJcbiAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDUuODc0NjAzODM3NTM1MzA5LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyYWRpdXNcIjogMTYsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNwZWVkXCI6IDg1LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDY4OTguNjIyODQ5NTEyMDUxLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ5XCI6IDQ3MTEuNTU2MDMxNDI4MjI4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJYXCI6IDY4OTguNjIyODQ5NTEyMDUxLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJZXCI6IDQ3MTEuNTU2MDMxNDI4MjI4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4dlwiOiA3OC4wMDMyNTM4NDMxMDc2NyxcclxuICAgICAgICAgICAgLy8gICAgIFwieXZcIjogMzMuNzcxMTc2OTEwMDE3NjMsXHJcbiAgICAgICAgICAgIC8vICAgICBcImJvdW5kXCI6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInhcIjogNjQwMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInlcIjogNDI1MCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcIndcIjogNjAwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwiaFwiOiA3MDBcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICBcImlzTGF2YVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmbGFzaGxpZ2h0OiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgIGlmKE1hdGgucmFuZG9tKCkgPCAwLjUpIHJldHVybiAnJztcclxuICAgICAgICAgICAgcmV0dXJuIGVuZW15VHlwZU1hcC50dXJyZXQoe1xyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidHVycmV0XCIsXHJcbiAgICAgICAgICAgICAgICBcImFuZ2xlXCI6IHBhcmFtcy5hbmdsZSxcclxuICAgICAgICAgICAgICAgIFwic2hvb3RTcGVlZFwiOiAxLjU0LFxyXG4gICAgICAgICAgICAgICAgXCJ0aW1lclwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJwUmFkaXVzXCI6IHBhcmFtcy5yYWRpdXMgKiAoTWF0aC5yYW5kb20oKSowLjggKyAwLjIpLFxyXG4gICAgICAgICAgICAgICAgXCJwU3BlZWRcIjogcGFyYW1zLnNwZWVkICogKDEuNjUrTWF0aC5yYW5kb20oKSksXHJcbiAgICAgICAgICAgICAgICBcInByb2plY3RpbGVzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJzaG9vdERpcmVjdGlvbnNcIjogW1xyXG4gICAgICAgICAgICAgICAgICAgIDAsIE1hdGguUEkgLyAyLCBNYXRoLlBJLCBNYXRoLlBJICogMy8yXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJjc2RcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiZGVhZFByb2plY3RpbGVzXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJyYWRpdXNcIjogcGFyYW1zLnJhZGl1cyxcclxuICAgICAgICAgICAgICAgIFwic3BlZWRcIjogcGFyYW1zLnNwZWVkLFxyXG4gICAgICAgICAgICAgICAgXCJ4XCI6IHBhcmFtcy54LFxyXG4gICAgICAgICAgICAgICAgXCJ5XCI6IHBhcmFtcy55LFxyXG4gICAgICAgICAgICAgICAgXCJyZW5kZXJYXCI6IHBhcmFtcy5yZW5kZXJYLFxyXG4gICAgICAgICAgICAgICAgXCJyZW5kZXJZXCI6IHBhcmFtcy5yZW5kZXJZLFxyXG4gICAgICAgICAgICAgICAgXCJ4dlwiOiBwYXJhbXMueHYsXHJcbiAgICAgICAgICAgICAgICBcInl2XCI6IHBhcmFtcy55dixcclxuICAgICAgICAgICAgICAgIFwiYm91bmRcIjogcGFyYW1zLmJvdW5kLFxyXG4gICAgICAgICAgICAgICAgXCJpblZpZXdcIjogZmFsc2VcclxuICAgICAgICAgICAgfSwpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgY29uc3QgYWxyZWFkeUxvZ2dlZCA9IHt9O1xyXG5cclxuICAgIHZhciBzdHIgPSAnJztcclxuXHJcbiAgICBsZXQgYWxyZWFkeUxvZ2dlZEVuZW15ID0ge307XHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZW5lbWllcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgaWYoZW5lbXlUeXBlTWFwW2VuZW1pZXNbaV0udHlwZV0gIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHN0ciArPSAnXFxuJyArIGVuZW15VHlwZU1hcFtlbmVtaWVzW2ldLnR5cGVdKGVuZW1pZXNbaV0pO1xyXG4gICAgICAgIH0gZWxzZSBpZihhbHJlYWR5TG9nZ2VkRW5lbXlbZW5lbWllc1tpXS50eXBlXSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgYWxyZWFkeUxvZ2dlZEVuZW15W2VuZW1pZXNbaV0udHlwZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgbm8gZW5lbXkgdHlwZSBkZWYgZm9yICR7ZW5lbWllc1tpXS50eXBlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgb2JzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBjb25zdCBvID0gb2JzW2ldO1xyXG4gICAgICAgIGNvbnN0IHR5cGVEZWYgPSB0eXBlTWFwW28udHlwZV07XHJcblxyXG4gICAgICAgIGlmKG8udHlwZSA9PT0gJ3JvdW5kZWRjb3JuZXJzJyB8fCBvLnR5cGUgPT09ICdyb3VuZGVkbGF2YScpe1xyXG4gICAgICAgICAgICBjb25zdCBjaXJjbGVUeXBlID0gby50eXBlID09PSAncm91bmRlZGNvcm5lcnMnID8gJ2NpcmNsZS1ub3JtYWwnIDogJ2NpcmNsZS1sYXZhJztcclxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG8uY2lyY2xlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBvYnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogby5jaXJjbGVzW2ldLngsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogby5jaXJjbGVzW2ldLnksXHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBvLmNpcmNsZXNbaV0ucmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgIFwicmVuZGVyVHlwZVwiOiBcImNpcmNsZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW5WaWV3XCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGNpcmNsZVR5cGVcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVjdFR5cGUgPSBvLnR5cGUgPT09ICdyb3VuZGVkY29ybmVycycgPyAnbm9ybWFsJyA6ICdsYXZhJztcclxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG8ucmVjdHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgb2JzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IG8ucmVjdHNbaV0ueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBvLnJlY3RzW2ldLnksXHJcbiAgICAgICAgICAgICAgICAgICAgdzogby5yZWN0c1tpXS53LFxyXG4gICAgICAgICAgICAgICAgICAgIGg6IG8ucmVjdHNbaV0uaCxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiByZWN0VHlwZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYoby50eXBlID09PSAnY29sb3InKXtcclxuICAgICAgICAgICAgby54ICo9IDI7IG8ueSAqPSAyOyBvLncgKj0gMjsgby5oICo9IDI7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pblggPSBvLnggLSAxMDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pblkgPSBvLnkgLSAxMDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heFggPSBvLnggKyBvLncgKyAxMDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heFkgPSBvLnkgKyBvLmggKyAxMDA7XHJcbiAgICAgICAgICAgIHN0ciArPSBgdmFyIG1pblgke2NvdW50ZXJ9LCBtaW5ZJHtjb3VudGVyfSwgbWF4WCR7Y291bnRlcn0sIG1heFkke2NvdW50ZXJ9O1xyXG4gICAgICAgICAgICBtaW5YJHtjb3VudGVyfSA9ICR7bWluWH07bWluWSR7Y291bnRlcn0gPSAke21pbll9O21heFgke2NvdW50ZXJ9ID0gJHttYXhYfTttYXhZJHtjb3VudGVyfSA9ICR7bWF4WX07XHJcbiAgICAgICAgICAgIEMoMSxbM10sWzBdLHtoOjEsdzoxLHk6MCx4Oi0xMDAwMCxzZjooZSk9PntcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXllciA9IHdpbmRvdy5wbGF5ZXJzW3dpbmRvdy5zZWxmSWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwbGF5ZXIucG9zLngpID4gbWQobWluWCR7Y291bnRlcn0pICYmIChwbGF5ZXIucG9zLngpIDwgbWQobWF4WCR7Y291bnRlcn0pICYmIChwbGF5ZXIucG9zLnkpID4gbWQobWluWSR7Y291bnRlcn0pICYmIChwbGF5ZXIucG9zLnkpIDwgbWQobWF4WSR7Y291bnRlcn0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLmJhY2tncm91bmQ9XCIke28udGlsZUNvbG9yfVwiOyBjb2xvcnMudGlsZT1cIiR7by5iZ0NvbG9yfVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LH0pO1xcbmA7XHJcbiAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICB9IGVsc2UgaWYoby50eXBlID09PSAnc3dpdGNobGF2YScpe1xyXG4gICAgICAgICAgICBvLnggKj0gMjsgby55ICo9IDI7IG8udyAqPSAyOyBvLmggKj0gMjtcclxuICAgICAgICAgICAgc3RyICs9IGB2YXIgdGltZXIke2NvdW50ZXJ9ID0gJHtvLnRpbWVyfTsgdmFyIHN0YXRlJHtjb3VudGVyfSA9JHtvLnN0YXRlfTsgdmFyIHgke2NvdW50ZXJ9ID0gJHtvLnh9OyBcclxuICAgICAgICAgICAgQygxLFtdLFsxXSx7aDoke28uaH0sdzoke28ud30seToke28ueX0seDoke28ueH0sc2Y6KGUpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXIke2NvdW50ZXJ9IC09IGR0IC8gMTAwMDtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aW1lciR7Y291bnRlcn0gPCAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUke2NvdW50ZXJ9ID0gIXN0YXRlJHtjb3VudGVyfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RhdGUke2NvdW50ZXJ9ID09PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciR7Y291bnRlcn0gKz0gJHtvLm9uVGltZX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnBvcy54ID0geCR7Y291bnRlcn07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyJHtjb3VudGVyfSArPSAke28ub2ZmVGltZX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnBvcy54ID0gLTFFOTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBjcjooZSk9PntcclxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlJHtjb3VudGVyfSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIke2NvdW50ZXJ9IDwgMC4yICYmICR7by5vblRpbWV9ID4gMC4yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aW1lciR7Y291bnRlcn0gLyAwLjI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciR7Y291bnRlcn0gPCAwLjIgJiYgJHtvLm9mZlRpbWV9ID4gMC4yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjkgKiAoMSAtIHRpbWVyJHtjb3VudGVyfSAvIDAuMikgKyAwLjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICR7by5jb2xsaWRhYmxlfSA/ICcjYzcwMDAwJyA6ICcjOWUwMDAwJztcclxuICAgICAgICAgICAgICAgICAgICAvKmlmIChvYnN0YWNsZS5jb2xsaWRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnI2M3MDAwMCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSovIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gNDtcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZWN0KHgke2NvdW50ZXJ9LCBlLnBvcy55LCBlLmRpbWVuc2lvbnMueCwgZS5kaW1lbnNpb25zLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcXG5gO1xyXG4gICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgfSBlbHNlIGlmKG8udHlwZSA9PT0gJ2Jsb2NrJyB8fCBvLnR5cGUgPT09ICd0cmFucycpe1xyXG4gICAgICAgICAgICBvLnggKj0gMjsgby55ICo9IDI7IG8udyAqPSAyOyBvLmggKj0gMjtcclxuICAgICAgICAgICAgc3RyICs9IGBDKDEsW10sWzIwXSx7aDoke28uaH0sdzoke28ud30seToke28ueX0seDoke28ueH0sXHJcbiAgICAgICAgICAgICAgICBjcjooZSk9PntcclxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9ICR7by50eXBlID09PSAndHJhbnMnID8gXCJjb2xvcnMuYmFja2dyb3VuZFwiIDogXCInXCIgKyAoby5oZXggPz8gby5jb2xvcikgKyBcIidcIn07XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gJHtvLm9wYXEgPz8gMX07XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoZS5wb3MueCwgZS5wb3MueSwgZS5kaW1lbnNpb25zLngsIGUuZGltZW5zaW9ucy55KTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XFxuYDtcclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYoby50eXBlID09PSAnZ3JhcHBsZXBvaW50JyB8fCBvLnR5cGUgPT09ICdtb3ZpbmdncmFwcGxlcG9pbnQnKXtcclxuICAgICAgICAgICAgby54ICo9IDI7IG8ueSAqPSAyO1xyXG4gICAgICAgICAgICBpZihvLnR5cGUgPT09ICdncmFwcGxlcG9pbnQnKXtcclxuICAgICAgICAgICAgICAgIHN0ciArPSBgQygwLFtdLFswXSx7cjoyMCsxMi8yLHk6JHtvLnl9LHg6JHtvLnh9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNyOihlKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmlzR3JhcHBsZVBvaW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJyNjOWM5YzknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKGUucG9zLngsIGUucG9zLnksIDIwLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xcbmA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBvO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwYXRoOiAnWyd9O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcmFtcy5wb2ludHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGF0aCArPSBgWyR7cGFyYW1zLnBvaW50c1tpXVswXSoyfSxbJHtwYXJhbXMucG9pbnRzW2ldWzFdKjJ9XSwke3BhcmFtcy5zcGVlZCAqIDIgLyAxMDAwfV0sYDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwLmN1cnJlbnRQb2ludCA9IHBhcmFtcy5jdXJyZW50UG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBwLnggPSBwYXJhbXMucG9pbnRzWzBdWzBdICogMjtcclxuICAgICAgICAgICAgICAgIHAueSA9IHBhcmFtcy5wb2ludHNbMF1bMV0gKiAyO1xyXG5cclxuICAgICAgICAgICAgICAgIHAucGF0aCA9IHAucGF0aC5zdWJzdHJpbmcoMCwgcC5wYXRoLmxlbmd0aC0xKTtcclxuICAgICAgICAgICAgICAgIHAucGF0aCArPSAnXSc7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gYEMoMCxbMF0sWzBdLHtyOjIwKzEyLzIsXHJcbiAgICAgICAgICAgICAgICAgICAgY3I6KGUpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuaXNHcmFwcGxlUG9pbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2M5YzljOSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoZS5wb3MueCwgZS5wb3MueSwgMjAsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxjdXJyZW50UG9pbnQ6JHtwLmN1cnJlbnRQb2ludH0seDoke3AueH0seToke3AueX0scGF0aDoke3AucGF0aH1cclxuICAgICAgICAgICAgICAgIH0pO1xcbmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYoby50eXBlID09PSAnY2lyY2xlLXNlbnRyeScpe1xyXG4gICAgICAgICAgICBvLnggKj0gMjsgby55ICo9IDI7IG8uciAqPSAyO1xyXG4gICAgICAgICAgICBvLmxhc2VyLnggKj0gMjsgby5sYXNlci55ICo9IDI7IG8ubGFzZXIudyAqPSAyOyBvLmxhc2VyLmggKj0gMjtcclxuICAgICAgICAgICAgc3RyICs9IGBDKDEsWzVdLFsxXSx7aDoke28ubGFzZXIuaH0sdzoke28ubGFzZXIud30seToke28ueS1vLmxhc2VyLmgvMn0seDoke28ueC1vLmxhc2VyLncvMn0sXHJcbiAgICAgICAgICAgICAgICBib3VuZFBsYXllcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHJlc3RBbmdsZXM6IFske28ucmVzdCpNYXRoLlBJLzE4MH0sICR7by5yZXN0Kk1hdGguUEkvMTgwK01hdGguUEl9XSxcclxuICAgICAgICAgICAgICAgIHRvUmVzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhvbWluZ1JvdGF0ZVNwZWVkOiAke28uc3BlZWQgLyA4NjAwMH0sXHJcbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25SYWRpdXM6ICR7TWF0aC5zcXJ0KG8ubGFzZXIudyoqMitvLmxhc2VyLmgqKjIpLzJ9LFxyXG4gICAgICAgICAgICAgICAgc3Bva2VBbmdsZXM6IFswLCBNYXRoLlBJXSxcclxuICAgICAgICAgICAgICAgIHBpdm90WDogJHtvLnh9LFxyXG4gICAgICAgICAgICAgICAgcGl2b3RZOiAke28ueX1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIEMoMCxbXSxbMF0se3g6JHtvLnh9LHk6JHtvLnl9LHI6JHtvLnJ9LGNyOihlKT0+e1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHdpbmRvdy5jb2xvcnMudGlsZTtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5hcmMoZS5wb3MueCwgZS5wb3MueSwgZS5zYXQuciwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxNTtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5hcmMoXHJcbiAgICAgICAgICAgICAgICAgICAgZS5wb3MueCxcclxuICAgICAgICAgICAgICAgICAgICBlLnBvcy55LFxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGUuc2F0LnIgLSAzMCwgMCksXHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgfX0pO2BcclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYoby50eXBlID09PSAncmVzZXRjb2lucycpe1xyXG4gICAgICAgICAgICBvLnggKj0gMjsgby55ICo9IDI7IG8udyAqPSAyOyBvLmggKj0gMjtcclxuICAgICAgICAgICAgc3RyICs9IGBDKDEsW10sWzIwXSx7eDoke28ueH0seToke28ueX0sdzoke28ud30saDoke28uaH0saGV4OicjMDAwMDAwJyxhbHBoYTowLGNyOigpPT57fSxlZjooKT0+e1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG9ic3RhY2xlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob2JzdGFjbGVzW2ldLmNvbGxlY3RlZCAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzdGFjbGVzW2ldLmNvbGxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihvYnN0YWNsZXNbaV0uaXNDb2luZG9vciA9PT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic3RhY2xlc1tpXS5jb2lucyA9IG9ic3RhY2xlc1tpXS5tYXhDb2luczsgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSAgICBcclxuICAgICAgICAgICAgfX0pO2A7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZihvLnR5cGUgPT09ICdyZXNldHRpbWV0cmFwcycpe1xyXG4gICAgICAgICAgICBvLnggKj0gMjsgby55ICo9IDI7IG8udyAqPSAyOyBvLmggKj0gMjtcclxuICAgICAgICAgICAgc3RyICs9IGBDKDEsW10sWzIwXSx7eDoke28ueH0seToke28ueX0sdzoke28ud30saDoke28uaH0saGV4OicjMDAwMDAwJyxhbHBoYTowLGNyOigpPT57fSxlZjooKT0+e1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG9ic3RhY2xlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob2JzdGFjbGVzW2ldLnRpbWVUcmFwVGltZSAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzdGFjbGVzW2ldLnRpbWVUcmFwVGltZSA9IG9ic3RhY2xlc1tpXS50aW1lVHJhcE1heFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSAgICBcclxuICAgICAgICAgICAgfX0pO2A7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZURlZiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmKGFscmVhZHlMb2dnZWRbby50eXBlXSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGFscmVhZHlMb2dnZWRbby50eXBlXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gdHlwZSBkZWYgZm9yICcgKyBvLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt0eXBlOiB0eXBlRGVmLnR5cGV9O1xyXG5cclxuICAgICAgICBmb3IobGV0IGtleSBpbiBvKXtcclxuICAgICAgICAgICAgaWYoa2V5ID09PSAndHlwZScpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZih0eXBlRGVmW2tleV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zW3R5cGVEZWZba2V5XV0gPSBvW2tleV07Ly8gby5yIGluc3RlYWQgb2Ygby5yYWRpdXMgc2V0IHRvIG9ba2V5XSBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtc1trZXldID0gb1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJhbXMueCAqPSAyO1xyXG4gICAgICAgIHBhcmFtcy55ICo9IDI7XHJcbiAgICAgICAgaWYocGFyYW1zLncpIHBhcmFtcy53ICo9IDI7XHJcbiAgICAgICAgaWYocGFyYW1zLmgpIHBhcmFtcy5oICo9IDI7XHJcbiAgICAgICAgaWYocGFyYW1zLnIgIT09IHVuZGVmaW5lZCkgcGFyYW1zLnIgKj0gMjtcclxuXHJcbiAgICAgICAgaWYodHlwZURlZi5jdXN0b21NYXAgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vcmVQYXJhbXMgPSB0eXBlRGVmLmN1c3RvbU1hcChvKTtcclxuICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gbW9yZVBhcmFtcyl7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IG1vcmVQYXJhbXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSBge2A7XHJcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gcGFyYW1zKXtcclxuICAgICAgICAgICAgcGFyYW1TdHJpbmcgKz0gYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldKX0sYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1TdHJpbmcgKz0gJ30nO1xyXG5cclxuICAgICAgICBsZXQgdHlwZVN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcy50eXBlKTtcclxuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZVN0cmluZy5zbGljZSgxLCB0eXBlU3RyaW5nLmxlbmd0aC0xKTtcclxuXHJcbiAgICAgICAgLy9DKDEsW10sWzBdLHtoOjEwMCx3OjExMDAseTo0MzAwLHg6NDYwMCx9KTtcclxuICAgICAgICBzdHIgKz0gYEMoJHt0eXBlU3RyaW5nfSwke3BhcmFtU3RyaW5nfSlcXG5gO1xyXG4gICAgfVxyXG5cclxuICAgIGV2YWwoc3RyKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaW1wb3J0TWFwOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///78\n')}}]);