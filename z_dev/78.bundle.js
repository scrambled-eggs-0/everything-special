"use strict";(self.webpackChunkomniserver=self.webpackChunkomniserver||[]).push([[78],{78:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(763);\n\r\nfunction importMap(str){\r\n    obstacles.length = 0;\r\n\r\n    const o = JSON.parse(str);\r\n\r\n    let {arena, safes, spawns, playerSpawn, tileColor, bgColor, texts} = o;\r\n\r\n    // arena.width, arena.height\r\n\r\n    mapDimensions.x=arena.width * 2;\r\n    mapDimensions.y=arena.height * 2;\r\n\r\n    spawnPosition.x=playerSpawn.x*2;\r\n    spawnPosition.y=playerSpawn.y*2;\r\n    _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.respawnPlayer();\r\n    colors.background=tileColor; colors.tile=bgColor;\r\n\r\n    let counter = 0;\r\n\r\n    let obs = o.obstacles;\r\n    let enemies = o.enemy;\r\n\r\n    safes = safes.map(p => {\r\n        p.type = "safe";\r\n        return p;\r\n    });\r\n\r\n    texts = texts.map(p => {\r\n        p.type = "text";\r\n        return p;\r\n    });\r\n\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n\r\n    const typeMap = {\r\n        \'normal\': {\r\n            type: [1,[],[0]],\r\n        },\r\n        // \'trans\': {\r\n        //     type: [1,[],[20]],\r\n        //     customMap: (params) => {\r\n        //         return {hex: \'#000000\', alpha: params.opaq};\r\n        //     }\r\n        // },\r\n        // \'block\': {\r\n        //     type: [1,[],[20]],\r\n        //     customMap: (params) => {\r\n        //         return {hex: params.color, alpha: 1};\r\n        //     }\r\n        // },\r\n        \'grav\': {\r\n            type: [1,[],[13]],\r\n            customMap: (params) => {\r\n                const p = {};\r\n                if(params.direction === \'right\'){\r\n                    p.conveyorAngle = 0\r\n                } else if(params.direction === \'down\'){\r\n                    p.conveyorAngle = 90;\r\n                } else if(params.direction === \'left\'){\r\n                    p.conveyorAngle = 180;\r\n                } else {\r\n                    p.conveyorAngle = 270;\r\n                }\r\n                p.conveyorFriction = 0.8;\r\n                p.conveyorAngleRotateSpeed = 0;\r\n                p.conveyorForce = params.force / 10000 * 7.08 * 5 / 16.66;\r\n                return p;\r\n            }\r\n        },\r\n        \'circle-normal\': {\r\n            type: [0,[],[0]],\r\n            radius: \'r\' // this means map radius to r\r\n            // all other params filled in 1:1, so x will be filled in from x, y from y, etc.\r\n        },\r\n        \'circle-lava\': {\r\n            type: [0,[],[1]],\r\n            radius: \'r\',\r\n            customMap: (params) => {\r\n                return {\r\n                    boundPlayer: true,\r\n                }\r\n            }\r\n        },\r\n        \'circle-tp\': {\r\n            type: [0,[],[12]],\r\n            customMap: (params) => {\r\n                return {\r\n                    tpx: params.tpx * 2,\r\n                    tpy: params.tpy * 2\r\n                }\r\n            }\r\n        },\r\n        \'lava\': {\r\n            type: [1,[],[1]],\r\n            customMap: (params) => {\r\n                return {\r\n                    boundPlayer: params.canCollide\r\n                };\r\n            }\r\n        },\r\n        \'poly\': {\r\n            type: [2,[],[0]],\r\n            customMap: (params) => {\r\n                const p = {points: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                return p;\r\n            }\r\n        },\r\n        \'poly-tp\': {\r\n            type: [2,[],[12]],\r\n            customMap: (params) => {\r\n                const p = {points: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                p.tpx = params.tpx * 2;\r\n                p.tpy = params.tpy * 2;\r\n                return p;\r\n            }\r\n        },\r\n        \'poly-safe\': {\r\n            type: [2,[],[11]],\r\n            customMap: (params) => {\r\n                const p = {points: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                return p;\r\n            }\r\n        },\r\n        \'poly-vinette\': {\r\n            type: [2,[],[24]],\r\n            customMap: (params) => {\r\n                const p = {points: [],\r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o\r\n                };\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                return p;\r\n            }\r\n        },\r\n        \'poly-lava\': {\r\n            type: [2,[],[1]],\r\n            customMap: (params) => {\r\n                const p = {points: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.points.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2\r\n                    ])\r\n                }\r\n                p.boundPlayer = true;//params.canCollide;\r\n                return p;\r\n            }\r\n        },\r\n        \'move\': {\r\n            type: [1,[0],[0]],\r\n            customMap: (params) => {\r\n                const p = {path: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n    \r\n                p.currentPoint = params.currentPoint;\r\n    \r\n                const currentPoint = p.path[p.currentPoint];\r\n                let nextPointIndex = p.currentPoint+1;\r\n                if(nextPointIndex === p.path.length) nextPointIndex = 0;\r\n                const nextPoint = p.path[nextPointIndex];\r\n    \r\n                const totalDist = Math.sqrt((nextPoint[0]-currentPoint[0])**2+(nextPoint[1]-currentPoint[1])**2);\r\n                const fractionCovered = Math.sqrt((params.x*2-currentPoint[0])**2+(params.y*2-currentPoint[1])**2);\r\n                \r\n                p.currentPoint += fractionCovered / totalDist;\r\n    \r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n                return p;\r\n            }\r\n        },\r\n        \'lavamove\': {\r\n            type: [1,[0],[1]],\r\n            customMap: (params) => {\r\n                const p = {path: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n    \r\n                p.currentPoint = params.currentPoint;\r\n    \r\n                const currentPoint = p.path[p.currentPoint];\r\n                let nextPointIndex = p.currentPoint+1;\r\n                if(nextPointIndex === p.path.length) nextPointIndex = 0;\r\n                const nextPoint = p.path[nextPointIndex];\r\n    \r\n                const totalDist = Math.sqrt((nextPoint[0]-currentPoint[0])**2+(nextPoint[1]-currentPoint[1])**2);\r\n                const fractionCovered = Math.sqrt((params.x*2-currentPoint[0])**2+(params.y*2-currentPoint[1])**2);\r\n                \r\n                p.currentPoint += fractionCovered / totalDist;\r\n    \r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n    \r\n                p.boundPlayer = false;\r\n                if(params.collidable) p.boundPlayer = true;\r\n                return p;\r\n            }\r\n        },\r\n        \'tornado\': {\r\n            type: [1,[],[23]],\r\n            spinRadius: \'tornadoStrength\' \r\n        },\r\n        \'vinette\': {\r\n            type: [1,[],[24]],\r\n            customMap: (params) => {\r\n                return {\r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o\r\n                }\r\n            }\r\n        },\r\n        \'tpmove\': {\r\n            type: [1,[0],[12]],\r\n            customMap: (params) => {\r\n                const p = {path: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n                \r\n                p.currentPoint = params.currentPoint;\r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n                p.tpx = params.tpx * 2; p.tpy = params.tpy * 2;\r\n                return p;\r\n            }\r\n        },\r\n        \'movingsafe\': {\r\n            type: [1,[0],[11]],\r\n            customMap: (params) => {\r\n                const p = {path: []};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n                p.currentPoint = params.currentPoint;\r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n                return p;\r\n            }\r\n        },\r\n        \'movingvinette\': {\r\n            type: [1,[0],[24]],\r\n            customMap: (params) => {\r\n                const p = {path: [],\r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o\r\n                };\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path.push([\r\n                        params.points[i][0]*2,\r\n                        params.points[i][1]*2,\r\n                        params.speed * 2 / 1000\r\n                    ])\r\n                }\r\n                p.currentPoint = params.currentPoint;\r\n                p.x = p.path[0][0];\r\n                p.y = p.path[0][1];\r\n                return p;\r\n            }\r\n        },\r\n        \'timetrap\': {\r\n            type: [1,[],[17]],\r\n            customMap: (params) => {\r\n                //shared.C(1,[],[17],{h:200,w:300,y:700,x:300,timeTrapToShowTenth:true,timeTrapToKill:true,timeTrapRecoverySpeed:1.5,timeTrapMaxTime:300,});\r\n                const p = {timeTrapToShowTenth:false,timeTrapToKill:true,timeTrapRecoverySpeed:params.cdmult};\r\n    \r\n                p.timeTrapMaxTime = params.maxTime * 1000;\r\n                return p;\r\n            }\r\n        },\r\n        \'oval\': {\r\n            type: [0,[],[0]],\r\n            customMap: (params) => {\r\n                return {r: Math.min(params.radius, params.radius2)*2};\r\n            }\r\n        },\r\n        \'lava-oval\': {\r\n            type: [0,[],[1]],\r\n            customMap: (params) => {\r\n                return {r: Math.min(params.radius, params.radius2)*2, boundPlayer: true};\r\n            }\r\n        },\r\n        \'safe\': {\r\n            type: [1,[],[11]],\r\n        },\r\n        \'circle-safe\': {\r\n            type: [0,[],[11]],\r\n            r: \'r\'\r\n        },\r\n        \'circle-vinette\': {\r\n            type: [0,[],[24]],\r\n            customMap: (params) => {\r\n                return {\r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o,\r\n                    r: params.r ?? params.radius\r\n                }\r\n            }\r\n        },\r\n        \'circle-coin\': {\r\n            radius: \'r\',\r\n            type: [0,[],[7]],\r\n            customMap: (params) => {\r\n                return {\r\n                    color: \'#d5d612\',\r\n                    coinAmount: 1\r\n                }\r\n            }\r\n        },\r\n        \'bounce\': {\r\n            type: [1,[],[2]],\r\n            customMap: (params) => {\r\n                return {bounciness: params.effect/3/10, decay: 0.5};\r\n            }\r\n        },\r\n        \'rotate-normal\': {\r\n            type: [1,[1],[0]],\r\n            customMap: (params) => {\r\n                params.x = params.distToPivot + params.pivotX;\r\n                params.y = params.pivotY;\r\n                return {\r\n                    x: params.x * 2 - params.w,\r\n                    y: params.y * 2 - params.h,\r\n                    initialRotation: params.angle * 180 / Math.PI,\r\n                    rotateSpeed: params.rotateSpeed / 360 / 220 * 1.36,\r\n                    pivotX: params.pivotX * 2,\r\n                    pivotY: params.pivotY * 2\r\n                };\r\n            }\r\n        },\r\n        \'rotate-lava\': {\r\n            type: [1,[1],[1]],\r\n            customMap: (params) => {\r\n                params.x = params.distToPivot + params.pivotX;\r\n                params.y = params.pivotY;\r\n                return {\r\n                    x: params.x * 2 - params.w,\r\n                    y: params.y * 2 - params.h,\r\n                    initialRotation: params.angle,\r\n                    rotateSpeed: params.rotateSpeed / 360 / 220 * 1.36,\r\n                    pivotX: params.pivotX * 2,\r\n                    pivotY: params.pivotY * 2,\r\n                    boundPlayer: params.canCollide\r\n                };\r\n            }\r\n        },\r\n        \'rotatingsafe\': {\r\n            type: [1,[1],[11]],\r\n            customMap: (params) => {\r\n                // console.log(params.angle - lastRotAngle);\r\n                // lastRotAngle = params.angle;\r\n                // lastRotAngle += Math.PI * 3/2;\r\n    \r\n                // 0: params.y += 1, x += 0\r\n                // 90: params.x -= 1, y += 0\r\n    \r\n                // params.angle = 0;\r\n    \r\n                // const rotation = params.angle * Math.PI / 180;\r\n    \r\n                // {\r\n                //     "x": 896.5984655296048,\r\n                //     "y": 1720.8819734868184,\r\n                //     "w": 25,\r\n                //     "h": 25,\r\n                //     "type": "rotatingsafe",\r\n                //     "angle": -66493.5,\r\n                //     "rotateSpeed": -90,\r\n                //     "pivotX": 925,\r\n                //     "pivotY": 1625,\r\n                //     "distToPivot": 100,\r\n                //     "canCollide": true,\r\n                //     "cullingRadius": 117.67766952966369,\r\n                //     "unSim": 0,\r\n                //     "inView": false\r\n                // },\r\n    \r\n                // in eX, position is set like this\r\n            //     obj.x =\r\n            //     Math.cos((obj.angle * Math.PI) / 180) *\r\n            //         obj.distToPivot +\r\n            //     obj.pivotX;\r\n            // obj.y =\r\n            //     Math.sin((obj.angle * Math.PI) / 180) *\r\n            //         obj.distToPivot +\r\n            //     obj.pivotY;\r\n    \r\n                // and we render like this\r\n    \r\n                // ctx.translate(center.x, center.y);\r\n                // ctx.rotate(degToRad(obstacle.angle));\r\n                // ctx.rect(\r\n                //     -obstacle.w / 2,\r\n                //     -obstacle.h / 2,\r\n                //     obstacle.w,\r\n                //     obstacle.h\r\n                // );\r\n    \r\n                // so obj.x, obj.y = centerX. \r\n    \r\n                // let angle = params.angle;\r\n    \r\n                // lets try setting angle to 0 and see what happens\r\n                // params.angle = 45;\r\n                params.x = params.distToPivot + params.pivotX;\r\n                params.y = params.pivotY;\r\n    \r\n                // they\'re in a straight line like o - ---\r\n    \r\n                // so now, lets rotate the angle around the obs center. We know that the center point of the safe is its center so lets calculate our own distToPivot from that\r\n    \r\n                // const middleX = params.x + params.w / 2;\r\n                // const middleY = params.y + params.h / 2\r\n    \r\n                // const realDistToPivot = Math.sqrt((params.x - params.pivotX) ** 2 + (params.y - params.pivotY) ** 2);\r\n    \r\n                // // // now we have that, we can set the x and y\r\n    \r\n                // // // params.angle = angle;\r\n                // const x = Math.cos(params.angle * Math.PI / 180) * dist + params.pivotX - params.w / 2;\r\n                // const y = Math.sin(params.angle * Math.PI / 180) * dist + params.pivotY - params.h / 2;\r\n    \r\n                return {\r\n                    // x:x*2,y:y*2,initialRotation: 0,\r\n                    x: params.x * 2 - params.w,\r\n                    y: params.y * 2 - params.h,\r\n                    initialRotation: params.angle,\r\n                    rotateSpeed: params.rotateSpeed / 360 / 220 * 1.36,\r\n                    pivotX: params.pivotX * 2,\r\n                    pivotY: params.pivotY * 2\r\n                };\r\n            }\r\n        },\r\n        \'rotatingvinette\': {\r\n            type: [1,[1],[24]],\r\n            customMap: (params) => {\r\n                params.x = params.distToPivot + params.pivotX;\r\n                params.y = params.pivotY;\r\n    \r\n                return {\r\n                    x: params.x * 2 - params.w,\r\n                    y: params.y * 2 - params.h,\r\n                    initialRotation: params.angle,\r\n                    rotateSpeed: params.rotateSpeed / 360 / 220 * 1.36,\r\n                    pivotX: params.pivotX * 2,\r\n                    pivotY: params.pivotY * 2,\r\n                    \r\n                    innerR: params.vc.r,\r\n                    innerG: params.vc.g,\r\n                    innerB: params.vc.b,\r\n                    innerSize: params.ir,\r\n                    outerR: params.vc.r,\r\n                    outerG: params.vc.g,\r\n                    outerB: params.vc.b,\r\n                    outerSize: params.or,\r\n                    innerOpacity: 0,\r\n                    outerOpacity: params.o\r\n                \r\n                };\r\n            }\r\n        },\r\n        \'check\': {\r\n            type: [1,[],[9]],\r\n            customMap: (params) => {\r\n                return {\r\n                    checkpointOffsetX: 0,\r\n                    checkpointOffsetY: 0\r\n                }\r\n            }\r\n        },\r\n        \'tp\': {\r\n            type: [1,[],[12]],\r\n            customMap: (params) => {\r\n                return {\r\n                    tpx: params.tpx * 2,\r\n                    tpy: params.tpy * 2\r\n                }\r\n            }\r\n        },\r\n        \'winpad\': {\r\n            type: [1,[],[6]]\r\n        },\r\n        \'speed\': {\r\n            type: [1,[],[19]],\r\n            customMap: (params) => {\r\n                return {\r\n                    speedChangePermanent: false,\r\n                    speedMult: params.speedInc\r\n                }\r\n            }\r\n        },\r\n        \'size\': {\r\n            type: [1,[],[18]],\r\n            customMap: (params) => {\r\n                return {\r\n                    sizeChangePermanent: false,\r\n                    sizeMult: params.size / 24.5\r\n                }\r\n            }\r\n            //shared.C(1,[],[18],{h:200,w:300,y:700,x:300,sizeChangePermanent:false,sizeMult:1.5,});\r\n        },\r\n        \'snap\': {\r\n            type: [1,[],[16]],\r\n            customMap: (params) => {\r\n                return {\r\n                    snapAngleRotateSpeed: 0,\r\n                    snapAngle: 0,\r\n                    snapCooldown: params.snapWait,\r\n                    snapDistanceY: params.snapDistance,\r\n                    snapDistanceX: params.snapDistance,\r\n                    toSnapX: params.snapX,\r\n                    toSnapY: params.snapY\r\n                }\r\n            }\r\n            // {\r\n            //     "x": 11050,\r\n            //     "y": 1550,\r\n            //     "w": 900,\r\n            //     "h": 500,\r\n            //     "type": "snap",\r\n            //     "snapDistance": 50,\r\n            //     "snapWait": 0.4,\r\n            //     "snapX": true,\r\n            //     "snapY": true,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        \'coin\': {\r\n            type: [1,[],[7]],\r\n            customMap: (params) => {\r\n                return {\r\n                    color: \'#d5d612\',\r\n                    coinAmount: 1\r\n                }\r\n            }\r\n        },\r\n        \'coindoor\': {\r\n            type: [1,[],[8]],\r\n            customMap: (params) => {\r\n                return {\r\n                    coinDoorColor: \'#d5d612\',\r\n                    coindoorCoinAmount: params.coins\r\n                }\r\n            }\r\n        },\r\n        \'button\': {\r\n            type: [1,[],[7]],\r\n            customMap: (params) => {\r\n                const top = {\r\n                    "x": 14941.438100925527,\r\n                    "y": 5495.870128796381\r\n                };\r\n                const bottom = {\r\n                    "x": 18420.158621406357,\r\n                    "y": 8873.08670452917\r\n                };\r\n                const x = params.x * 2;\r\n                const y = params.y * 2;\r\n                const inside = x > top.x && x < bottom.x && y > top.y && y < bottom.y;\r\n                return {\r\n                    color: inside ? \'#00FF00\' : \'#d6d612\',\r\n                    coinAmount: 1\r\n                }\r\n            }\r\n        },\r\n        \'door\': {\r\n            type: [1,[],[8]],\r\n            customMap: (params) => {\r\n                const id = params.id;\r\n                let coinAmount = 0;\r\n                for(let i = 0; i < obs.length; i++){\r\n                    if(obs[i].type === \'button\' && obs[i].id === id){\r\n                        coinAmount++;\r\n                    }\r\n                }\r\n                const top = {\r\n                    "x": 14941.438100925527,\r\n                    "y": 5495.870128796381\r\n                };\r\n                const bottom = {\r\n                    "x": 18420.158621406357,\r\n                    "y": 8873.08670452917\r\n                };\r\n                const x = params.x * 2;\r\n                const y = params.y * 2;\r\n                const inside = x > top.x && x < bottom.x && y > top.y && y < bottom.y;\r\n                return {\r\n                    coinDoorColor: inside ? \'#00FF00\' : \'#d6d612\',\r\n                    coindoorCoinAmount: inside ? 5 : coinAmount\r\n                }\r\n            }\r\n        },\r\n        \'raxis\': {\r\n            type: [1,[],[15]],\r\n            customMap: (params) => {\r\n                return {\r\n                    axisSpeedMultY: params.ry === true ? 0 : 1,\r\n                    axisSpeedMultX: params.rx === true ? 0 : 1\r\n                }\r\n            }\r\n        },\r\n        \'push\': {\r\n            type: [1,[],[25]],\r\n            customMap: (params) => {\r\n                return {\r\n                    pushAngle: {\'right\': 180, \'down\': 270, \'left\': 0, \'right\': 90}[params.dir],\r\n                    maxPushDistance: params.max * 2,\r\n                    idlePushBackSpeed: params.pushBack / 20,\r\n                    positiveDirectionOnly: true,\r\n                    pushConversionRatio: 0.86\r\n                }\r\n            }\r\n        },//shared.C(3,[],[20],{fontSize:80,text:\'I am a text :D\',y:800,x:450,hex:colourRgb(100,100,100),});\r\n        \'text\': {\r\n            customMap: (params) => {\r\n                // {\r\n                //     "x": 300,\r\n                //     "y": 75,\r\n                //     "angle": 0,\r\n                //     "text": "Welcome to the",\r\n                //     "size": 30,\r\n                //     "story": false,\r\n                //     "element": {\r\n                //         "tWidth": 0,\r\n                //         "tHeight": 0\r\n                //     }\r\n                // },\r\n                if(params.angle !== 0) {\r\n                    return {\r\n                        type: [3,[1],[20]],\r\n                        fontSize: params.size * 2,\r\n                        text: params.text,\r\n                        hex: \'#FFFFFF\',\r\n                        pivotX: params.x * 2,\r\n                        pivotY: params.y * 2,\r\n                        rotateSpeed: 0,\r\n                        initialRotation: params.angle,\r\n                    }\r\n                }//"shared.C(3,[1],[20],{fontSize:80,text:\'I am a text :D\',y:800,x:450,pivotY:800,pivotX:450,rotateSpeed:0,initialRotation:45,hex:colourRgb(100,100,100),});"\r\n                else {\r\n                    return {\r\n                        type: [3,[],[20]],\r\n                        fontSize: params.size * 2,\r\n                        text: params.text,\r\n                        hex: \'#FFFFFF\'\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \'platformer\': {\r\n            type: [1,[],[14]],\r\n            customMap: (params) => {\r\n                const p = {};\r\n                if(params.direction === \'right\'){\r\n                    p.platformerAngle = 0\r\n                } else if(params.direction === \'down\'){\r\n                    p.platformerAngle = 90;\r\n                } else if(params.direction === \'left\'){\r\n                    p.platformerAngle = 180;\r\n                } else {\r\n                    p.platformerAngle = 270;\r\n                }\r\n                p.platformerFriction = 0.9;\r\n                p.platformerAngleRotateSpeed = 0;\r\n                p.platformerForce = params.force / 10000 * 1.5 * 1.8 * 1.6 * 10 / 16.66;\r\n                p.jumpForce = params.jumpHeight / 10 / 8.2 * 2.32 / 1.2 / 2;\r\n                p.jumpDecay = 0.9525;\r\n                p.maxJumpCooldown = 20 * 16.6;\r\n                return p;\r\n            }\r\n            // {\r\n            //     "x": 6600,\r\n            //     "y": 300,\r\n            //     "w": 500,\r\n            //     "h": 350,\r\n            //     "type": "platformer",\r\n            //     "force": 1500,\r\n            //     "dir": {\r\n            //         "x": 0,\r\n            //         "y": 1500\r\n            //     },\r\n            //     "direction": "down",\r\n            //     "jumpHeight": 145,\r\n            //     "maxForce": 1000,\r\n            //     "variableJumpHeight": false,\r\n            //     "platformerFriction": 0.8,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        \'breakable\': {\r\n            type: [1,[],[10]],\r\n            customMap: (params) => {\r\n                return {\r\n                    maxStrength: Math.max(200,params.maxStrength * Math.max(1,params.timer * 1000 / 60)),\r\n                    regenTime: params.regenTime * 1000 / 15,\r\n                    healSpeed: 1\r\n                }\r\n            }\r\n        },\r\n        // shared.C(1,[],[10],{h:200,w:300,y:700,x:300,healSpeed:1,regenTime:100,maxStrength:60,});\r\n        // {\r\n        //     "x": 2950,\r\n        //     "y": 2650,\r\n        //     "w": 200,\r\n        //     "h": 50,\r\n        //     "type": "breakable",\r\n        //     "maxStrength": 40,\r\n        //     "currentStrength": 40,\r\n        //     "time": 0,\r\n        //     "timer": 0,\r\n        //     "regenTime": 3,\r\n        //     "inView": false\r\n        // },\r\n        \r\n    \r\n        // {\r\n        //     "x": 8550,\r\n        //     "y": 9500,\r\n        //     "radius": 300,\r\n        //     "type": "circle-hollow-slice",\r\n        //     "startAngle": 1.5707963267948966,\r\n        //     "endAngle": -1.5707963267948966,\r\n        //     "startPolygon": {\r\n        //         "points": [\r\n        //             [\r\n        //                 8550,\r\n        //                 9650\r\n        //             ],\r\n        //             [\r\n        //                 8550,\r\n        //                 9800\r\n        //             ]\r\n        //         ],\r\n        //         "type": "poly",\r\n        //         "props": {}\r\n        //     },\r\n        //     "endPolygon": {\r\n        //         "points": [\r\n        //             [\r\n        //                 8550,\r\n        //                 9350\r\n        //             ],\r\n        //             [\r\n        //                 8550,\r\n        //                 9200\r\n        //             ]\r\n        //         ],\r\n        //         "type": "poly",\r\n        //         "props": {}\r\n        //     },\r\n        //     "innerRadius": 150,\r\n        //     "toRotate": false,\r\n        //     "rotateSpeed": 0,\r\n        //     "renderType": "circle",\r\n        //     "inView": false\r\n        // },\r\n        \'circle-hollow-slice\': {\r\n            type: [4,[],[0]],\r\n            customMap: (params) => {\r\n                return {\r\n                    r: params.radius * 2,\r\n                    innerRadius: params.innerRadius * 2,\r\n                    startSliceAngle: params.startAngle,\r\n                    endSliceAngle: params.endAngle,\r\n                    startSliceAngleRotateSpeed: params.rotateSpeed / 2000,\r\n                    endSliceAngleRotateSpeed: params.rotateSpeed / 2000\r\n                }\r\n            }\r\n        },\r\n    \r\n        \'circle-slice\': {\r\n            type: [4,[],[0]],\r\n            customMap: (params) => {\r\n                return {\r\n                    r: params.radius * 2,\r\n                    innerRadius: 0,\r\n                    startSliceAngle: params.startAngle,\r\n                    endSliceAngle: params.endAngle,\r\n                    startSliceAngleRotateSpeed: 0,\r\n                    endSliceAngleRotateSpeed: 0\r\n                }\r\n            }\r\n        },\r\n    \r\n        \'ship\': {\r\n            type: [1,[],[27]],\r\n            customMap: (params) => {\r\n                return {\r\n                    changeShipStateTo: params.state,\r\n                    initialShipAngle: -Math.PI / 2,\r\n                    shipTurnSpeed: Math.PI / 20 / 16.66 / 2\r\n                }\r\n            }\r\n        },\r\n    \r\n        \'musicchange\': {\r\n            type: [1,[],[26]],\r\n            customMap: (params) => {\r\n                return {\r\n                    x: params.x * 2,\r\n                    y: params.y * 2,\r\n                    w: params.w * 2,\r\n                    h: params.h * 2,\r\n                    musicPath: params.musicPath\r\n                };\r\n            }\r\n        },\r\n    \r\n        \'grpu\': {\r\n            type: [1,[],[28]],\r\n            customMap: (params) => {\r\n                return {\r\n                    changeGrappleStateTo: params.state,       \r\n                    grappleRange: 488,\r\n                    grappleForce: 0.06,\r\n                    grappleFric: 0.8,\r\n                };\r\n            }\r\n        },\r\n    }\r\n    \r\n    const enemyTypeMap = {\r\n        normal: (params) => {\r\n            const bounds = {\r\n                x: params.bound.x * 2,\r\n                y: params.bound.y * 2,\r\n                w: params.bound.w * 2,\r\n                h: params.bound.h * 2\r\n            };\r\n            counter++;\r\n            return `\r\n            var xv${counter} = ${params.xv/30};\r\n            var yv${counter} = ${params.yv/30};\r\n            shared.C(0,[3],[1],{r:${params.radius*2},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n            e.pos.y += yv${counter};\r\n            e.pos.x += xv${counter};\r\n            if ((e.pos.x - e.sat.r) < ${bounds.x} || e.pos.x + e.sat.r > ${bounds.x + bounds.w}) {\r\n                xv${counter} = xv${counter} * -1;\r\n            }\r\n            if ((e.pos.y - e.sat.r) < ${bounds.y} || e.pos.y + e.sat.r > ${bounds.y + bounds.h}) {\r\n                yv${counter} = yv${counter} * -1;\r\n            }\r\n            },});\r\n            `\r\n            // {\r\n            //     "type": "normal",\r\n            //     "angle": 5.874603837535309,\r\n            //     "radius": 16,\r\n            //     "speed": 85,\r\n            //     "x": 6898.622849512051,\r\n            //     "y": 4711.556031428228,\r\n            //     "renderX": 6898.622849512051,\r\n            //     "renderY": 4711.556031428228,\r\n            //     "xv": 78.00325384310767,\r\n            //     "yv": 33.77117691001763,\r\n            //     "bound": {\r\n            //         "x": 6400,\r\n            //         "y": 4250,\r\n            //         "w": 600,\r\n            //         "h": 700\r\n            //     },\r\n            //     "isLava": false,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        square: (params) => {\r\n            const bounds = {\r\n                x: params.bound.x * 2,\r\n                y: params.bound.y * 2,\r\n                w: params.bound.w * 2,\r\n                h: params.bound.h * 2\r\n            };\r\n            const size = params.size;\r\n            counter++;\r\n            return `\r\n            var xv${counter} = ${params.xv/42};\r\n            var yv${counter} = ${params.yv/42};\r\n            shared.C(1,[3],[1],{w:${size},h:${size},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n            e.pos.y += yv${counter};\r\n            e.pos.x += xv${counter};\r\n            if ((e.pos.x) < ${bounds.x} || e.pos.x + ${size} > ${bounds.x + bounds.w}) {\r\n                xv${counter} = xv${counter} * -1;\r\n            }\r\n            if ((e.pos.y) < ${bounds.y} || e.pos.y + ${size} > ${bounds.y + bounds.h}) {\r\n                yv${counter} = yv${counter} * -1;\r\n            }\r\n            },});\r\n            `\r\n            // {\r\n            //     "type": "normal",\r\n            //     "angle": 5.874603837535309,\r\n            //     "radius": 16,\r\n            //     "speed": 85,\r\n            //     "x": 6898.622849512051,\r\n            //     "y": 4711.556031428228,\r\n            //     "renderX": 6898.622849512051,\r\n            //     "renderY": 4711.556031428228,\r\n            //     "xv": 78.00325384310767,\r\n            //     "yv": 33.77117691001763,\r\n            //     "bound": {\r\n            //         "x": 6400,\r\n            //         "y": 4250,\r\n            //         "w": 600,\r\n            //         "h": 700\r\n            //     },\r\n            //     "isLava": false,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        turret: (params) => {\r\n            // {\r\n            //     "type": "turret",\r\n            //     "angle": 3.6232766945442836,\r\n            //     "shootSpeed": 3.58,\r\n            //     "timer": 2.2316666666694256,\r\n            //     "pRadius": 32,\r\n            //     "pSpeed": 120,\r\n            //     "projectiles": [\r\n            //         {\r\n            //             "x": 4291,\r\n            //             "y": 3450,\r\n            //             "angle": 0\r\n            //         },\r\n            //         {\r\n            //             "x": 3862,\r\n            //             "y": 3450,\r\n            //             "angle": 0\r\n            //         }\r\n            //     ],\r\n            //     "shootDirections": [\r\n            //         0\r\n            //     ],\r\n            //     "csd": 0,\r\n            //     "deadProjectiles": [],\r\n            //     "radius": 32,\r\n            //     "speed": 0,\r\n            //     "x": 3700,\r\n            //     "y": 3450,\r\n            //     "renderX": 3700,\r\n            //     "renderY": 3450,\r\n            //     "xv": 0,\r\n            //     "yv": 0,\r\n            //     "bound": {\r\n            //         "x": 3650,\r\n            //         "y": 3400,\r\n            //         "w": 850,\r\n            //         "h": 100\r\n            //     },\r\n            //     "inView": true\r\n            // },\r\n            const bounds = {\r\n                x: params.bound.x * 2,\r\n                y: params.bound.y * 2,\r\n                w: params.bound.w * 2,\r\n                h: params.bound.h * 2\r\n            };\r\n            counter++;\r\n            const shootSpeed = params.shootSpeed * 1000 / 15;\r\n            const projectileParams = {\r\n                speed: params.pSpeed / 42,\r\n                radius: params.pRadius * 2,\r\n                shootDirections: params.shootDirections,\r\n            }\r\n            const c = counter;\r\n            return `\r\n            var xv${c} = ${params.xv/42};\r\n            var yv${c} = ${params.yv/42};\r\n            var shootDirectionIndex${c} = 0;\r\n            var timer${c} = ${shootSpeed};\r\n            shared.C(0,[3],[1],{r:${params.radius},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n            e.pos.y += yv${c};\r\n            e.pos.x += xv${c};\r\n            if ((e.pos.x - e.sat.r) < ${bounds.x} || e.pos.x + e.sat.r > ${bounds.x + bounds.w}) {\r\n                xv${c} = xv${c} * -1;\r\n            }\r\n            if ((e.pos.y - e.sat.r) < ${bounds.y} || e.pos.y + e.sat.r > ${bounds.y + bounds.h}) {\r\n                yv${c} = yv${c} * -1;\r\n            }\r\n    \r\n            timer${c}--;\r\n            if(timer${c} < 0){\r\n                timer${c} = ${shootSpeed};\r\n    \r\n                shootDirectionIndex${c}++;\r\n                const shootDirections = [${projectileParams.shootDirections.toString()}];\r\n                if(shootDirectionIndex${c} >= shootDirections.length){\r\n                    shootDirectionIndex${c} = 0;\r\n                }\r\n                let dir = shootDirections[shootDirectionIndex${c}];\r\n    \r\n                counter++;\r\n                /*scoped using let*/\r\n                let xv${counter} = Math.cos(dir) * ${projectileParams.speed};\r\n                let yv${counter} = Math.sin(dir) * ${projectileParams.speed};\r\n                shared.C(0,[3],[1],{r:${projectileParams.radius},y:e.pos.y,x:e.pos.x,sf:(e)=>{\r\n                e.pos.y += yv${counter};\r\n                e.pos.x += xv${counter};\r\n                /*delete obstacle*/\r\n                if ((e.pos.x - e.sat.r) < ${bounds.x} || e.pos.x + e.sat.r > ${bounds.x + bounds.w} || (e.pos.y - e.sat.r) < ${bounds.y} || e.pos.y + e.sat.r > ${bounds.y + bounds.h}) {\r\n                    shared.tickFns.push(()=>{\r\n                        for(let i = 0; i < obstacles.length; i++){\r\n                            if(obstacles[i] === e) {obstacles.splice(i,1); break;}\r\n                        }\r\n                        /*for(let key in shared.idToObs){\r\n                            if(shared.idToObs[key] === e){delete shared.idToObs[key]; break;}\r\n                        }*/\r\n                    });\r\n                }\r\n                },});\r\n            }\r\n    \r\n            },});\r\n            `\r\n        },\r\n        switch: (params) => {\r\n            // {\r\n            //     "type": "switch",\r\n            //     "angle": 0.6586898029125109,\r\n            //     "switchTime": 3.2,\r\n            //     "switchTimer": 2.3083333333306277,\r\n            //     "currentSwitch": true,\r\n            //     "radius": 25,\r\n            //     "speed": 22,\r\n            //     "x": 2557.5655869230604,\r\n            //     "y": 4628.602260600484,\r\n            //     "renderX": 2557.5655869230604,\r\n            //     "renderY": 4628.602260600484,\r\n            //     "xv": -17.397486856740482,\r\n            //     "yv": 13.465788171122483,\r\n            //     "bound": {\r\n            //         "x": 2400,\r\n            //         "y": 4150,\r\n            //         "w": 350,\r\n            //         "h": 650\r\n            //     },\r\n            //     "inView": false\r\n            // },\r\n            const bounds = {\r\n                x: params.bound.x * 2,\r\n                y: params.bound.y * 2,\r\n                w: params.bound.w * 2,\r\n                h: params.bound.h * 2\r\n            };\r\n            counter++;\r\n            const maxSwitchTime = params.switchTime*1000/16; \r\n            return `\r\n            var xv${counter} = ${params.xv/42*4};\r\n            var yv${counter} = ${params.yv/42*4};\r\n            var switchTime${counter} = ${maxSwitchTime*Math.random()*2};\r\n            var switchState${counter} = true;\r\n            var pos${counter} = {\r\n                x: ${params.x*2}, y: ${params.y*2} \r\n            }\r\n            shared.C(0,[3],[1],{r:${params.radius},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n                pos${counter}.y += yv${counter};\r\n                pos${counter}.x += xv${counter};\r\n                if ((pos${counter}.x - e.sat.r) < ${bounds.x} || pos${counter}.x + e.sat.r > ${bounds.x + bounds.w}) {\r\n                    xv${counter} = xv${counter} * -1;\r\n                }\r\n                if ((pos${counter}.y - e.sat.r) < ${bounds.y} || pos${counter}.y + e.sat.r > ${bounds.y + bounds.h}) {\r\n                    yv${counter} = yv${counter} * -1;\r\n                }\r\n    \r\n                if(switchState${counter} === true){\r\n                    e.pos.x = pos${counter}.x;\r\n                    e.pos.y = pos${counter}.y;\r\n                } else {\r\n                    e.pos.x = -100000;\r\n                }\r\n    \r\n                switchTime${counter}--;\r\n                if(switchTime${counter} <= 0){\r\n                    switchTime${counter} = ${params.switchTimer*1000/15};\r\n                    switchState${counter} = !switchState${counter};\r\n                    if(switchState${counter} === true){\r\n                        /*if we\'re switching on, reset to pos we were on. This wasn\'t how the enemy worked before but it\'s ok*/\r\n                        e.pos.x = pos${counter}.x;\r\n                        e.pos.y = pos${counter}.y;\r\n                    }\r\n                }\r\n            }});\r\n            shared.C(0,[3],[0],{r:${params.radius},y:${params.y*2},x:${params.x*2},sf:(e)=>{\r\n                if(switchState${counter} === true){\r\n                    e.pos.x = -100000;\r\n                } else {\r\n                    e.pos.x = pos${counter}.x;\r\n                    e.pos.y = pos${counter}.y;\r\n                }\r\n            }});\r\n            `\r\n            // {\r\n            //     "type": "normal",\r\n            //     "angle": 5.874603837535309,\r\n            //     "radius": 16,\r\n            //     "speed": 85,\r\n            //     "x": 6898.622849512051,\r\n            //     "y": 4711.556031428228,\r\n            //     "renderX": 6898.622849512051,\r\n            //     "renderY": 4711.556031428228,\r\n            //     "xv": 78.00325384310767,\r\n            //     "yv": 33.77117691001763,\r\n            //     "bound": {\r\n            //         "x": 6400,\r\n            //         "y": 4250,\r\n            //         "w": 600,\r\n            //         "h": 700\r\n            //     },\r\n            //     "isLava": false,\r\n            //     "inView": false\r\n            // },\r\n        },\r\n        flashlight: (params) => {\r\n            if(Math.random() < 0.5) return \'\';\r\n            return enemyTypeMap.turret({\r\n                "type": "turret",\r\n                "angle": params.angle,\r\n                "shootSpeed": 1.54,\r\n                "timer": 0,\r\n                "pRadius": params.radius * (Math.random()*0.8 + 0.2),\r\n                "pSpeed": params.speed * (1.65+Math.random()),\r\n                "projectiles": [],\r\n                "shootDirections": [\r\n                    0, Math.PI / 2, Math.PI, Math.PI * 3/2\r\n                ],\r\n                "csd": 0,\r\n                "deadProjectiles": [],\r\n                "radius": params.radius,\r\n                "speed": params.speed,\r\n                "x": params.x,\r\n                "y": params.y,\r\n                "renderX": params.renderX,\r\n                "renderY": params.renderY,\r\n                "xv": params.xv,\r\n                "yv": params.yv,\r\n                "bound": params.bound,\r\n                "inView": false\r\n            },)\r\n        }\r\n    }\r\n\r\n    // -----------------------------------------------------------------------------------------------------------------\r\n\r\n    const alreadyLogged = {};\r\n\r\n    var str = \'\';\r\n\r\n    for(let i = 0; i < obs.length; i++){\r\n        if([\'spawner\',\'square\',\'switch\',\'turret\',\'flashlight\'].includes(obs[i].type) === false) continue;\r\n        const o = obs[i];\r\n\r\n        const spawnData = obs[i].spawnData;\r\n        spawnData.bound = {\r\n            x: obs[i].x, y: obs[i].y, w: obs[i].w, h: obs[i].h\r\n        }\r\n\r\n        for(let i = 0; i < spawnData.amount; i++){\r\n            const s = structuredClone(spawnData);\r\n\r\n            s.x = o.x + Math.random() * o.w;\r\n            s.y = o.y + Math.random() * o.h;\r\n            s.angle = Math.random() * Math.PI * 2;\r\n            s.xv = Math.cos(s.angle) * s.speed;\r\n            s.yv = Math.sin(s.angle) * s.speed;\r\n\r\n            enemies.push(s);\r\n            console.log(s);\r\n        }\r\n    }\r\n\r\n    let alreadyLoggedEnemy = {};\r\n    for(let i = 0; i < enemies.length; i++){\r\n        if(enemyTypeMap[enemies[i].type] !== undefined){\r\n            str += \'\\n\' + enemyTypeMap[enemies[i].type](enemies[i]);\r\n        } else if(alreadyLoggedEnemy[enemies[i].type] === undefined){\r\n            alreadyLoggedEnemy[enemies[i].type] = true;\r\n            console.log(`no enemy type def for ${enemies[i].type}`);\r\n        }\r\n    }\r\n\r\n    for(let i = 0; i < obs.length; i++){\r\n        const o = obs[i];\r\n        const typeDef = typeMap[o.type];\r\n\r\n        if(o.type === \'spawner\') continue;\r\n        if(o.type === \'roundedcorners\' || o.type === \'roundedlava\'){\r\n            const circleType = o.type === \'roundedcorners\' ? \'circle-normal\' : \'circle-lava\';\r\n            for(let i = 0; i < o.circles.length; i++){\r\n                obs.push({\r\n                    x: o.circles[i].x,\r\n                    y: o.circles[i].y,\r\n                    radius: o.circles[i].radius,\r\n                    "renderType": "circle",\r\n                    "inView": false,\r\n                    type: circleType\r\n                })\r\n            }\r\n            const rectType = o.type === \'roundedcorners\' ? \'normal\' : \'lava\';\r\n            for(let i = 0; i < o.rects.length; i++){\r\n                obs.push({\r\n                    x: o.rects[i].x,\r\n                    y: o.rects[i].y,\r\n                    w: o.rects[i].w,\r\n                    h: o.rects[i].h,\r\n                    type: rectType\r\n                })\r\n            }\r\n            continue;\r\n        } else if(o.type === \'color\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            const minX = o.x - 100;\r\n            const minY = o.y - 100;\r\n            const maxX = o.x + o.w + 100;\r\n            const maxY = o.y + o.h + 100;\r\n            str += `var minX${counter}, minY${counter}, maxX${counter}, maxY${counter};\r\n            minX${counter} = ${minX};minY${counter} = ${minY};maxX${counter} = ${maxX};maxY${counter} = ${maxY};\r\n            shared.C(1,[3],[0],{h:1,w:1,y:0,x:-10000,sf:(e)=>{\r\n                const player = shared.players[shared.selfId];\r\n                if ((player.pos.x) > md(minX${counter}) && (player.pos.x) < md(maxX${counter}) && (player.pos.y) > md(minY${counter}) && (player.pos.y) < md(maxY${counter})) {\r\n                    colors.background="${o.tileColor}"; colors.tile="${o.bgColor}";\r\n                }\r\n            },});\\n`;\r\n            counter++;\r\n        } else if(o.type === \'switchlava\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            str += `var timer${counter} = ${o.timer}; var state${counter} =${o.state}; var x${counter} = ${o.x}; \r\n            shared.C(1,[],[1],{h:${o.h},w:${o.w},y:${o.y},x:${o.x},sf:(e)=>{\r\n                    timer${counter} -= 1/60;\r\n                    if(timer${counter} < 0){\r\n                        state${counter} = !state${counter};\r\n                        if(state${counter} === true){\r\n                            // on\r\n                            timer${counter} += ${o.onTime};\r\n                            e.pos.x = x${counter};\r\n                        } else {\r\n                            // off\r\n                            timer${counter} += ${o.offTime};\r\n                            e.pos.x = -1E9;\r\n                        }\r\n                    }\r\n                },\r\n                cr:(e)=>{\r\n                    ctx.beginPath();\r\n                    \r\n                    if (state${counter}) {\r\n                        if (timer${counter} < 0.2 && ${o.onTime} > 0.2) {\r\n                            ctx.globalAlpha = timer${counter} / 0.2;\r\n                        }\r\n                    } else {\r\n                        ctx.globalAlpha = 0.3;\r\n                        if (timer${counter} < 0.2 && ${o.offTime} > 0.2) {\r\n                            ctx.globalAlpha = 0.9 * (1 - timer${counter} / 0.2) + 0.1;\r\n                        }\r\n                    }\r\n                    ctx.fillStyle = ${o.collidable} ? \'#c70000\' : \'#9e0000\';\r\n                    /*if (obstacle.collidable) {\r\n                        ctx.fillStyle = \'#c70000\';\r\n                    }*/ \r\n\r\n                    ctx.lineWidth = 4;\r\n                    ctx.strokeStyle = \'black\';\r\n                    ctx.rect(x${counter}, e.pos.y, e.dimensions.x, e.dimensions.y);\r\n                    ctx.fill();\r\n                    ctx.stroke();\r\n                    ctx.closePath();\r\n                    ctx.globalAlpha = 1;\r\n                }\r\n            });\\n`;\r\n            counter++;\r\n        } else if(o.type === \'block\' || o.type === \'trans\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            str += `shared.C(1,[],[20],{h:${o.h},w:${o.w},y:${o.y},x:${o.x},\r\n                cr:(e)=>{\r\n                    ctx.beginPath();\r\n                    ctx.lineWidth = 2;\r\n                    ctx.strokeStyle = ctx.fillStyle = ${o.type === \'trans\' ? "colors.background" : "\'" + (o.hex ?? o.color) + "\'"};\r\n                    ctx.globalAlpha = ${o.opaq ?? 1};\r\n                    ctx.rect(e.pos.x, e.pos.y, e.dimensions.x, e.dimensions.y);\r\n                    ctx.fill();\r\n                    ctx.stroke();\r\n                    ctx.closePath();\r\n                    ctx.globalAlpha = 1;\r\n                }\r\n            });\\n`;\r\n            counter++;\r\n            continue;\r\n        } else if(o.type === \'grapplepoint\' || o.type === \'movinggrapplepoint\'){\r\n            o.x *= 2; o.y *= 2;\r\n            if(o.type === \'grapplepoint\'){\r\n                str += `shared.C(0,[],[0],{r:20+12/2,y:${o.y},x:${o.x},\r\n                    cr:(e)=>{\r\n                        e.isGrapplePoint = true;\r\n                        ctx.strokeStyle = \'#c9c9c9\';\r\n                        ctx.lineWidth = 12;\r\n                        ctx.globalAlpha = 0.5;\r\n                        ctx.beginPath();\r\n                        ctx.arc(e.pos.x, e.pos.y, 20, 0, Math.PI * 2);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        ctx.globalAlpha = 1;\r\n                    }\r\n                });\\n`;\r\n            } else {\r\n                const params = o;\r\n                const p = {path: \'[\'};\r\n                for(let i = 0; i < params.points.length; i++){\r\n                    p.path += `[${params.points[i][0]*2},[${params.points[i][1]*2}],${params.speed * 2 / 1000}],`;\r\n                }\r\n\r\n                p.currentPoint = params.currentPoint;\r\n                p.x = params.points[0][0] * 2;\r\n                p.y = params.points[0][1] * 2;\r\n\r\n                p.path = p.path.substring(0, p.path.length-1);\r\n                p.path += \']\';\r\n                str += `shared.C(0,[0],[0],{r:20+12/2,\r\n                    cr:(e)=>{\r\n                        e.isGrapplePoint = true;\r\n                        ctx.strokeStyle = \'#c9c9c9\';\r\n                        ctx.lineWidth = 12;\r\n                        ctx.globalAlpha = 0.5;\r\n                        ctx.beginPath();\r\n                        ctx.arc(e.pos.x, e.pos.y, 20, 0, Math.PI * 2);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        ctx.globalAlpha = 1;\r\n                    },currentPoint:${p.currentPoint},x:${p.x},y:${p.y},path:${p.path}\r\n                });\\n`;\r\n            }\r\n            counter++;\r\n            continue;\r\n        } else if(o.type === \'circle-sentry\'){\r\n            o.x *= 2; o.y *= 2; o.r *= 2;\r\n            o.laser.x *= 2; o.laser.y *= 2; o.laser.w *= 2; o.laser.h *= 2;\r\n            str += `shared.C(1,[5],[1],{h:${o.laser.h},w:${o.laser.w},y:${o.y-o.laser.h/2},x:${o.x-o.laser.w/2},\r\n                boundPlayer: true,\r\n                restAngles: [${o.rest*Math.PI/180}, ${o.rest*Math.PI/180+Math.PI}],\r\n                toRest: true,\r\n                homingRotateSpeed: ${o.speed / 86000},\r\n                detectionRadius: ${Math.sqrt(o.laser.w**2+o.laser.h**2)/2},\r\n                spokeAngles: [0, Math.PI],\r\n                pivotX: ${o.x},\r\n                pivotY: ${o.y}\r\n            });\r\n            shared.C(0,[],[0],{x:${o.x},y:${o.y},r:${o.r},cr:(e)=>{\r\n                ctx.fillStyle = shared.colors.tile;\r\n                ctx.beginPath();\r\n                ctx.arc(e.pos.x, e.pos.y, e.sat.r, 0, Math.PI * 2);\r\n                ctx.fill();\r\n                ctx.closePath();\r\n\r\n                ctx.strokeStyle = \'red\';\r\n                ctx.lineWidth = 15;\r\n                ctx.beginPath();\r\n                ctx.arc(\r\n                    e.pos.x,\r\n                    e.pos.y,\r\n                    Math.max(e.sat.r - 30, 0),\r\n                    0,\r\n                    Math.PI * 2\r\n                );\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            }});`\r\n            counter++;\r\n            continue;\r\n        } else if(o.type === \'resetcoins\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            str += `shared.C(1,[],[20],{x:${o.x},y:${o.y},w:${o.w},h:${o.h},hex:\'#000000\',alpha:0,cr:()=>{},ef:()=>{\r\n                for(let i = 0; i < obstacles.length; i++){\r\n                    if(obstacles[i].collected !== undefined){\r\n                        obstacles[i].collected = false;\r\n                    } else if(obstacles[i].isCoindoor === true){\r\n                        obstacles[i].coins = obstacles[i].maxCoins; \r\n                    }\r\n                }    \r\n            }});`;\r\n            continue;\r\n        } else if(o.type === \'resettimetraps\'){\r\n            o.x *= 2; o.y *= 2; o.w *= 2; o.h *= 2;\r\n            str += `shared.C(1,[],[20],{x:${o.x},y:${o.y},w:${o.w},h:${o.h},hex:\'#000000\',alpha:0,cr:()=>{},ef:()=>{\r\n                for(let i = 0; i < obstacles.length; i++){\r\n                    if(obstacles[i].timeTrapTime !== undefined){\r\n                        obstacles[i].timeTrapTime = obstacles[i].timeTrapMaxTime;\r\n                    }\r\n                }    \r\n            }});`;\r\n            continue;\r\n        }\r\n\r\n        if(typeDef === undefined) {\r\n            if(alreadyLogged[o.type] === undefined){\r\n                alreadyLogged[o.type] = true;\r\n                console.log(\'no type def for \' + o.type);\r\n            }\r\n            \r\n            continue;\r\n        }\r\n\r\n        const params = {type: typeDef.type};\r\n\r\n        for(let key in o){\r\n            if(key === \'type\') continue;\r\n            if(typeDef[key] !== undefined) {\r\n                params[typeDef[key]] = o[key];// o.r instead of o.radius set to o[key] \r\n            } else {\r\n                params[key] = o[key];\r\n            }\r\n        }\r\n\r\n        params.x *= 2;\r\n        params.y *= 2;\r\n        if(params.w) params.w *= 2;\r\n        if(params.h) params.h *= 2;\r\n        if(params.r !== undefined) params.r *= 2;\r\n\r\n        if(typeDef.customMap !== undefined){\r\n            const moreParams = typeDef.customMap(o);\r\n            for(let key in moreParams){\r\n                params[key] = moreParams[key];\r\n            }\r\n        }\r\n        \r\n        let paramString = `{`;\r\n        for(let key in params){\r\n            paramString += `${key}:${JSON.stringify(params[key])},`;\r\n        }\r\n        paramString += \'}\';\r\n\r\n        let typeString = JSON.stringify(params.type);\r\n        typeString = typeString.slice(1, typeString.length-1);\r\n\r\n        //shared.C(1,[],[0],{h:100,w:1100,y:4300,x:4600,});\r\n        str += `shared.C(${typeString},${paramString})\\n`;\r\n    }\r\n\r\n    eval(str);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (importMap);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29tbmlzZXJ2ZXIvLi9lWGNsaWVudC9leHRyYXMvaW1wb3J0TWFwLmpzP2UxZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNoYXJlZCBmcm9tICcuLi8uLi9zaGFyZWQvc2hhcmVkLmpzJztcclxuZnVuY3Rpb24gaW1wb3J0TWFwKHN0cil7XHJcbiAgICBvYnN0YWNsZXMubGVuZ3RoID0gMDtcclxuXHJcbiAgICBjb25zdCBvID0gSlNPTi5wYXJzZShzdHIpO1xyXG5cclxuICAgIGxldCB7YXJlbmEsIHNhZmVzLCBzcGF3bnMsIHBsYXllclNwYXduLCB0aWxlQ29sb3IsIGJnQ29sb3IsIHRleHRzfSA9IG87XHJcblxyXG4gICAgLy8gYXJlbmEud2lkdGgsIGFyZW5hLmhlaWdodFxyXG5cclxuICAgIG1hcERpbWVuc2lvbnMueD1hcmVuYS53aWR0aCAqIDI7XHJcbiAgICBtYXBEaW1lbnNpb25zLnk9YXJlbmEuaGVpZ2h0ICogMjtcclxuXHJcbiAgICBzcGF3blBvc2l0aW9uLng9cGxheWVyU3Bhd24ueCoyO1xyXG4gICAgc3Bhd25Qb3NpdGlvbi55PXBsYXllclNwYXduLnkqMjtcclxuICAgIHNoYXJlZC5yZXNwYXduUGxheWVyKCk7XHJcbiAgICBjb2xvcnMuYmFja2dyb3VuZD10aWxlQ29sb3I7IGNvbG9ycy50aWxlPWJnQ29sb3I7XHJcblxyXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xyXG5cclxuICAgIGxldCBvYnMgPSBvLm9ic3RhY2xlcztcclxuICAgIGxldCBlbmVtaWVzID0gby5lbmVteTtcclxuXHJcbiAgICBzYWZlcyA9IHNhZmVzLm1hcChwID0+IHtcclxuICAgICAgICBwLnR5cGUgPSBcInNhZmVcIjtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH0pO1xyXG5cclxuICAgIHRleHRzID0gdGV4dHMubWFwKHAgPT4ge1xyXG4gICAgICAgIHAudHlwZSA9IFwidGV4dFwiO1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBjb25zdCB0eXBlTWFwID0ge1xyXG4gICAgICAgICdub3JtYWwnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFswXV0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyAndHJhbnMnOiB7XHJcbiAgICAgICAgLy8gICAgIHR5cGU6IFsxLFtdLFsyMF1dLFxyXG4gICAgICAgIC8vICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVybiB7aGV4OiAnIzAwMDAwMCcsIGFscGhhOiBwYXJhbXMub3BhcX07XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9LFxyXG4gICAgICAgIC8vICdibG9jayc6IHtcclxuICAgICAgICAvLyAgICAgdHlwZTogWzEsW10sWzIwXV0sXHJcbiAgICAgICAgLy8gICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIHtoZXg6IHBhcmFtcy5jb2xvciwgYWxwaGE6IDF9O1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAnZ3Jhdic6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzEzXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYocGFyYW1zLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5jb252ZXlvckFuZ2xlID0gMFxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHBhcmFtcy5kaXJlY3Rpb24gPT09ICdkb3duJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5jb252ZXlvckFuZ2xlID0gOTA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYocGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2xlZnQnKXtcclxuICAgICAgICAgICAgICAgICAgICBwLmNvbnZleW9yQW5nbGUgPSAxODA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAuY29udmV5b3JBbmdsZSA9IDI3MDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAuY29udmV5b3JGcmljdGlvbiA9IDAuODtcclxuICAgICAgICAgICAgICAgIHAuY29udmV5b3JBbmdsZVJvdGF0ZVNwZWVkID0gMDtcclxuICAgICAgICAgICAgICAgIHAuY29udmV5b3JGb3JjZSA9IHBhcmFtcy5mb3JjZSAvIDEwMDAwICogNy4wOCAqIDUgLyAxNi42NjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY2lyY2xlLW5vcm1hbCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzBdXSxcclxuICAgICAgICAgICAgcmFkaXVzOiAncicgLy8gdGhpcyBtZWFucyBtYXAgcmFkaXVzIHRvIHJcclxuICAgICAgICAgICAgLy8gYWxsIG90aGVyIHBhcmFtcyBmaWxsZWQgaW4gMToxLCBzbyB4IHdpbGwgYmUgZmlsbGVkIGluIGZyb20geCwgeSBmcm9tIHksIGV0Yy5cclxuICAgICAgICB9LFxyXG4gICAgICAgICdjaXJjbGUtbGF2YSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzFdXSxcclxuICAgICAgICAgICAgcmFkaXVzOiAncicsXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZFBsYXllcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NpcmNsZS10cCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzEyXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB0cHg6IHBhcmFtcy50cHggKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRweTogcGFyYW1zLnRweSAqIDJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2xhdmEnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsxXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZFBsYXllcjogcGFyYW1zLmNhbkNvbGxpZGVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdwb2x5Jzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMixbXSxbMF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cG9pbnRzOiBbXX07XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFyYW1zLnBvaW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wb2ludHMucHVzaChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wb2ludHNbaV1bMF0qMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVsxXSoyXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAncG9seS10cCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzIsW10sWzEyXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwb2ludHM6IFtdfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjJcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcC50cHggPSBwYXJhbXMudHB4ICogMjtcclxuICAgICAgICAgICAgICAgIHAudHB5ID0gcGFyYW1zLnRweSAqIDI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3BvbHktc2FmZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzIsW10sWzExXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwb2ludHM6IFtdfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjJcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdwb2x5LXZpbmV0dGUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsyLFtdLFsyNF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cG9pbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclI6IHBhcmFtcy52Yy5yLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRzogcGFyYW1zLnZjLmcsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJCOiBwYXJhbXMudmMuYixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclNpemU6IHBhcmFtcy5pcixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlclI6IHBhcmFtcy52Yy5yLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyRzogcGFyYW1zLnZjLmcsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJCOiBwYXJhbXMudmMuYixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlclNpemU6IHBhcmFtcy5vcixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lck9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJPcGFjaXR5OiBwYXJhbXMub1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjJcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdwb2x5LWxhdmEnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsyLFtdLFsxXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwb2ludHM6IFtdfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBvaW50cy5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjJcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcC5ib3VuZFBsYXllciA9IHRydWU7Ly9wYXJhbXMuY2FuQ29sbGlkZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnbW92ZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzBdLFswXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHtwYXRoOiBbXX07XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFyYW1zLnBvaW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wYXRoLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzBdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wb2ludHNbaV1bMV0qMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNwZWVkICogMiAvIDEwMDBcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBwLmN1cnJlbnRQb2ludCA9IHBhcmFtcy5jdXJyZW50UG9pbnQ7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHAucGF0aFtwLmN1cnJlbnRQb2ludF07XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvaW50SW5kZXggPSBwLmN1cnJlbnRQb2ludCsxO1xyXG4gICAgICAgICAgICAgICAgaWYobmV4dFBvaW50SW5kZXggPT09IHAucGF0aC5sZW5ndGgpIG5leHRQb2ludEluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQb2ludCA9IHAucGF0aFtuZXh0UG9pbnRJbmRleF07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsRGlzdCA9IE1hdGguc3FydCgobmV4dFBvaW50WzBdLWN1cnJlbnRQb2ludFswXSkqKjIrKG5leHRQb2ludFsxXS1jdXJyZW50UG9pbnRbMV0pKioyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uQ292ZXJlZCA9IE1hdGguc3FydCgocGFyYW1zLngqMi1jdXJyZW50UG9pbnRbMF0pKioyKyhwYXJhbXMueSoyLWN1cnJlbnRQb2ludFsxXSkqKjIpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBwLmN1cnJlbnRQb2ludCArPSBmcmFjdGlvbkNvdmVyZWQgLyB0b3RhbERpc3Q7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHAueCA9IHAucGF0aFswXVswXTtcclxuICAgICAgICAgICAgICAgIHAueSA9IHAucGF0aFswXVsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnbGF2YW1vdmUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFswXSxbMV1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogW119O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcmFtcy5wb2ludHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGF0aC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zcGVlZCAqIDIgLyAxMDAwXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgPSBwYXJhbXMuY3VycmVudFBvaW50O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBwLnBhdGhbcC5jdXJyZW50UG9pbnRdO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb2ludEluZGV4ID0gcC5jdXJyZW50UG9pbnQrMTtcclxuICAgICAgICAgICAgICAgIGlmKG5leHRQb2ludEluZGV4ID09PSBwLnBhdGgubGVuZ3RoKSBuZXh0UG9pbnRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9pbnQgPSBwLnBhdGhbbmV4dFBvaW50SW5kZXhdO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbERpc3QgPSBNYXRoLnNxcnQoKG5leHRQb2ludFswXS1jdXJyZW50UG9pbnRbMF0pKioyKyhuZXh0UG9pbnRbMV0tY3VycmVudFBvaW50WzFdKSoqMik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFjdGlvbkNvdmVyZWQgPSBNYXRoLnNxcnQoKHBhcmFtcy54KjItY3VycmVudFBvaW50WzBdKSoqMisocGFyYW1zLnkqMi1jdXJyZW50UG9pbnRbMV0pKioyKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgKz0gZnJhY3Rpb25Db3ZlcmVkIC8gdG90YWxEaXN0O1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBwLnggPSBwLnBhdGhbMF1bMF07XHJcbiAgICAgICAgICAgICAgICBwLnkgPSBwLnBhdGhbMF1bMV07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHAuYm91bmRQbGF5ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmKHBhcmFtcy5jb2xsaWRhYmxlKSBwLmJvdW5kUGxheWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAndG9ybmFkbyc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzIzXV0sXHJcbiAgICAgICAgICAgIHNwaW5SYWRpdXM6ICd0b3JuYWRvU3RyZW5ndGgnIFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3ZpbmV0dGUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsyNF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTaXplOiBwYXJhbXMuaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJTaXplOiBwYXJhbXMub3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyT3BhY2l0eTogcGFyYW1zLm9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3RwbW92ZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzBdLFsxMl1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogW119O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcmFtcy5wb2ludHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGF0aC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zcGVlZCAqIDIgLyAxMDAwXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgPSBwYXJhbXMuY3VycmVudFBvaW50O1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcC5wYXRoWzBdWzBdO1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcC5wYXRoWzBdWzFdO1xyXG4gICAgICAgICAgICAgICAgcC50cHggPSBwYXJhbXMudHB4ICogMjsgcC50cHkgPSBwYXJhbXMudHB5ICogMjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnbW92aW5nc2FmZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzBdLFsxMV1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogW119O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcmFtcy5wb2ludHMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGF0aC5wdXNoKFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnBvaW50c1tpXVswXSoyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzFdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zcGVlZCAqIDIgLyAxMDAwXHJcbiAgICAgICAgICAgICAgICAgICAgXSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAuY3VycmVudFBvaW50ID0gcGFyYW1zLmN1cnJlbnRQb2ludDtcclxuICAgICAgICAgICAgICAgIHAueCA9IHAucGF0aFswXVswXTtcclxuICAgICAgICAgICAgICAgIHAueSA9IHAucGF0aFswXVsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnbW92aW5ndmluZXR0ZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzBdLFsyNF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTaXplOiBwYXJhbXMuaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJTaXplOiBwYXJhbXMub3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyT3BhY2l0eTogcGFyYW1zLm9cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFyYW1zLnBvaW50cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wYXRoLnB1c2goW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucG9pbnRzW2ldWzBdKjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wb2ludHNbaV1bMV0qMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNwZWVkICogMiAvIDEwMDBcclxuICAgICAgICAgICAgICAgICAgICBdKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgPSBwYXJhbXMuY3VycmVudFBvaW50O1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcC5wYXRoWzBdWzBdO1xyXG4gICAgICAgICAgICAgICAgcC55ID0gcC5wYXRoWzBdWzFdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICd0aW1ldHJhcCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzE3XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy9zaGFyZWQuQygxLFtdLFsxN10se2g6MjAwLHc6MzAwLHk6NzAwLHg6MzAwLHRpbWVUcmFwVG9TaG93VGVudGg6dHJ1ZSx0aW1lVHJhcFRvS2lsbDp0cnVlLHRpbWVUcmFwUmVjb3ZlcnlTcGVlZDoxLjUsdGltZVRyYXBNYXhUaW1lOjMwMCx9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7dGltZVRyYXBUb1Nob3dUZW50aDpmYWxzZSx0aW1lVHJhcFRvS2lsbDp0cnVlLHRpbWVUcmFwUmVjb3ZlcnlTcGVlZDpwYXJhbXMuY2RtdWx0fTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcC50aW1lVHJhcE1heFRpbWUgPSBwYXJhbXMubWF4VGltZSAqIDEwMDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ292YWwnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFswLFtdLFswXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtyOiBNYXRoLm1pbihwYXJhbXMucmFkaXVzLCBwYXJhbXMucmFkaXVzMikqMn07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdsYXZhLW92YWwnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFswLFtdLFsxXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtyOiBNYXRoLm1pbihwYXJhbXMucmFkaXVzLCBwYXJhbXMucmFkaXVzMikqMiwgYm91bmRQbGF5ZXI6IHRydWV9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnc2FmZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzExXV0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY2lyY2xlLXNhZmUnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFswLFtdLFsxMV1dLFxyXG4gICAgICAgICAgICByOiAncidcclxuICAgICAgICB9LFxyXG4gICAgICAgICdjaXJjbGUtdmluZXR0ZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzAsW10sWzI0XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclI6IHBhcmFtcy52Yy5yLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRzogcGFyYW1zLnZjLmcsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJCOiBwYXJhbXMudmMuYixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclNpemU6IHBhcmFtcy5pcixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlclI6IHBhcmFtcy52Yy5yLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyRzogcGFyYW1zLnZjLmcsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJCOiBwYXJhbXMudmMuYixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlclNpemU6IHBhcmFtcy5vcixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lck9wYWNpdHk6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJPcGFjaXR5OiBwYXJhbXMubyxcclxuICAgICAgICAgICAgICAgICAgICByOiBwYXJhbXMuciA/PyBwYXJhbXMucmFkaXVzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdjaXJjbGUtY29pbic6IHtcclxuICAgICAgICAgICAgcmFkaXVzOiAncicsXHJcbiAgICAgICAgICAgIHR5cGU6IFswLFtdLFs3XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNkNWQ2MTInLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvaW5BbW91bnQ6IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2JvdW5jZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzJdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge2JvdW5jaW5lc3M6IHBhcmFtcy5lZmZlY3QvMy8xMCwgZGVjYXk6IDAuNX07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdyb3RhdGUtbm9ybWFsJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbMV0sWzBdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMueCA9IHBhcmFtcy5kaXN0VG9QaXZvdCArIHBhcmFtcy5waXZvdFg7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMueSA9IHBhcmFtcy5waXZvdFk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHBhcmFtcy54ICogMiAtIHBhcmFtcy53LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcmFtcy55ICogMiAtIHBhcmFtcy5oLFxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxSb3RhdGlvbjogcGFyYW1zLmFuZ2xlICogMTgwIC8gTWF0aC5QSSxcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGVTcGVlZDogcGFyYW1zLnJvdGF0ZVNwZWVkIC8gMzYwIC8gMjIwICogMS4zNixcclxuICAgICAgICAgICAgICAgICAgICBwaXZvdFg6IHBhcmFtcy5waXZvdFggKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHBpdm90WTogcGFyYW1zLnBpdm90WSAqIDJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdyb3RhdGUtbGF2YSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzFdLFsxXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnggPSBwYXJhbXMuZGlzdFRvUGl2b3QgKyBwYXJhbXMucGl2b3RYO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnkgPSBwYXJhbXMucGl2b3RZO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBwYXJhbXMueCAqIDIgLSBwYXJhbXMudyxcclxuICAgICAgICAgICAgICAgICAgICB5OiBwYXJhbXMueSAqIDIgLSBwYXJhbXMuaCxcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsUm90YXRpb246IHBhcmFtcy5hbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGVTcGVlZDogcGFyYW1zLnJvdGF0ZVNwZWVkIC8gMzYwIC8gMjIwICogMS4zNixcclxuICAgICAgICAgICAgICAgICAgICBwaXZvdFg6IHBhcmFtcy5waXZvdFggKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHBpdm90WTogcGFyYW1zLnBpdm90WSAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRQbGF5ZXI6IHBhcmFtcy5jYW5Db2xsaWRlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAncm90YXRpbmdzYWZlJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbMV0sWzExXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocGFyYW1zLmFuZ2xlIC0gbGFzdFJvdEFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIC8vIGxhc3RSb3RBbmdsZSA9IHBhcmFtcy5hbmdsZTtcclxuICAgICAgICAgICAgICAgIC8vIGxhc3RSb3RBbmdsZSArPSBNYXRoLlBJICogMy8yO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyAwOiBwYXJhbXMueSArPSAxLCB4ICs9IDBcclxuICAgICAgICAgICAgICAgIC8vIDkwOiBwYXJhbXMueCAtPSAxLCB5ICs9IDBcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gcGFyYW1zLmFuZ2xlID0gMDtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gY29uc3Qgcm90YXRpb24gPSBwYXJhbXMuYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDg5Ni41OTg0NjU1Mjk2MDQ4LFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwieVwiOiAxNzIwLjg4MTk3MzQ4NjgxODQsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJ3XCI6IDI1LFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwiaFwiOiAyNSxcclxuICAgICAgICAgICAgICAgIC8vICAgICBcInR5cGVcIjogXCJyb3RhdGluZ3NhZmVcIixcclxuICAgICAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IC02NjQ5My41LFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwicm90YXRlU3BlZWRcIjogLTkwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwicGl2b3RYXCI6IDkyNSxcclxuICAgICAgICAgICAgICAgIC8vICAgICBcInBpdm90WVwiOiAxNjI1LFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwiZGlzdFRvUGl2b3RcIjogMTAwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwiY2FuQ29sbGlkZVwiOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwiY3VsbGluZ1JhZGl1c1wiOiAxMTcuNjc3NjY5NTI5NjYzNjksXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJ1blNpbVwiOiAwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAvLyB9LFxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBpbiBlWCwgcG9zaXRpb24gaXMgc2V0IGxpa2UgdGhpc1xyXG4gICAgICAgICAgICAvLyAgICAgb2JqLnggPVxyXG4gICAgICAgICAgICAvLyAgICAgTWF0aC5jb3MoKG9iai5hbmdsZSAqIE1hdGguUEkpIC8gMTgwKSAqXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgb2JqLmRpc3RUb1Bpdm90ICtcclxuICAgICAgICAgICAgLy8gICAgIG9iai5waXZvdFg7XHJcbiAgICAgICAgICAgIC8vIG9iai55ID1cclxuICAgICAgICAgICAgLy8gICAgIE1hdGguc2luKChvYmouYW5nbGUgKiBNYXRoLlBJKSAvIDE4MCkgKlxyXG4gICAgICAgICAgICAvLyAgICAgICAgIG9iai5kaXN0VG9QaXZvdCArXHJcbiAgICAgICAgICAgIC8vICAgICBvYmoucGl2b3RZO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2UgcmVuZGVyIGxpa2UgdGhpc1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBjdHgudHJhbnNsYXRlKGNlbnRlci54LCBjZW50ZXIueSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjdHgucm90YXRlKGRlZ1RvUmFkKG9ic3RhY2xlLmFuZ2xlKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjdHgucmVjdChcclxuICAgICAgICAgICAgICAgIC8vICAgICAtb2JzdGFjbGUudyAvIDIsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgLW9ic3RhY2xlLmggLyAyLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIG9ic3RhY2xlLncsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgb2JzdGFjbGUuaFxyXG4gICAgICAgICAgICAgICAgLy8gKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gc28gb2JqLngsIG9iai55ID0gY2VudGVyWC4gXHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIGxldCBhbmdsZSA9IHBhcmFtcy5hbmdsZTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gbGV0cyB0cnkgc2V0dGluZyBhbmdsZSB0byAwIGFuZCBzZWUgd2hhdCBoYXBwZW5zXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJhbXMuYW5nbGUgPSA0NTtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy54ID0gcGFyYW1zLmRpc3RUb1Bpdm90ICsgcGFyYW1zLnBpdm90WDtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy55ID0gcGFyYW1zLnBpdm90WTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gdGhleSdyZSBpbiBhIHN0cmFpZ2h0IGxpbmUgbGlrZSBvIC0gLS0tXHJcbiAgICBcclxuICAgICAgICAgICAgICAgIC8vIHNvIG5vdywgbGV0cyByb3RhdGUgdGhlIGFuZ2xlIGFyb3VuZCB0aGUgb2JzIGNlbnRlci4gV2Uga25vdyB0aGF0IHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIHNhZmUgaXMgaXRzIGNlbnRlciBzbyBsZXRzIGNhbGN1bGF0ZSBvdXIgb3duIGRpc3RUb1Bpdm90IGZyb20gdGhhdFxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBtaWRkbGVYID0gcGFyYW1zLnggKyBwYXJhbXMudyAvIDI7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBtaWRkbGVZID0gcGFyYW1zLnkgKyBwYXJhbXMuaCAvIDJcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgcmVhbERpc3RUb1Bpdm90ID0gTWF0aC5zcXJ0KChwYXJhbXMueCAtIHBhcmFtcy5waXZvdFgpICoqIDIgKyAocGFyYW1zLnkgLSBwYXJhbXMucGl2b3RZKSAqKiAyKTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gLy8gLy8gbm93IHdlIGhhdmUgdGhhdCwgd2UgY2FuIHNldCB0aGUgeCBhbmQgeVxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvLyAvLyAvLyBwYXJhbXMuYW5nbGUgPSBhbmdsZTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHggPSBNYXRoLmNvcyhwYXJhbXMuYW5nbGUgKiBNYXRoLlBJIC8gMTgwKSAqIGRpc3QgKyBwYXJhbXMucGl2b3RYIC0gcGFyYW1zLncgLyAyO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgeSA9IE1hdGguc2luKHBhcmFtcy5hbmdsZSAqIE1hdGguUEkgLyAxODApICogZGlzdCArIHBhcmFtcy5waXZvdFkgLSBwYXJhbXMuaCAvIDI7XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8geDp4KjIseTp5KjIsaW5pdGlhbFJvdGF0aW9uOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHg6IHBhcmFtcy54ICogMiAtIHBhcmFtcy53LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcmFtcy55ICogMiAtIHBhcmFtcy5oLFxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxSb3RhdGlvbjogcGFyYW1zLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZVNwZWVkOiBwYXJhbXMucm90YXRlU3BlZWQgLyAzNjAgLyAyMjAgKiAxLjM2LFxyXG4gICAgICAgICAgICAgICAgICAgIHBpdm90WDogcGFyYW1zLnBpdm90WCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgcGl2b3RZOiBwYXJhbXMucGl2b3RZICogMlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3JvdGF0aW5ndmluZXR0ZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsWzFdLFsyNF1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy54ID0gcGFyYW1zLmRpc3RUb1Bpdm90ICsgcGFyYW1zLnBpdm90WDtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy55ID0gcGFyYW1zLnBpdm90WTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBwYXJhbXMueCAqIDIgLSBwYXJhbXMudyxcclxuICAgICAgICAgICAgICAgICAgICB5OiBwYXJhbXMueSAqIDIgLSBwYXJhbXMuaCxcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsUm90YXRpb246IHBhcmFtcy5hbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGVTcGVlZDogcGFyYW1zLnJvdGF0ZVNwZWVkIC8gMzYwIC8gMjIwICogMS4zNixcclxuICAgICAgICAgICAgICAgICAgICBwaXZvdFg6IHBhcmFtcy5waXZvdFggKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHBpdm90WTogcGFyYW1zLnBpdm90WSAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJTaXplOiBwYXJhbXMuaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJSOiBwYXJhbXMudmMucixcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckc6IHBhcmFtcy52Yy5nLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyQjogcGFyYW1zLnZjLmIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJTaXplOiBwYXJhbXMub3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJPcGFjaXR5OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyT3BhY2l0eTogcGFyYW1zLm9cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NoZWNrJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbOV1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludE9mZnNldFg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2twb2ludE9mZnNldFk6IDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ3RwJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbMTJdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRweDogcGFyYW1zLnRweCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgdHB5OiBwYXJhbXMudHB5ICogMlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnd2lucGFkJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbNl1dXHJcbiAgICAgICAgfSxcclxuICAgICAgICAnc3BlZWQnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsxOV1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlZWRDaGFuZ2VQZXJtYW5lbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkTXVsdDogcGFyYW1zLnNwZWVkSW5jXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdzaXplJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbMThdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpemVDaGFuZ2VQZXJtYW5lbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemVNdWx0OiBwYXJhbXMuc2l6ZSAvIDI0LjVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3NoYXJlZC5DKDEsW10sWzE4XSx7aDoyMDAsdzozMDAseTo3MDAseDozMDAsc2l6ZUNoYW5nZVBlcm1hbmVudDpmYWxzZSxzaXplTXVsdDoxLjUsfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnc25hcCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzE2XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzbmFwQW5nbGVSb3RhdGVTcGVlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICBzbmFwQW5nbGU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcENvb2xkb3duOiBwYXJhbXMuc25hcFdhaXQsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcERpc3RhbmNlWTogcGFyYW1zLnNuYXBEaXN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICBzbmFwRGlzdGFuY2VYOiBwYXJhbXMuc25hcERpc3RhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvU25hcFg6IHBhcmFtcy5zbmFwWCxcclxuICAgICAgICAgICAgICAgICAgICB0b1NuYXBZOiBwYXJhbXMuc25hcFlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgIC8vICAgICBcInhcIjogMTEwNTAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInlcIjogMTU1MCxcclxuICAgICAgICAgICAgLy8gICAgIFwid1wiOiA5MDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcImhcIjogNTAwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwic25hcFwiLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJzbmFwRGlzdGFuY2VcIjogNTAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNuYXBXYWl0XCI6IDAuNCxcclxuICAgICAgICAgICAgLy8gICAgIFwic25hcFhcIjogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gICAgIFwic25hcFlcIjogdHJ1ZSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY29pbic6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzddXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2Q1ZDYxMicsXHJcbiAgICAgICAgICAgICAgICAgICAgY29pbkFtb3VudDogMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY29pbmRvb3InOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFs4XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2luRG9vckNvbG9yOiAnI2Q1ZDYxMicsXHJcbiAgICAgICAgICAgICAgICAgICAgY29pbmRvb3JDb2luQW1vdW50OiBwYXJhbXMuY29pbnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2J1dHRvbic6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzddXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IDE0OTQxLjQzODEwMDkyNTUyNyxcclxuICAgICAgICAgICAgICAgICAgICBcInlcIjogNTQ5NS44NzAxMjg3OTYzODFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b20gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IDE4NDIwLjE1ODYyMTQwNjM1NyxcclxuICAgICAgICAgICAgICAgICAgICBcInlcIjogODg3My4wODY3MDQ1MjkxN1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBwYXJhbXMueCAqIDI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFyYW1zLnkgKiAyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5zaWRlID0geCA+IHRvcC54ICYmIHggPCBib3R0b20ueCAmJiB5ID4gdG9wLnkgJiYgeSA8IGJvdHRvbS55O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogaW5zaWRlID8gJyMwMEZGMDAnIDogJyNkNmQ2MTInLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvaW5BbW91bnQ6IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2Rvb3InOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFs4XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBwYXJhbXMuaWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29pbkFtb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgb2JzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihvYnNbaV0udHlwZSA9PT0gJ2J1dHRvbicgJiYgb2JzW2ldLmlkID09PSBpZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvaW5BbW91bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IDE0OTQxLjQzODEwMDkyNTUyNyxcclxuICAgICAgICAgICAgICAgICAgICBcInlcIjogNTQ5NS44NzAxMjg3OTYzODFcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b20gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ4XCI6IDE4NDIwLjE1ODYyMTQwNjM1NyxcclxuICAgICAgICAgICAgICAgICAgICBcInlcIjogODg3My4wODY3MDQ1MjkxN1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBwYXJhbXMueCAqIDI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gcGFyYW1zLnkgKiAyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5zaWRlID0geCA+IHRvcC54ICYmIHggPCBib3R0b20ueCAmJiB5ID4gdG9wLnkgJiYgeSA8IGJvdHRvbS55O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2luRG9vckNvbG9yOiBpbnNpZGUgPyAnIzAwRkYwMCcgOiAnI2Q2ZDYxMicsXHJcbiAgICAgICAgICAgICAgICAgICAgY29pbmRvb3JDb2luQW1vdW50OiBpbnNpZGUgPyA1IDogY29pbkFtb3VudFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAncmF4aXMnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsxNV1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpc1NwZWVkTXVsdFk6IHBhcmFtcy5yeSA9PT0gdHJ1ZSA/IDAgOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGF4aXNTcGVlZE11bHRYOiBwYXJhbXMucnggPT09IHRydWUgPyAwIDogMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAncHVzaCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzI1XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoQW5nbGU6IHsncmlnaHQnOiAxODAsICdkb3duJzogMjcwLCAnbGVmdCc6IDAsICdyaWdodCc6IDkwfVtwYXJhbXMuZGlyXSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhQdXNoRGlzdGFuY2U6IHBhcmFtcy5tYXggKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkbGVQdXNoQmFja1NwZWVkOiBwYXJhbXMucHVzaEJhY2sgLyAyMCxcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZURpcmVjdGlvbk9ubHk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaENvbnZlcnNpb25SYXRpbzogMC44NlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwvL3NoYXJlZC5DKDMsW10sWzIwXSx7Zm9udFNpemU6ODAsdGV4dDonSSBhbSBhIHRleHQgOkQnLHk6ODAwLHg6NDUwLGhleDpjb2xvdXJSZ2IoMTAwLDEwMCwxMDApLH0pO1xyXG4gICAgICAgICd0ZXh0Jzoge1xyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgICAgIC8vICAgICBcInhcIjogMzAwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIFwieVwiOiA3NSxcclxuICAgICAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJ0ZXh0XCI6IFwiV2VsY29tZSB0byB0aGVcIixcclxuICAgICAgICAgICAgICAgIC8vICAgICBcInNpemVcIjogMzAsXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgXCJzdG9yeVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIC8vICAgICBcImVsZW1lbnRcIjoge1xyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBcInRXaWR0aFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBcInRIZWlnaHRcIjogMFxyXG4gICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgICAgICAgICBpZihwYXJhbXMuYW5nbGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBbMyxbMV0sWzIwXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBwYXJhbXMuc2l6ZSAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcmFtcy50ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZXg6ICcjRkZGRkZGJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGl2b3RYOiBwYXJhbXMueCAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpdm90WTogcGFyYW1zLnkgKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVTcGVlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFJvdGF0aW9uOiBwYXJhbXMuYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS8vXCJzaGFyZWQuQygzLFsxXSxbMjBdLHtmb250U2l6ZTo4MCx0ZXh0OidJIGFtIGEgdGV4dCA6RCcseTo4MDAseDo0NTAscGl2b3RZOjgwMCxwaXZvdFg6NDUwLHJvdGF0ZVNwZWVkOjAsaW5pdGlhbFJvdGF0aW9uOjQ1LGhleDpjb2xvdXJSZ2IoMTAwLDEwMCwxMDApLH0pO1wiXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBbMyxbXSxbMjBdXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IHBhcmFtcy5zaXplICogMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcGFyYW1zLnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleDogJyNGRkZGRkYnXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAncGxhdGZvcm1lcic6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzE0XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYocGFyYW1zLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wbGF0Zm9ybWVyQW5nbGUgPSAwXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYocGFyYW1zLmRpcmVjdGlvbiA9PT0gJ2Rvd24nKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBsYXRmb3JtZXJBbmdsZSA9IDkwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHBhcmFtcy5kaXJlY3Rpb24gPT09ICdsZWZ0Jyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5wbGF0Zm9ybWVyQW5nbGUgPSAxODA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHAucGxhdGZvcm1lckFuZ2xlID0gMjcwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcC5wbGF0Zm9ybWVyRnJpY3Rpb24gPSAwLjk7XHJcbiAgICAgICAgICAgICAgICBwLnBsYXRmb3JtZXJBbmdsZVJvdGF0ZVNwZWVkID0gMDtcclxuICAgICAgICAgICAgICAgIHAucGxhdGZvcm1lckZvcmNlID0gcGFyYW1zLmZvcmNlIC8gMTAwMDAgKiAxLjUgKiAxLjggKiAxLjYgKiAxMCAvIDE2LjY2O1xyXG4gICAgICAgICAgICAgICAgcC5qdW1wRm9yY2UgPSBwYXJhbXMuanVtcEhlaWdodCAvIDEwIC8gOC4yICogMi4zMiAvIDEuMiAvIDI7XHJcbiAgICAgICAgICAgICAgICBwLmp1bXBEZWNheSA9IDAuOTUyNTtcclxuICAgICAgICAgICAgICAgIHAubWF4SnVtcENvb2xkb3duID0gMjAgKiAxNi42O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDY2MDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInlcIjogMzAwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ3XCI6IDUwMCxcclxuICAgICAgICAgICAgLy8gICAgIFwiaFwiOiAzNTAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInR5cGVcIjogXCJwbGF0Zm9ybWVyXCIsXHJcbiAgICAgICAgICAgIC8vICAgICBcImZvcmNlXCI6IDE1MDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcImRpclwiOiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJ4XCI6IDAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJ5XCI6IDE1MDBcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICBcImRpcmVjdGlvblwiOiBcImRvd25cIixcclxuICAgICAgICAgICAgLy8gICAgIFwianVtcEhlaWdodFwiOiAxNDUsXHJcbiAgICAgICAgICAgIC8vICAgICBcIm1heEZvcmNlXCI6IDEwMDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInZhcmlhYmxlSnVtcEhlaWdodFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gICAgIFwicGxhdGZvcm1lckZyaWN0aW9uXCI6IDAuOCxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICAnYnJlYWthYmxlJzoge1xyXG4gICAgICAgICAgICB0eXBlOiBbMSxbXSxbMTBdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFN0cmVuZ3RoOiBNYXRoLm1heCgyMDAscGFyYW1zLm1heFN0cmVuZ3RoICogTWF0aC5tYXgoMSxwYXJhbXMudGltZXIgKiAxMDAwIC8gNjApKSxcclxuICAgICAgICAgICAgICAgICAgICByZWdlblRpbWU6IHBhcmFtcy5yZWdlblRpbWUgKiAxMDAwIC8gMTUsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhbFNwZWVkOiAxXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIHNoYXJlZC5DKDEsW10sWzEwXSx7aDoyMDAsdzozMDAseTo3MDAseDozMDAsaGVhbFNwZWVkOjEscmVnZW5UaW1lOjEwMCxtYXhTdHJlbmd0aDo2MCx9KTtcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIFwieFwiOiAyOTUwLFxyXG4gICAgICAgIC8vICAgICBcInlcIjogMjY1MCxcclxuICAgICAgICAvLyAgICAgXCJ3XCI6IDIwMCxcclxuICAgICAgICAvLyAgICAgXCJoXCI6IDUwLFxyXG4gICAgICAgIC8vICAgICBcInR5cGVcIjogXCJicmVha2FibGVcIixcclxuICAgICAgICAvLyAgICAgXCJtYXhTdHJlbmd0aFwiOiA0MCxcclxuICAgICAgICAvLyAgICAgXCJjdXJyZW50U3RyZW5ndGhcIjogNDAsXHJcbiAgICAgICAgLy8gICAgIFwidGltZVwiOiAwLFxyXG4gICAgICAgIC8vICAgICBcInRpbWVyXCI6IDAsXHJcbiAgICAgICAgLy8gICAgIFwicmVnZW5UaW1lXCI6IDMsXHJcbiAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICBcclxuICAgIFxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgXCJ4XCI6IDg1NTAsXHJcbiAgICAgICAgLy8gICAgIFwieVwiOiA5NTAwLFxyXG4gICAgICAgIC8vICAgICBcInJhZGl1c1wiOiAzMDAsXHJcbiAgICAgICAgLy8gICAgIFwidHlwZVwiOiBcImNpcmNsZS1ob2xsb3ctc2xpY2VcIixcclxuICAgICAgICAvLyAgICAgXCJzdGFydEFuZ2xlXCI6IDEuNTcwNzk2MzI2Nzk0ODk2NixcclxuICAgICAgICAvLyAgICAgXCJlbmRBbmdsZVwiOiAtMS41NzA3OTYzMjY3OTQ4OTY2LFxyXG4gICAgICAgIC8vICAgICBcInN0YXJ0UG9seWdvblwiOiB7XHJcbiAgICAgICAgLy8gICAgICAgICBcInBvaW50c1wiOiBbXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgW1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICA4NTUwLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICA5NjUwXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgXSxcclxuICAgICAgICAvLyAgICAgICAgICAgICBbXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIDg1NTAsXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIDk4MDBcclxuICAgICAgICAvLyAgICAgICAgICAgICBdXHJcbiAgICAgICAgLy8gICAgICAgICBdLFxyXG4gICAgICAgIC8vICAgICAgICAgXCJ0eXBlXCI6IFwicG9seVwiLFxyXG4gICAgICAgIC8vICAgICAgICAgXCJwcm9wc1wiOiB7fVxyXG4gICAgICAgIC8vICAgICB9LFxyXG4gICAgICAgIC8vICAgICBcImVuZFBvbHlnb25cIjoge1xyXG4gICAgICAgIC8vICAgICAgICAgXCJwb2ludHNcIjogW1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIFtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgODU1MCxcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgOTM1MFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgW1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICA4NTUwLFxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICA5MjAwXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgXVxyXG4gICAgICAgIC8vICAgICAgICAgXSxcclxuICAgICAgICAvLyAgICAgICAgIFwidHlwZVwiOiBcInBvbHlcIixcclxuICAgICAgICAvLyAgICAgICAgIFwicHJvcHNcIjoge31cclxuICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAvLyAgICAgXCJpbm5lclJhZGl1c1wiOiAxNTAsXHJcbiAgICAgICAgLy8gICAgIFwidG9Sb3RhdGVcIjogZmFsc2UsXHJcbiAgICAgICAgLy8gICAgIFwicm90YXRlU3BlZWRcIjogMCxcclxuICAgICAgICAvLyAgICAgXCJyZW5kZXJUeXBlXCI6IFwiY2lyY2xlXCIsXHJcbiAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgLy8gfSxcclxuICAgICAgICAnY2lyY2xlLWhvbGxvdy1zbGljZSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzQsW10sWzBdXSxcclxuICAgICAgICAgICAgY3VzdG9tTWFwOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHI6IHBhcmFtcy5yYWRpdXMgKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubmVyUmFkaXVzOiBwYXJhbXMuaW5uZXJSYWRpdXMgKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U2xpY2VBbmdsZTogcGFyYW1zLnN0YXJ0QW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kU2xpY2VBbmdsZTogcGFyYW1zLmVuZEFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0U2xpY2VBbmdsZVJvdGF0ZVNwZWVkOiBwYXJhbXMucm90YXRlU3BlZWQgLyAyMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFNsaWNlQW5nbGVSb3RhdGVTcGVlZDogcGFyYW1zLnJvdGF0ZVNwZWVkIC8gMjAwMFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgIFxyXG4gICAgICAgICdjaXJjbGUtc2xpY2UnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFs0LFtdLFswXV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByOiBwYXJhbXMucmFkaXVzICogMixcclxuICAgICAgICAgICAgICAgICAgICBpbm5lclJhZGl1czogMCxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFNsaWNlQW5nbGU6IHBhcmFtcy5zdGFydEFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFNsaWNlQW5nbGU6IHBhcmFtcy5lbmRBbmdsZSxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFNsaWNlQW5nbGVSb3RhdGVTcGVlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICBlbmRTbGljZUFuZ2xlUm90YXRlU3BlZWQ6IDBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICBcclxuICAgICAgICAnc2hpcCc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzI3XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VTaGlwU3RhdGVUbzogcGFyYW1zLnN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxTaGlwQW5nbGU6IC1NYXRoLlBJIC8gMixcclxuICAgICAgICAgICAgICAgICAgICBzaGlwVHVyblNwZWVkOiBNYXRoLlBJIC8gMjAgLyAxNi42NiAvIDJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICBcclxuICAgICAgICAnbXVzaWNjaGFuZ2UnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFsxLFtdLFsyNl1dLFxyXG4gICAgICAgICAgICBjdXN0b21NYXA6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogcGFyYW1zLnggKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhcmFtcy55ICogMixcclxuICAgICAgICAgICAgICAgICAgICB3OiBwYXJhbXMudyAqIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgaDogcGFyYW1zLmggKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIG11c2ljUGF0aDogcGFyYW1zLm11c2ljUGF0aFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICBcclxuICAgICAgICAnZ3JwdSc6IHtcclxuICAgICAgICAgICAgdHlwZTogWzEsW10sWzI4XV0sXHJcbiAgICAgICAgICAgIGN1c3RvbU1hcDogKHBhcmFtcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VHcmFwcGxlU3RhdGVUbzogcGFyYW1zLnN0YXRlLCAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBncmFwcGxlUmFuZ2U6IDQ4OCxcclxuICAgICAgICAgICAgICAgICAgICBncmFwcGxlRm9yY2U6IDAuMDYsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcHBsZUZyaWM6IDAuOCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBlbmVteVR5cGVNYXAgPSB7XHJcbiAgICAgICAgbm9ybWFsOiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgICAgIHg6IHBhcmFtcy5ib3VuZC54ICogMixcclxuICAgICAgICAgICAgICAgIHk6IHBhcmFtcy5ib3VuZC55ICogMixcclxuICAgICAgICAgICAgICAgIHc6IHBhcmFtcy5ib3VuZC53ICogMixcclxuICAgICAgICAgICAgICAgIGg6IHBhcmFtcy5ib3VuZC5oICogMlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgICAgIHJldHVybiBgXHJcbiAgICAgICAgICAgIHZhciB4diR7Y291bnRlcn0gPSAke3BhcmFtcy54di8zMH07XHJcbiAgICAgICAgICAgIHZhciB5diR7Y291bnRlcn0gPSAke3BhcmFtcy55di8zMH07XHJcbiAgICAgICAgICAgIHNoYXJlZC5DKDAsWzNdLFsxXSx7cjoke3BhcmFtcy5yYWRpdXMqMn0seToke3BhcmFtcy55KjJ9LHg6JHtwYXJhbXMueCoyfSxzZjooZSk9PntcclxuICAgICAgICAgICAgZS5wb3MueSArPSB5diR7Y291bnRlcn07XHJcbiAgICAgICAgICAgIGUucG9zLnggKz0geHYke2NvdW50ZXJ9O1xyXG4gICAgICAgICAgICBpZiAoKGUucG9zLnggLSBlLnNhdC5yKSA8ICR7Ym91bmRzLnh9IHx8IGUucG9zLnggKyBlLnNhdC5yID4gJHtib3VuZHMueCArIGJvdW5kcy53fSkge1xyXG4gICAgICAgICAgICAgICAgeHYke2NvdW50ZXJ9ID0geHYke2NvdW50ZXJ9ICogLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChlLnBvcy55IC0gZS5zYXQucikgPCAke2JvdW5kcy55fSB8fCBlLnBvcy55ICsgZS5zYXQuciA+ICR7Ym91bmRzLnkgKyBib3VuZHMuaH0pIHtcclxuICAgICAgICAgICAgICAgIHl2JHtjb3VudGVyfSA9IHl2JHtjb3VudGVyfSAqIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sfSk7XHJcbiAgICAgICAgICAgIGBcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwibm9ybWFsXCIsXHJcbiAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDUuODc0NjAzODM3NTM1MzA5LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyYWRpdXNcIjogMTYsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNwZWVkXCI6IDg1LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDY4OTguNjIyODQ5NTEyMDUxLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ5XCI6IDQ3MTEuNTU2MDMxNDI4MjI4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJYXCI6IDY4OTguNjIyODQ5NTEyMDUxLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJZXCI6IDQ3MTEuNTU2MDMxNDI4MjI4LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4dlwiOiA3OC4wMDMyNTM4NDMxMDc2NyxcclxuICAgICAgICAgICAgLy8gICAgIFwieXZcIjogMzMuNzcxMTc2OTEwMDE3NjMsXHJcbiAgICAgICAgICAgIC8vICAgICBcImJvdW5kXCI6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInhcIjogNjQwMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInlcIjogNDI1MCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcIndcIjogNjAwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwiaFwiOiA3MDBcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICBcImlzTGF2YVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcXVhcmU6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYm91bmRzID0ge1xyXG4gICAgICAgICAgICAgICAgeDogcGFyYW1zLmJvdW5kLnggKiAyLFxyXG4gICAgICAgICAgICAgICAgeTogcGFyYW1zLmJvdW5kLnkgKiAyLFxyXG4gICAgICAgICAgICAgICAgdzogcGFyYW1zLmJvdW5kLncgKiAyLFxyXG4gICAgICAgICAgICAgICAgaDogcGFyYW1zLmJvdW5kLmggKiAyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJhbXMuc2l6ZTtcclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICByZXR1cm4gYFxyXG4gICAgICAgICAgICB2YXIgeHYke2NvdW50ZXJ9ID0gJHtwYXJhbXMueHYvNDJ9O1xyXG4gICAgICAgICAgICB2YXIgeXYke2NvdW50ZXJ9ID0gJHtwYXJhbXMueXYvNDJ9O1xyXG4gICAgICAgICAgICBzaGFyZWQuQygxLFszXSxbMV0se3c6JHtzaXplfSxoOiR7c2l6ZX0seToke3BhcmFtcy55KjJ9LHg6JHtwYXJhbXMueCoyfSxzZjooZSk9PntcclxuICAgICAgICAgICAgZS5wb3MueSArPSB5diR7Y291bnRlcn07XHJcbiAgICAgICAgICAgIGUucG9zLnggKz0geHYke2NvdW50ZXJ9O1xyXG4gICAgICAgICAgICBpZiAoKGUucG9zLngpIDwgJHtib3VuZHMueH0gfHwgZS5wb3MueCArICR7c2l6ZX0gPiAke2JvdW5kcy54ICsgYm91bmRzLnd9KSB7XHJcbiAgICAgICAgICAgICAgICB4diR7Y291bnRlcn0gPSB4diR7Y291bnRlcn0gKiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGUucG9zLnkpIDwgJHtib3VuZHMueX0gfHwgZS5wb3MueSArICR7c2l6ZX0gPiAke2JvdW5kcy55ICsgYm91bmRzLmh9KSB7XHJcbiAgICAgICAgICAgICAgICB5diR7Y291bnRlcn0gPSB5diR7Y291bnRlcn0gKiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LH0pO1xyXG4gICAgICAgICAgICBgXHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gICAgIFwidHlwZVwiOiBcIm5vcm1hbFwiLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJhbmdsZVwiOiA1Ljg3NDYwMzgzNzUzNTMwOSxcclxuICAgICAgICAgICAgLy8gICAgIFwicmFkaXVzXCI6IDE2LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJzcGVlZFwiOiA4NSxcclxuICAgICAgICAgICAgLy8gICAgIFwieFwiOiA2ODk4LjYyMjg0OTUxMjA1MSxcclxuICAgICAgICAgICAgLy8gICAgIFwieVwiOiA0NzExLjU1NjAzMTQyODIyOCxcclxuICAgICAgICAgICAgLy8gICAgIFwicmVuZGVyWFwiOiA2ODk4LjYyMjg0OTUxMjA1MSxcclxuICAgICAgICAgICAgLy8gICAgIFwicmVuZGVyWVwiOiA0NzExLjU1NjAzMTQyODIyOCxcclxuICAgICAgICAgICAgLy8gICAgIFwieHZcIjogNzguMDAzMjUzODQzMTA3NjcsXHJcbiAgICAgICAgICAgIC8vICAgICBcInl2XCI6IDMzLjc3MTE3NjkxMDAxNzYzLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJib3VuZFwiOiB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJ4XCI6IDY0MDAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJ5XCI6IDQyNTAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJ3XCI6IDYwMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcImhcIjogNzAwXHJcbiAgICAgICAgICAgIC8vICAgICB9LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJpc0xhdmFcIjogZmFsc2UsXHJcbiAgICAgICAgICAgIC8vICAgICBcImluVmlld1wiOiBmYWxzZVxyXG4gICAgICAgICAgICAvLyB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHVycmV0OiAocGFyYW1zKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gICAgIFwidHlwZVwiOiBcInR1cnJldFwiLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJhbmdsZVwiOiAzLjYyMzI3NjY5NDU0NDI4MzYsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNob290U3BlZWRcIjogMy41OCxcclxuICAgICAgICAgICAgLy8gICAgIFwidGltZXJcIjogMi4yMzE2NjY2NjY2Njk0MjU2LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJwUmFkaXVzXCI6IDMyLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJwU3BlZWRcIjogMTIwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJwcm9qZWN0aWxlc1wiOiBbXHJcbiAgICAgICAgICAgIC8vICAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBcInhcIjogNDI5MSxcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgXCJ5XCI6IDM0NTAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIFwiYW5nbGVcIjogMFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICAgICAge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICBcInhcIjogMzg2MixcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgXCJ5XCI6IDM0NTAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIFwiYW5nbGVcIjogMFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gICAgIF0sXHJcbiAgICAgICAgICAgIC8vICAgICBcInNob290RGlyZWN0aW9uc1wiOiBbXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgMFxyXG4gICAgICAgICAgICAvLyAgICAgXSxcclxuICAgICAgICAgICAgLy8gICAgIFwiY3NkXCI6IDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcImRlYWRQcm9qZWN0aWxlc1wiOiBbXSxcclxuICAgICAgICAgICAgLy8gICAgIFwicmFkaXVzXCI6IDMyLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJzcGVlZFwiOiAwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDM3MDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInlcIjogMzQ1MCxcclxuICAgICAgICAgICAgLy8gICAgIFwicmVuZGVyWFwiOiAzNzAwLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyZW5kZXJZXCI6IDM0NTAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInh2XCI6IDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcInl2XCI6IDAsXHJcbiAgICAgICAgICAgIC8vICAgICBcImJvdW5kXCI6IHtcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInhcIjogMzY1MCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcInlcIjogMzQwMCxcclxuICAgICAgICAgICAgLy8gICAgICAgICBcIndcIjogODUwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwiaFwiOiAxMDBcclxuICAgICAgICAgICAgLy8gICAgIH0sXHJcbiAgICAgICAgICAgIC8vICAgICBcImluVmlld1wiOiB0cnVlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgICAgIHg6IHBhcmFtcy5ib3VuZC54ICogMixcclxuICAgICAgICAgICAgICAgIHk6IHBhcmFtcy5ib3VuZC55ICogMixcclxuICAgICAgICAgICAgICAgIHc6IHBhcmFtcy5ib3VuZC53ICogMixcclxuICAgICAgICAgICAgICAgIGg6IHBhcmFtcy5ib3VuZC5oICogMlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob290U3BlZWQgPSBwYXJhbXMuc2hvb3RTcGVlZCAqIDEwMDAgLyAxNTtcclxuICAgICAgICAgICAgY29uc3QgcHJvamVjdGlsZVBhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHNwZWVkOiBwYXJhbXMucFNwZWVkIC8gNDIsXHJcbiAgICAgICAgICAgICAgICByYWRpdXM6IHBhcmFtcy5wUmFkaXVzICogMixcclxuICAgICAgICAgICAgICAgIHNob290RGlyZWN0aW9uczogcGFyYW1zLnNob290RGlyZWN0aW9ucyxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjID0gY291bnRlcjtcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgdmFyIHh2JHtjfSA9ICR7cGFyYW1zLnh2LzQyfTtcclxuICAgICAgICAgICAgdmFyIHl2JHtjfSA9ICR7cGFyYW1zLnl2LzQyfTtcclxuICAgICAgICAgICAgdmFyIHNob290RGlyZWN0aW9uSW5kZXgke2N9ID0gMDtcclxuICAgICAgICAgICAgdmFyIHRpbWVyJHtjfSA9ICR7c2hvb3RTcGVlZH07XHJcbiAgICAgICAgICAgIHNoYXJlZC5DKDAsWzNdLFsxXSx7cjoke3BhcmFtcy5yYWRpdXN9LHk6JHtwYXJhbXMueSoyfSx4OiR7cGFyYW1zLngqMn0sc2Y6KGUpPT57XHJcbiAgICAgICAgICAgIGUucG9zLnkgKz0geXYke2N9O1xyXG4gICAgICAgICAgICBlLnBvcy54ICs9IHh2JHtjfTtcclxuICAgICAgICAgICAgaWYgKChlLnBvcy54IC0gZS5zYXQucikgPCAke2JvdW5kcy54fSB8fCBlLnBvcy54ICsgZS5zYXQuciA+ICR7Ym91bmRzLnggKyBib3VuZHMud30pIHtcclxuICAgICAgICAgICAgICAgIHh2JHtjfSA9IHh2JHtjfSAqIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoZS5wb3MueSAtIGUuc2F0LnIpIDwgJHtib3VuZHMueX0gfHwgZS5wb3MueSArIGUuc2F0LnIgPiAke2JvdW5kcy55ICsgYm91bmRzLmh9KSB7XHJcbiAgICAgICAgICAgICAgICB5diR7Y30gPSB5diR7Y30gKiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIHRpbWVyJHtjfS0tO1xyXG4gICAgICAgICAgICBpZih0aW1lciR7Y30gPCAwKXtcclxuICAgICAgICAgICAgICAgIHRpbWVyJHtjfSA9ICR7c2hvb3RTcGVlZH07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHNob290RGlyZWN0aW9uSW5kZXgke2N9Kys7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaG9vdERpcmVjdGlvbnMgPSBbJHtwcm9qZWN0aWxlUGFyYW1zLnNob290RGlyZWN0aW9ucy50b1N0cmluZygpfV07XHJcbiAgICAgICAgICAgICAgICBpZihzaG9vdERpcmVjdGlvbkluZGV4JHtjfSA+PSBzaG9vdERpcmVjdGlvbnMubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICBzaG9vdERpcmVjdGlvbkluZGV4JHtjfSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgZGlyID0gc2hvb3REaXJlY3Rpb25zW3Nob290RGlyZWN0aW9uSW5kZXgke2N9XTtcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICAgICAgLypzY29wZWQgdXNpbmcgbGV0Ki9cclxuICAgICAgICAgICAgICAgIGxldCB4diR7Y291bnRlcn0gPSBNYXRoLmNvcyhkaXIpICogJHtwcm9qZWN0aWxlUGFyYW1zLnNwZWVkfTtcclxuICAgICAgICAgICAgICAgIGxldCB5diR7Y291bnRlcn0gPSBNYXRoLnNpbihkaXIpICogJHtwcm9qZWN0aWxlUGFyYW1zLnNwZWVkfTtcclxuICAgICAgICAgICAgICAgIHNoYXJlZC5DKDAsWzNdLFsxXSx7cjoke3Byb2plY3RpbGVQYXJhbXMucmFkaXVzfSx5OmUucG9zLnkseDplLnBvcy54LHNmOihlKT0+e1xyXG4gICAgICAgICAgICAgICAgZS5wb3MueSArPSB5diR7Y291bnRlcn07XHJcbiAgICAgICAgICAgICAgICBlLnBvcy54ICs9IHh2JHtjb3VudGVyfTtcclxuICAgICAgICAgICAgICAgIC8qZGVsZXRlIG9ic3RhY2xlKi9cclxuICAgICAgICAgICAgICAgIGlmICgoZS5wb3MueCAtIGUuc2F0LnIpIDwgJHtib3VuZHMueH0gfHwgZS5wb3MueCArIGUuc2F0LnIgPiAke2JvdW5kcy54ICsgYm91bmRzLnd9IHx8IChlLnBvcy55IC0gZS5zYXQucikgPCAke2JvdW5kcy55fSB8fCBlLnBvcy55ICsgZS5zYXQuciA+ICR7Ym91bmRzLnkgKyBib3VuZHMuaH0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFyZWQudGlja0Zucy5wdXNoKCgpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBvYnN0YWNsZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JzdGFjbGVzW2ldID09PSBlKSB7b2JzdGFjbGVzLnNwbGljZShpLDEpOyBicmVhazt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypmb3IobGV0IGtleSBpbiBzaGFyZWQuaWRUb09icyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzaGFyZWQuaWRUb09ic1trZXldID09PSBlKXtkZWxldGUgc2hhcmVkLmlkVG9PYnNba2V5XTsgYnJlYWs7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9Ki9cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICB9LH0pO1xyXG4gICAgICAgICAgICBgXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzd2l0Y2g6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgXCJ0eXBlXCI6IFwic3dpdGNoXCIsXHJcbiAgICAgICAgICAgIC8vICAgICBcImFuZ2xlXCI6IDAuNjU4Njg5ODAyOTEyNTEwOSxcclxuICAgICAgICAgICAgLy8gICAgIFwic3dpdGNoVGltZVwiOiAzLjIsXHJcbiAgICAgICAgICAgIC8vICAgICBcInN3aXRjaFRpbWVyXCI6IDIuMzA4MzMzMzMzMzMwNjI3NyxcclxuICAgICAgICAgICAgLy8gICAgIFwiY3VycmVudFN3aXRjaFwiOiB0cnVlLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJyYWRpdXNcIjogMjUsXHJcbiAgICAgICAgICAgIC8vICAgICBcInNwZWVkXCI6IDIyLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ4XCI6IDI1NTcuNTY1NTg2OTIzMDYwNCxcclxuICAgICAgICAgICAgLy8gICAgIFwieVwiOiA0NjI4LjYwMjI2MDYwMDQ4NCxcclxuICAgICAgICAgICAgLy8gICAgIFwicmVuZGVyWFwiOiAyNTU3LjU2NTU4NjkyMzA2MDQsXHJcbiAgICAgICAgICAgIC8vICAgICBcInJlbmRlcllcIjogNDYyOC42MDIyNjA2MDA0ODQsXHJcbiAgICAgICAgICAgIC8vICAgICBcInh2XCI6IC0xNy4zOTc0ODY4NTY3NDA0ODIsXHJcbiAgICAgICAgICAgIC8vICAgICBcInl2XCI6IDEzLjQ2NTc4ODE3MTEyMjQ4MyxcclxuICAgICAgICAgICAgLy8gICAgIFwiYm91bmRcIjoge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwieFwiOiAyNDAwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwieVwiOiA0MTUwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwid1wiOiAzNTAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJoXCI6IDY1MFxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaW5WaWV3XCI6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIH0sXHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IHtcclxuICAgICAgICAgICAgICAgIHg6IHBhcmFtcy5ib3VuZC54ICogMixcclxuICAgICAgICAgICAgICAgIHk6IHBhcmFtcy5ib3VuZC55ICogMixcclxuICAgICAgICAgICAgICAgIHc6IHBhcmFtcy5ib3VuZC53ICogMixcclxuICAgICAgICAgICAgICAgIGg6IHBhcmFtcy5ib3VuZC5oICogMlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heFN3aXRjaFRpbWUgPSBwYXJhbXMuc3dpdGNoVGltZSoxMDAwLzE2OyBcclxuICAgICAgICAgICAgcmV0dXJuIGBcclxuICAgICAgICAgICAgdmFyIHh2JHtjb3VudGVyfSA9ICR7cGFyYW1zLnh2LzQyKjR9O1xyXG4gICAgICAgICAgICB2YXIgeXYke2NvdW50ZXJ9ID0gJHtwYXJhbXMueXYvNDIqNH07XHJcbiAgICAgICAgICAgIHZhciBzd2l0Y2hUaW1lJHtjb3VudGVyfSA9ICR7bWF4U3dpdGNoVGltZSpNYXRoLnJhbmRvbSgpKjJ9O1xyXG4gICAgICAgICAgICB2YXIgc3dpdGNoU3RhdGUke2NvdW50ZXJ9ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHBvcyR7Y291bnRlcn0gPSB7XHJcbiAgICAgICAgICAgICAgICB4OiAke3BhcmFtcy54KjJ9LCB5OiAke3BhcmFtcy55KjJ9IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNoYXJlZC5DKDAsWzNdLFsxXSx7cjoke3BhcmFtcy5yYWRpdXN9LHk6JHtwYXJhbXMueSoyfSx4OiR7cGFyYW1zLngqMn0sc2Y6KGUpPT57XHJcbiAgICAgICAgICAgICAgICBwb3Mke2NvdW50ZXJ9LnkgKz0geXYke2NvdW50ZXJ9O1xyXG4gICAgICAgICAgICAgICAgcG9zJHtjb3VudGVyfS54ICs9IHh2JHtjb3VudGVyfTtcclxuICAgICAgICAgICAgICAgIGlmICgocG9zJHtjb3VudGVyfS54IC0gZS5zYXQucikgPCAke2JvdW5kcy54fSB8fCBwb3Mke2NvdW50ZXJ9LnggKyBlLnNhdC5yID4gJHtib3VuZHMueCArIGJvdW5kcy53fSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHh2JHtjb3VudGVyfSA9IHh2JHtjb3VudGVyfSAqIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwb3Mke2NvdW50ZXJ9LnkgLSBlLnNhdC5yKSA8ICR7Ym91bmRzLnl9IHx8IHBvcyR7Y291bnRlcn0ueSArIGUuc2F0LnIgPiAke2JvdW5kcy55ICsgYm91bmRzLmh9KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeXYke2NvdW50ZXJ9ID0geXYke2NvdW50ZXJ9ICogLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgICAgIGlmKHN3aXRjaFN0YXRlJHtjb3VudGVyfSA9PT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wb3MueCA9IHBvcyR7Y291bnRlcn0ueDtcclxuICAgICAgICAgICAgICAgICAgICBlLnBvcy55ID0gcG9zJHtjb3VudGVyfS55O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnBvcy54ID0gLTEwMDAwMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICAgICAgc3dpdGNoVGltZSR7Y291bnRlcn0tLTtcclxuICAgICAgICAgICAgICAgIGlmKHN3aXRjaFRpbWUke2NvdW50ZXJ9IDw9IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFRpbWUke2NvdW50ZXJ9ID0gJHtwYXJhbXMuc3dpdGNoVGltZXIqMTAwMC8xNX07XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoU3RhdGUke2NvdW50ZXJ9ID0gIXN3aXRjaFN0YXRlJHtjb3VudGVyfTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzd2l0Y2hTdGF0ZSR7Y291bnRlcn0gPT09IHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKmlmIHdlJ3JlIHN3aXRjaGluZyBvbiwgcmVzZXQgdG8gcG9zIHdlIHdlcmUgb24uIFRoaXMgd2Fzbid0IGhvdyB0aGUgZW5lbXkgd29ya2VkIGJlZm9yZSBidXQgaXQncyBvayovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucG9zLnggPSBwb3Mke2NvdW50ZXJ9Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucG9zLnkgPSBwb3Mke2NvdW50ZXJ9Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9fSk7XHJcbiAgICAgICAgICAgIHNoYXJlZC5DKDAsWzNdLFswXSx7cjoke3BhcmFtcy5yYWRpdXN9LHk6JHtwYXJhbXMueSoyfSx4OiR7cGFyYW1zLngqMn0sc2Y6KGUpPT57XHJcbiAgICAgICAgICAgICAgICBpZihzd2l0Y2hTdGF0ZSR7Y291bnRlcn0gPT09IHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGUucG9zLnggPSAtMTAwMDAwO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnBvcy54ID0gcG9zJHtjb3VudGVyfS54O1xyXG4gICAgICAgICAgICAgICAgICAgIGUucG9zLnkgPSBwb3Mke2NvdW50ZXJ9Lnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH19KTtcclxuICAgICAgICAgICAgYFxyXG4gICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgIC8vICAgICBcInR5cGVcIjogXCJub3JtYWxcIixcclxuICAgICAgICAgICAgLy8gICAgIFwiYW5nbGVcIjogNS44NzQ2MDM4Mzc1MzUzMDksXHJcbiAgICAgICAgICAgIC8vICAgICBcInJhZGl1c1wiOiAxNixcclxuICAgICAgICAgICAgLy8gICAgIFwic3BlZWRcIjogODUsXHJcbiAgICAgICAgICAgIC8vICAgICBcInhcIjogNjg5OC42MjI4NDk1MTIwNTEsXHJcbiAgICAgICAgICAgIC8vICAgICBcInlcIjogNDcxMS41NTYwMzE0MjgyMjgsXHJcbiAgICAgICAgICAgIC8vICAgICBcInJlbmRlclhcIjogNjg5OC42MjI4NDk1MTIwNTEsXHJcbiAgICAgICAgICAgIC8vICAgICBcInJlbmRlcllcIjogNDcxMS41NTYwMzE0MjgyMjgsXHJcbiAgICAgICAgICAgIC8vICAgICBcInh2XCI6IDc4LjAwMzI1Mzg0MzEwNzY3LFxyXG4gICAgICAgICAgICAvLyAgICAgXCJ5dlwiOiAzMy43NzExNzY5MTAwMTc2MyxcclxuICAgICAgICAgICAgLy8gICAgIFwiYm91bmRcIjoge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwieFwiOiA2NDAwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwieVwiOiA0MjUwLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgIFwid1wiOiA2MDAsXHJcbiAgICAgICAgICAgIC8vICAgICAgICAgXCJoXCI6IDcwMFxyXG4gICAgICAgICAgICAvLyAgICAgfSxcclxuICAgICAgICAgICAgLy8gICAgIFwiaXNMYXZhXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAvLyAgICAgXCJpblZpZXdcIjogZmFsc2VcclxuICAgICAgICAgICAgLy8gfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZsYXNobGlnaHQ6IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgaWYoTWF0aC5yYW5kb20oKSA8IDAuNSkgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICByZXR1cm4gZW5lbXlUeXBlTWFwLnR1cnJldCh7XHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0dXJyZXRcIixcclxuICAgICAgICAgICAgICAgIFwiYW5nbGVcIjogcGFyYW1zLmFuZ2xlLFxyXG4gICAgICAgICAgICAgICAgXCJzaG9vdFNwZWVkXCI6IDEuNTQsXHJcbiAgICAgICAgICAgICAgICBcInRpbWVyXCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcInBSYWRpdXNcIjogcGFyYW1zLnJhZGl1cyAqIChNYXRoLnJhbmRvbSgpKjAuOCArIDAuMiksXHJcbiAgICAgICAgICAgICAgICBcInBTcGVlZFwiOiBwYXJhbXMuc3BlZWQgKiAoMS42NStNYXRoLnJhbmRvbSgpKSxcclxuICAgICAgICAgICAgICAgIFwicHJvamVjdGlsZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcInNob290RGlyZWN0aW9uc1wiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgMCwgTWF0aC5QSSAvIDIsIE1hdGguUEksIE1hdGguUEkgKiAzLzJcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImNzZFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJkZWFkUHJvamVjdGlsZXNcIjogW10sXHJcbiAgICAgICAgICAgICAgICBcInJhZGl1c1wiOiBwYXJhbXMucmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgXCJzcGVlZFwiOiBwYXJhbXMuc3BlZWQsXHJcbiAgICAgICAgICAgICAgICBcInhcIjogcGFyYW1zLngsXHJcbiAgICAgICAgICAgICAgICBcInlcIjogcGFyYW1zLnksXHJcbiAgICAgICAgICAgICAgICBcInJlbmRlclhcIjogcGFyYW1zLnJlbmRlclgsXHJcbiAgICAgICAgICAgICAgICBcInJlbmRlcllcIjogcGFyYW1zLnJlbmRlclksXHJcbiAgICAgICAgICAgICAgICBcInh2XCI6IHBhcmFtcy54dixcclxuICAgICAgICAgICAgICAgIFwieXZcIjogcGFyYW1zLnl2LFxyXG4gICAgICAgICAgICAgICAgXCJib3VuZFwiOiBwYXJhbXMuYm91bmQsXHJcbiAgICAgICAgICAgICAgICBcImluVmlld1wiOiBmYWxzZVxyXG4gICAgICAgICAgICB9LClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICBjb25zdCBhbHJlYWR5TG9nZ2VkID0ge307XHJcblxyXG4gICAgdmFyIHN0ciA9ICcnO1xyXG5cclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBvYnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGlmKFsnc3Bhd25lcicsJ3NxdWFyZScsJ3N3aXRjaCcsJ3R1cnJldCcsJ2ZsYXNobGlnaHQnXS5pbmNsdWRlcyhvYnNbaV0udHlwZSkgPT09IGZhbHNlKSBjb250aW51ZTtcclxuICAgICAgICBjb25zdCBvID0gb2JzW2ldO1xyXG5cclxuICAgICAgICBjb25zdCBzcGF3bkRhdGEgPSBvYnNbaV0uc3Bhd25EYXRhO1xyXG4gICAgICAgIHNwYXduRGF0YS5ib3VuZCA9IHtcclxuICAgICAgICAgICAgeDogb2JzW2ldLngsIHk6IG9ic1tpXS55LCB3OiBvYnNbaV0udywgaDogb2JzW2ldLmhcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzcGF3bkRhdGEuYW1vdW50OyBpKyspe1xyXG4gICAgICAgICAgICBjb25zdCBzID0gc3RydWN0dXJlZENsb25lKHNwYXduRGF0YSk7XHJcblxyXG4gICAgICAgICAgICBzLnggPSBvLnggKyBNYXRoLnJhbmRvbSgpICogby53O1xyXG4gICAgICAgICAgICBzLnkgPSBvLnkgKyBNYXRoLnJhbmRvbSgpICogby5oO1xyXG4gICAgICAgICAgICBzLmFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICBzLnh2ID0gTWF0aC5jb3Mocy5hbmdsZSkgKiBzLnNwZWVkO1xyXG4gICAgICAgICAgICBzLnl2ID0gTWF0aC5zaW4ocy5hbmdsZSkgKiBzLnNwZWVkO1xyXG5cclxuICAgICAgICAgICAgZW5lbWllcy5wdXNoKHMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFscmVhZHlMb2dnZWRFbmVteSA9IHt9O1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGVuZW1pZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGlmKGVuZW15VHlwZU1hcFtlbmVtaWVzW2ldLnR5cGVdICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBzdHIgKz0gJ1xcbicgKyBlbmVteVR5cGVNYXBbZW5lbWllc1tpXS50eXBlXShlbmVtaWVzW2ldKTtcclxuICAgICAgICB9IGVsc2UgaWYoYWxyZWFkeUxvZ2dlZEVuZW15W2VuZW1pZXNbaV0udHlwZV0gPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGFscmVhZHlMb2dnZWRFbmVteVtlbmVtaWVzW2ldLnR5cGVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYG5vIGVuZW15IHR5cGUgZGVmIGZvciAke2VuZW1pZXNbaV0udHlwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IG9icy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgY29uc3QgbyA9IG9ic1tpXTtcclxuICAgICAgICBjb25zdCB0eXBlRGVmID0gdHlwZU1hcFtvLnR5cGVdO1xyXG5cclxuICAgICAgICBpZihvLnR5cGUgPT09ICdzcGF3bmVyJykgY29udGludWU7XHJcbiAgICAgICAgaWYoby50eXBlID09PSAncm91bmRlZGNvcm5lcnMnIHx8IG8udHlwZSA9PT0gJ3JvdW5kZWRsYXZhJyl7XHJcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZVR5cGUgPSBvLnR5cGUgPT09ICdyb3VuZGVkY29ybmVycycgPyAnY2lyY2xlLW5vcm1hbCcgOiAnY2lyY2xlLWxhdmEnO1xyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgby5jaXJjbGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIG9icy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBvLmNpcmNsZXNbaV0ueCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBvLmNpcmNsZXNbaV0ueSxcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IG8uY2lyY2xlc1tpXS5yYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJyZW5kZXJUeXBlXCI6IFwiY2lyY2xlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpblZpZXdcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY2lyY2xlVHlwZVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZWN0VHlwZSA9IG8udHlwZSA9PT0gJ3JvdW5kZWRjb3JuZXJzJyA/ICdub3JtYWwnIDogJ2xhdmEnO1xyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgby5yZWN0cy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBvYnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogby5yZWN0c1tpXS54LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IG8ucmVjdHNbaV0ueSxcclxuICAgICAgICAgICAgICAgICAgICB3OiBvLnJlY3RzW2ldLncsXHJcbiAgICAgICAgICAgICAgICAgICAgaDogby5yZWN0c1tpXS5oLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHJlY3RUeXBlXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZihvLnR5cGUgPT09ICdjb2xvcicpe1xyXG4gICAgICAgICAgICBvLnggKj0gMjsgby55ICo9IDI7IG8udyAqPSAyOyBvLmggKj0gMjtcclxuICAgICAgICAgICAgY29uc3QgbWluWCA9IG8ueCAtIDEwMDtcclxuICAgICAgICAgICAgY29uc3QgbWluWSA9IG8ueSAtIDEwMDtcclxuICAgICAgICAgICAgY29uc3QgbWF4WCA9IG8ueCArIG8udyArIDEwMDtcclxuICAgICAgICAgICAgY29uc3QgbWF4WSA9IG8ueSArIG8uaCArIDEwMDtcclxuICAgICAgICAgICAgc3RyICs9IGB2YXIgbWluWCR7Y291bnRlcn0sIG1pblkke2NvdW50ZXJ9LCBtYXhYJHtjb3VudGVyfSwgbWF4WSR7Y291bnRlcn07XHJcbiAgICAgICAgICAgIG1pblgke2NvdW50ZXJ9ID0gJHttaW5YfTttaW5ZJHtjb3VudGVyfSA9ICR7bWluWX07bWF4WCR7Y291bnRlcn0gPSAke21heFh9O21heFkke2NvdW50ZXJ9ID0gJHttYXhZfTtcclxuICAgICAgICAgICAgc2hhcmVkLkMoMSxbM10sWzBdLHtoOjEsdzoxLHk6MCx4Oi0xMDAwMCxzZjooZSk9PntcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXllciA9IHNoYXJlZC5wbGF5ZXJzW3NoYXJlZC5zZWxmSWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwbGF5ZXIucG9zLngpID4gbWQobWluWCR7Y291bnRlcn0pICYmIChwbGF5ZXIucG9zLngpIDwgbWQobWF4WCR7Y291bnRlcn0pICYmIChwbGF5ZXIucG9zLnkpID4gbWQobWluWSR7Y291bnRlcn0pICYmIChwbGF5ZXIucG9zLnkpIDwgbWQobWF4WSR7Y291bnRlcn0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLmJhY2tncm91bmQ9XCIke28udGlsZUNvbG9yfVwiOyBjb2xvcnMudGlsZT1cIiR7by5iZ0NvbG9yfVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LH0pO1xcbmA7XHJcbiAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICB9IGVsc2UgaWYoby50eXBlID09PSAnc3dpdGNobGF2YScpe1xyXG4gICAgICAgICAgICBvLnggKj0gMjsgby55ICo9IDI7IG8udyAqPSAyOyBvLmggKj0gMjtcclxuICAgICAgICAgICAgc3RyICs9IGB2YXIgdGltZXIke2NvdW50ZXJ9ID0gJHtvLnRpbWVyfTsgdmFyIHN0YXRlJHtjb3VudGVyfSA9JHtvLnN0YXRlfTsgdmFyIHgke2NvdW50ZXJ9ID0gJHtvLnh9OyBcclxuICAgICAgICAgICAgc2hhcmVkLkMoMSxbXSxbMV0se2g6JHtvLmh9LHc6JHtvLnd9LHk6JHtvLnl9LHg6JHtvLnh9LHNmOihlKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyJHtjb3VudGVyfSAtPSAxLzYwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRpbWVyJHtjb3VudGVyfSA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSR7Y291bnRlcn0gPSAhc3RhdGUke2NvdW50ZXJ9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzdGF0ZSR7Y291bnRlcn0gPT09IHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyJHtjb3VudGVyfSArPSAke28ub25UaW1lfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucG9zLnggPSB4JHtjb3VudGVyfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIke2NvdW50ZXJ9ICs9ICR7by5vZmZUaW1lfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucG9zLnggPSAtMUU5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNyOihlKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUke2NvdW50ZXJ9KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciR7Y291bnRlcn0gPCAwLjIgJiYgJHtvLm9uVGltZX0gPiAwLjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRpbWVyJHtjb3VudGVyfSAvIDAuMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyJHtjb3VudGVyfSA8IDAuMiAmJiAke28ub2ZmVGltZX0gPiAwLjIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuOSAqICgxIC0gdGltZXIke2NvdW50ZXJ9IC8gMC4yKSArIDAuMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJHtvLmNvbGxpZGFibGV9ID8gJyNjNzAwMDAnIDogJyM5ZTAwMDAnO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qaWYgKG9ic3RhY2xlLmNvbGxpZGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjYzcwMDAwJztcclxuICAgICAgICAgICAgICAgICAgICB9Ki8gXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoeCR7Y291bnRlcn0sIGUucG9zLnksIGUuZGltZW5zaW9ucy54LCBlLmRpbWVuc2lvbnMueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xcbmA7XHJcbiAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICB9IGVsc2UgaWYoby50eXBlID09PSAnYmxvY2snIHx8IG8udHlwZSA9PT0gJ3RyYW5zJyl7XHJcbiAgICAgICAgICAgIG8ueCAqPSAyOyBvLnkgKj0gMjsgby53ICo9IDI7IG8uaCAqPSAyO1xyXG4gICAgICAgICAgICBzdHIgKz0gYHNoYXJlZC5DKDEsW10sWzIwXSx7aDoke28uaH0sdzoke28ud30seToke28ueX0seDoke28ueH0sXHJcbiAgICAgICAgICAgICAgICBjcjooZSk9PntcclxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9ICR7by50eXBlID09PSAndHJhbnMnID8gXCJjb2xvcnMuYmFja2dyb3VuZFwiIDogXCInXCIgKyAoby5oZXggPz8gby5jb2xvcikgKyBcIidcIn07XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gJHtvLm9wYXEgPz8gMX07XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoZS5wb3MueCwgZS5wb3MueSwgZS5kaW1lbnNpb25zLngsIGUuZGltZW5zaW9ucy55KTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XFxuYDtcclxuICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9IGVsc2UgaWYoby50eXBlID09PSAnZ3JhcHBsZXBvaW50JyB8fCBvLnR5cGUgPT09ICdtb3ZpbmdncmFwcGxlcG9pbnQnKXtcclxuICAgICAgICAgICAgby54ICo9IDI7IG8ueSAqPSAyO1xyXG4gICAgICAgICAgICBpZihvLnR5cGUgPT09ICdncmFwcGxlcG9pbnQnKXtcclxuICAgICAgICAgICAgICAgIHN0ciArPSBgc2hhcmVkLkMoMCxbXSxbMF0se3I6MjArMTIvMix5OiR7by55fSx4OiR7by54fSxcclxuICAgICAgICAgICAgICAgICAgICBjcjooZSk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5pc0dyYXBwbGVQb2ludCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjYzljOWM5JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDEyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhlLnBvcy54LCBlLnBvcy55LCAyMCwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcXG5gO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB7cGF0aDogJ1snfTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9pbnRzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBwLnBhdGggKz0gYFske3BhcmFtcy5wb2ludHNbaV1bMF0qMn0sWyR7cGFyYW1zLnBvaW50c1tpXVsxXSoyfV0sJHtwYXJhbXMuc3BlZWQgKiAyIC8gMTAwMH1dLGA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcC5jdXJyZW50UG9pbnQgPSBwYXJhbXMuY3VycmVudFBvaW50O1xyXG4gICAgICAgICAgICAgICAgcC54ID0gcGFyYW1zLnBvaW50c1swXVswXSAqIDI7XHJcbiAgICAgICAgICAgICAgICBwLnkgPSBwYXJhbXMucG9pbnRzWzBdWzFdICogMjtcclxuXHJcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBwLnBhdGguc3Vic3RyaW5nKDAsIHAucGF0aC5sZW5ndGgtMSk7XHJcbiAgICAgICAgICAgICAgICBwLnBhdGggKz0gJ10nO1xyXG4gICAgICAgICAgICAgICAgc3RyICs9IGBzaGFyZWQuQygwLFswXSxbMF0se3I6MjArMTIvMixcclxuICAgICAgICAgICAgICAgICAgICBjcjooZSk9PntcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5pc0dyYXBwbGVQb2ludCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjYzljOWM5JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDEyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhlLnBvcy54LCBlLnBvcy55LCAyMCwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9LGN1cnJlbnRQb2ludDoke3AuY3VycmVudFBvaW50fSx4OiR7cC54fSx5OiR7cC55fSxwYXRoOiR7cC5wYXRofVxyXG4gICAgICAgICAgICAgICAgfSk7XFxuYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb3VudGVyKys7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZihvLnR5cGUgPT09ICdjaXJjbGUtc2VudHJ5Jyl7XHJcbiAgICAgICAgICAgIG8ueCAqPSAyOyBvLnkgKj0gMjsgby5yICo9IDI7XHJcbiAgICAgICAgICAgIG8ubGFzZXIueCAqPSAyOyBvLmxhc2VyLnkgKj0gMjsgby5sYXNlci53ICo9IDI7IG8ubGFzZXIuaCAqPSAyO1xyXG4gICAgICAgICAgICBzdHIgKz0gYHNoYXJlZC5DKDEsWzVdLFsxXSx7aDoke28ubGFzZXIuaH0sdzoke28ubGFzZXIud30seToke28ueS1vLmxhc2VyLmgvMn0seDoke28ueC1vLmxhc2VyLncvMn0sXHJcbiAgICAgICAgICAgICAgICBib3VuZFBsYXllcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHJlc3RBbmdsZXM6IFske28ucmVzdCpNYXRoLlBJLzE4MH0sICR7by5yZXN0Kk1hdGguUEkvMTgwK01hdGguUEl9XSxcclxuICAgICAgICAgICAgICAgIHRvUmVzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhvbWluZ1JvdGF0ZVNwZWVkOiAke28uc3BlZWQgLyA4NjAwMH0sXHJcbiAgICAgICAgICAgICAgICBkZXRlY3Rpb25SYWRpdXM6ICR7TWF0aC5zcXJ0KG8ubGFzZXIudyoqMitvLmxhc2VyLmgqKjIpLzJ9LFxyXG4gICAgICAgICAgICAgICAgc3Bva2VBbmdsZXM6IFswLCBNYXRoLlBJXSxcclxuICAgICAgICAgICAgICAgIHBpdm90WDogJHtvLnh9LFxyXG4gICAgICAgICAgICAgICAgcGl2b3RZOiAke28ueX1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHNoYXJlZC5DKDAsW10sWzBdLHt4OiR7by54fSx5OiR7by55fSxyOiR7by5yfSxjcjooZSk9PntcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBzaGFyZWQuY29sb3JzLnRpbGU7XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguYXJjKGUucG9zLngsIGUucG9zLnksIGUuc2F0LnIsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gMTU7XHJcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguYXJjKFxyXG4gICAgICAgICAgICAgICAgICAgIGUucG9zLngsXHJcbiAgICAgICAgICAgICAgICAgICAgZS5wb3MueSxcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChlLnNhdC5yIC0gMzAsIDApLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSAqIDJcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIH19KTtgXHJcbiAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSBlbHNlIGlmKG8udHlwZSA9PT0gJ3Jlc2V0Y29pbnMnKXtcclxuICAgICAgICAgICAgby54ICo9IDI7IG8ueSAqPSAyOyBvLncgKj0gMjsgby5oICo9IDI7XHJcbiAgICAgICAgICAgIHN0ciArPSBgc2hhcmVkLkMoMSxbXSxbMjBdLHt4OiR7by54fSx5OiR7by55fSx3OiR7by53fSxoOiR7by5ofSxoZXg6JyMwMDAwMDAnLGFscGhhOjAsY3I6KCk9Pnt9LGVmOigpPT57XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgb2JzdGFjbGVzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihvYnN0YWNsZXNbaV0uY29sbGVjdGVkICE9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnN0YWNsZXNbaV0uY29sbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKG9ic3RhY2xlc1tpXS5pc0NvaW5kb29yID09PSB0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzdGFjbGVzW2ldLmNvaW5zID0gb2JzdGFjbGVzW2ldLm1heENvaW5zOyBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICB9fSk7YDtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSBlbHNlIGlmKG8udHlwZSA9PT0gJ3Jlc2V0dGltZXRyYXBzJyl7XHJcbiAgICAgICAgICAgIG8ueCAqPSAyOyBvLnkgKj0gMjsgby53ICo9IDI7IG8uaCAqPSAyO1xyXG4gICAgICAgICAgICBzdHIgKz0gYHNoYXJlZC5DKDEsW10sWzIwXSx7eDoke28ueH0seToke28ueX0sdzoke28ud30saDoke28uaH0saGV4OicjMDAwMDAwJyxhbHBoYTowLGNyOigpPT57fSxlZjooKT0+e1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG9ic3RhY2xlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYob2JzdGFjbGVzW2ldLnRpbWVUcmFwVGltZSAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzdGFjbGVzW2ldLnRpbWVUcmFwVGltZSA9IG9ic3RhY2xlc1tpXS50aW1lVHJhcE1heFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSAgICBcclxuICAgICAgICAgICAgfX0pO2A7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZURlZiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmKGFscmVhZHlMb2dnZWRbby50eXBlXSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGFscmVhZHlMb2dnZWRbby50eXBlXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm8gdHlwZSBkZWYgZm9yICcgKyBvLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt0eXBlOiB0eXBlRGVmLnR5cGV9O1xyXG5cclxuICAgICAgICBmb3IobGV0IGtleSBpbiBvKXtcclxuICAgICAgICAgICAgaWYoa2V5ID09PSAndHlwZScpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZih0eXBlRGVmW2tleV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zW3R5cGVEZWZba2V5XV0gPSBvW2tleV07Ly8gby5yIGluc3RlYWQgb2Ygby5yYWRpdXMgc2V0IHRvIG9ba2V5XSBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtc1trZXldID0gb1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJhbXMueCAqPSAyO1xyXG4gICAgICAgIHBhcmFtcy55ICo9IDI7XHJcbiAgICAgICAgaWYocGFyYW1zLncpIHBhcmFtcy53ICo9IDI7XHJcbiAgICAgICAgaWYocGFyYW1zLmgpIHBhcmFtcy5oICo9IDI7XHJcbiAgICAgICAgaWYocGFyYW1zLnIgIT09IHVuZGVmaW5lZCkgcGFyYW1zLnIgKj0gMjtcclxuXHJcbiAgICAgICAgaWYodHlwZURlZi5jdXN0b21NYXAgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vcmVQYXJhbXMgPSB0eXBlRGVmLmN1c3RvbU1hcChvKTtcclxuICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gbW9yZVBhcmFtcyl7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IG1vcmVQYXJhbXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSBge2A7XHJcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gcGFyYW1zKXtcclxuICAgICAgICAgICAgcGFyYW1TdHJpbmcgKz0gYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldKX0sYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyYW1TdHJpbmcgKz0gJ30nO1xyXG5cclxuICAgICAgICBsZXQgdHlwZVN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcy50eXBlKTtcclxuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZVN0cmluZy5zbGljZSgxLCB0eXBlU3RyaW5nLmxlbmd0aC0xKTtcclxuXHJcbiAgICAgICAgLy9zaGFyZWQuQygxLFtdLFswXSx7aDoxMDAsdzoxMTAwLHk6NDMwMCx4OjQ2MDAsfSk7XHJcbiAgICAgICAgc3RyICs9IGBzaGFyZWQuQygke3R5cGVTdHJpbmd9LCR7cGFyYW1TdHJpbmd9KVxcbmA7XHJcbiAgICB9XHJcblxyXG4gICAgZXZhbChzdHIpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBpbXBvcnRNYXA7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///78\n')}}]);