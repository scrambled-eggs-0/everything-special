"use strict";(self.webpackChunkomniserver=self.webpackChunkomniserver||[]).push([[964],{964:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// ONLY thing the api does is copy over the canvas to a webgl canvas\r\n// with shader effects. This means to draw anything we must draw it\r\n// on the canvas first and then do 1 draw call per each transformation.\r\n// This is the best even though drawing on webgl directly would be faster,\r\n// all our obstacles are tied to the canvas anyways and canvas can do pretty\r\n// much everything besides nonlinear transformations.\r\n\r\n// For the notable exception of doing something with some parameters not encoded\r\n// in the 2d image (e.g. z-coordinate) we should eventually implement a system\r\n// to add a buffer (see texCoordinates in serum's threedrenderer example)\r\n\r\nconst placeholder = document.getElementById('webglplaceholder');\r\nlet glCanvas;\r\n\r\nfunction initNonlinearTransform(vs, fs, uniformNames, uniformLambdas){\r\n    if(window.distortionsActive === true) unInitNonlinearTransform();\r\n    window.distortionsActive = true;\r\n\r\n    // set up canvas and resizing\r\n    glCanvas = document.createElement('canvas');\r\n    const gl = glCanvas.getContext('webgl2');\r\n    placeholder.appendChild(glCanvas);\r\n    \r\n    window.resizeWebGl = () => {\r\n        window.resizeElements([glCanvas]);\r\n        gl.viewport(0, 0, glCanvas.width, glCanvas.height);\r\n    }\r\n    window.resizeWebGl();\r\n    window.resizeFns.push(window.resizeWebGl);\r\n    \r\n    let vertexData = [];\r\n    let indicies = [];\r\n    \r\n    const jmp = 1;//10\r\n    const resX = Math.ceil(glCanvas.width / jmp);\r\n    const resY = Math.ceil(glCanvas.height / jmp);\r\n    \r\n    // forming verticies\r\n    for(let y = 0; y < resY; y++){\r\n        for(let x = 0; x < resX; x++){\r\n            // vertex positions in space. Scaled from -1 to 1\r\n            vertexData.push(\r\n                (x / (resX-1)) * 2 - 1,\r\n                (y / (resY-1)) * 2 - 1,\r\n            );\r\n        }\r\n    }\r\n    \r\n    // forming triangles\r\n    // we form triangles from y layer n to y layer n+1\r\n    for(let y = 0; y < resY-1; y++){\r\n        for(let x = 0; x < resX-1; x++){\r\n            const i = y * (resX) + x;\r\n            indicies.push(\r\n                i,\r\n                i+1,\r\n                i+resX,\r\n            );\r\n            indicies.push(\r\n                i+1,\r\n                i+resX,\r\n                i+resX+1,\r\n            );\r\n        }\r\n    }\r\n    \r\n    vertexData = new Float32Array(vertexData);\r\n    indicies = new Uint32Array(indicies);\r\n    \r\n    // Create vertex buffer\r\n    const vertexBuffer = gl.createBuffer();\r\n    {\r\n        // Bind buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\r\n    \r\n        // Feed vertex buffer with data\r\n        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);\r\n    }\r\n    \r\n    // Create index buffer\r\n    const indexBuffer = gl.createBuffer();\r\n    {\r\n        // Bind buffer\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    \r\n        // Feed index buffer with data\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicies, gl.STATIC_DRAW);\r\n    }\r\n    \r\n    // Use shader program\r\n    function createShaderProgram() {\r\n        function compileShader(str, type) {\r\n            // create shader\r\n            const shader = gl.createShader(type)\r\n        \r\n            // give it source code and compile\r\n            gl.shaderSource(shader, str);\r\n            gl.compileShader(shader)\r\n        \r\n            const errors = gl.getShaderInfoLog(shader)\r\n            if (errors.length != 0) {\r\n                console.log('Error Compiling Shader!');\r\n                console.log(errors);\r\n                return null;\r\n            }\r\n            else return shader;\r\n        }\r\n\r\n        // Create shader program\r\n        const program = gl.createProgram();\r\n    \r\n        // Attach vertex shader\r\n        const vertexShader = compileShader(vs, gl.VERTEX_SHADER)\r\n        gl.attachShader(program, vertexShader)\r\n    \r\n        // Attach fragment shader\r\n        const fragmentShader = compileShader(fs, gl.FRAGMENT_SHADER)\r\n        gl.attachShader(program, fragmentShader)\r\n    \r\n        // Link and validate program\r\n        gl.linkProgram(program);\r\n        gl.validateProgram(program);\r\n    \r\n        // Check for errors\r\n        const errors = gl.getProgramInfoLog(program)\r\n        if (errors.length !== 0) {\r\n            console.log('Error Compiling Program!');\r\n            console.log(errors);\r\n        }\r\n    \r\n        // Free GPU memory\r\n        gl.deleteShader(vertexShader);\r\n        gl.deleteShader(fragmentShader);\r\n    \r\n        return program;\r\n    }\r\n    const program = createShaderProgram();\r\n    \r\n    gl.useProgram(program);\r\n    \r\n    {// Specify locations of pos in the typed arrays\r\n        let posLocation = gl.getAttribLocation(program, \"pos\");\r\n        gl.enableVertexAttribArray(posLocation);\r\n        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT, 0);// for second to last 0\r\n    }\r\n    \r\n    // Texture\r\n    const texture = gl.createTexture();\r\n    updateTexture();\r\n    \r\n    function updateTexture(){\r\n        // use texture unit 0\r\n        gl.activeTexture(gl.TEXTURE0 + 0);\r\n    \r\n        // bind to the TEXTURE_2D bind point of texture unit 0\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\r\n    \r\n        // canvas is not a power of 2. If it was, it would be higher quality to do\r\n        // gl.generateMipmap(gl.TEXTURE_2D);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);// gl.LINEAR\r\n    }\r\n\r\n    const uniforms = [];\r\n    for(let i = 0; i < uniformNames.length; i++){\r\n        uniforms.push(gl.getUniformLocation(program, uniformNames[i]));\r\n    }\r\n    \r\n    //TODO: flipY gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n    window.renderGl = () => {\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n\r\n        // get new canvas data\r\n        updateTexture();\r\n    \r\n        // setup uniforms\r\n        for(let i = 0; i < uniformLambdas.length; i++){\r\n            gl.uniform1f(uniforms[i], uniformLambdas[i]());\r\n        }\r\n        // let t = Date.now() / 1000;\r\n        // t -= Math.floor(t/100)*100;\r\n        // gl.uniform1f(uTime, t);\r\n        \r\n        gl.clearColor(0, 0, 0, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n    \r\n        gl.drawElements(gl.TRIANGLES,\r\n            indicies.length, // how many vertecies we want to draw\r\n            gl.UNSIGNED_INT, // Uint32 for created indicies array \r\n            0 // offset in index array (0 = start from beginning)\r\n        )\r\n    }\r\n}\r\n\r\nfunction unInitNonlinearTransform(){\r\n    if(window.distortionsActive === false) return;\r\n    window.resizeFns = window.resizeFns.filter(f => f !== window.resizeWebGl);\r\n    window.distortionsActive = false;\r\n    glCanvas.remove();\r\n}\r\n\r\n// window.initDistortion(`#version 300 es\r\n//     in highp vec4 pos;\r\n    \r\n//     uniform float uTime;\r\n    \r\n//     out highp vec2 vTextureCoord;\r\n    \r\n//     void main()\r\n//     {\r\n//         gl_Position = pos;\r\n//         gl_Position.x += 0.1*sin(6.0*uTime + 3.0*pos.y);\r\n//         gl_Position.y += 0.2*sin(6.0*uTime - 6.0*pos.x);\r\n    \r\n//         // texture coordinate is just pos but within 0-1 instead of -1 to 1.\r\n//         // So scale in that range.\r\n//         vTextureCoord = (pos.xy+1.)*0.5;\r\n//     }`,\r\n//     `#version 300 es\r\n//     in highp vec2 vTextureCoord;\r\n    \r\n//     out highp vec4 outColor;\r\n    \r\n//     uniform sampler2D uSampler;\r\n    \r\n//     void main()\r\n//     {\r\n//         // outColor = vec4(vTextureCoord.x, 0.0, 0.0, 1.0);\r\n//         outColor = texture(uSampler, vTextureCoord);//vec4(1, 0, 0.5, 1);\r\n// }`);\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({initNonlinearTransform, unInitNonlinearTransform});\r\n\r\n// // CONE MAP\r\n// window.initDistortion(`#version 300 es\r\n//     in highp vec4 pos;\r\n    \r\n//     uniform float uTime;\r\n    \r\n//     out highp vec2 vTextureCoord;\r\n    \r\n//     void main()\r\n//     {\r\n//         float angle = atan(pos.y, pos.x);\r\n//         float dist = sqrt(pos.y*pos.y + pos.x*pos.x);\r\n\r\n//         // calculating max distance along the angle from the origin to end of screen\r\n\r\n//         float p = max(abs(cos(angle)), abs(sin(angle)));\r\n//         // float maxDistAlongAngle = 0.5/p;\r\n\r\n//         // above 2 lines equivalent to:\r\n//         float x = cos(angle) / p;\r\n//         float y = sin(angle) / p;\r\n//         float maxDistAlongAngle = sqrt(x*x + y*y);\r\n\r\n//         // just setting x,y to gl_Position.xy results in oval shape. What we're doing is extruding to 3d.\r\n//         x = cos(angle) * dist / maxDistAlongAngle;\r\n//         y = sin(angle) * dist / maxDistAlongAngle;\r\n//         float z = dist / maxDistAlongAngle;\r\n\r\n//         float a = 2.;\r\n//         float b = 3.14/4.;\r\n\r\n//         float sa = sin(a);\r\n//         float sb = sin(b);\r\n//         float ca = cos(a);\r\n//         float cb = cos(b);\r\n\r\n//         float coneX = x * ca - y * sa;\r\n//         float coneY = (x * sa + y * ca) * sb - z * cb;\r\n\r\n//         float t = uTime - floor(uTime);\r\n\r\n//         gl_Position = pos;\r\n//         gl_Position.x = coneX * t + pos.x * (1.-t);\r\n//         gl_Position.y = coneY * t + pos.y * (1.-t) + .5;\r\n    \r\n//         // texture coordinate is just pos but within 0-1 instead of -1 to 1.\r\n//         // So scale in that range.\r\n//         vTextureCoord = (pos.xy+1.)*0.5;\r\n//     }`,\r\n//     `#version 300 es\r\n//     in highp vec2 vTextureCoord;\r\n    \r\n//     out highp vec4 outColor;\r\n    \r\n//     uniform sampler2D uSampler;\r\n    \r\n//     void main()\r\n//     {\r\n//         // outColor = vec4(vTextureCoord.x, 0.0, 0.0, 1.0);\r\n//         outColor = texture(uSampler, vTextureCoord);//vec4(1, 0, 0.5, 1);\r\n// }`);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb21uaXNlcnZlci8uL2VYY2xpZW50L2V4dHJhcy9kaXN0b3J0LmpzPzAxMmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT05MWSB0aGluZyB0aGUgYXBpIGRvZXMgaXMgY29weSBvdmVyIHRoZSBjYW52YXMgdG8gYSB3ZWJnbCBjYW52YXNcclxuLy8gd2l0aCBzaGFkZXIgZWZmZWN0cy4gVGhpcyBtZWFucyB0byBkcmF3IGFueXRoaW5nIHdlIG11c3QgZHJhdyBpdFxyXG4vLyBvbiB0aGUgY2FudmFzIGZpcnN0IGFuZCB0aGVuIGRvIDEgZHJhdyBjYWxsIHBlciBlYWNoIHRyYW5zZm9ybWF0aW9uLlxyXG4vLyBUaGlzIGlzIHRoZSBiZXN0IGV2ZW4gdGhvdWdoIGRyYXdpbmcgb24gd2ViZ2wgZGlyZWN0bHkgd291bGQgYmUgZmFzdGVyLFxyXG4vLyBhbGwgb3VyIG9ic3RhY2xlcyBhcmUgdGllZCB0byB0aGUgY2FudmFzIGFueXdheXMgYW5kIGNhbnZhcyBjYW4gZG8gcHJldHR5XHJcbi8vIG11Y2ggZXZlcnl0aGluZyBiZXNpZGVzIG5vbmxpbmVhciB0cmFuc2Zvcm1hdGlvbnMuXHJcblxyXG4vLyBGb3IgdGhlIG5vdGFibGUgZXhjZXB0aW9uIG9mIGRvaW5nIHNvbWV0aGluZyB3aXRoIHNvbWUgcGFyYW1ldGVycyBub3QgZW5jb2RlZFxyXG4vLyBpbiB0aGUgMmQgaW1hZ2UgKGUuZy4gei1jb29yZGluYXRlKSB3ZSBzaG91bGQgZXZlbnR1YWxseSBpbXBsZW1lbnQgYSBzeXN0ZW1cclxuLy8gdG8gYWRkIGEgYnVmZmVyIChzZWUgdGV4Q29vcmRpbmF0ZXMgaW4gc2VydW0ncyB0aHJlZWRyZW5kZXJlciBleGFtcGxlKVxyXG5cclxuY29uc3QgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2ViZ2xwbGFjZWhvbGRlcicpO1xyXG5sZXQgZ2xDYW52YXM7XHJcblxyXG5mdW5jdGlvbiBpbml0Tm9ubGluZWFyVHJhbnNmb3JtKHZzLCBmcywgdW5pZm9ybU5hbWVzLCB1bmlmb3JtTGFtYmRhcyl7XHJcbiAgICBpZih3aW5kb3cuZGlzdG9ydGlvbnNBY3RpdmUgPT09IHRydWUpIHVuSW5pdE5vbmxpbmVhclRyYW5zZm9ybSgpO1xyXG4gICAgd2luZG93LmRpc3RvcnRpb25zQWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBzZXQgdXAgY2FudmFzIGFuZCByZXNpemluZ1xyXG4gICAgZ2xDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNvbnN0IGdsID0gZ2xDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XHJcbiAgICBwbGFjZWhvbGRlci5hcHBlbmRDaGlsZChnbENhbnZhcyk7XHJcbiAgICBcclxuICAgIHdpbmRvdy5yZXNpemVXZWJHbCA9ICgpID0+IHtcclxuICAgICAgICB3aW5kb3cucmVzaXplRWxlbWVudHMoW2dsQ2FudmFzXSk7XHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2xDYW52YXMud2lkdGgsIGdsQ2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICB3aW5kb3cucmVzaXplV2ViR2woKTtcclxuICAgIHdpbmRvdy5yZXNpemVGbnMucHVzaCh3aW5kb3cucmVzaXplV2ViR2wpO1xyXG4gICAgXHJcbiAgICBsZXQgdmVydGV4RGF0YSA9IFtdO1xyXG4gICAgbGV0IGluZGljaWVzID0gW107XHJcbiAgICBcclxuICAgIGNvbnN0IGptcCA9IDE7Ly8xMFxyXG4gICAgY29uc3QgcmVzWCA9IE1hdGguY2VpbChnbENhbnZhcy53aWR0aCAvIGptcCk7XHJcbiAgICBjb25zdCByZXNZID0gTWF0aC5jZWlsKGdsQ2FudmFzLmhlaWdodCAvIGptcCk7XHJcbiAgICBcclxuICAgIC8vIGZvcm1pbmcgdmVydGljaWVzXHJcbiAgICBmb3IobGV0IHkgPSAwOyB5IDwgcmVzWTsgeSsrKXtcclxuICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgcmVzWDsgeCsrKXtcclxuICAgICAgICAgICAgLy8gdmVydGV4IHBvc2l0aW9ucyBpbiBzcGFjZS4gU2NhbGVkIGZyb20gLTEgdG8gMVxyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhLnB1c2goXHJcbiAgICAgICAgICAgICAgICAoeCAvIChyZXNYLTEpKSAqIDIgLSAxLFxyXG4gICAgICAgICAgICAgICAgKHkgLyAocmVzWS0xKSkgKiAyIC0gMSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIGZvcm1pbmcgdHJpYW5nbGVzXHJcbiAgICAvLyB3ZSBmb3JtIHRyaWFuZ2xlcyBmcm9tIHkgbGF5ZXIgbiB0byB5IGxheWVyIG4rMVxyXG4gICAgZm9yKGxldCB5ID0gMDsgeSA8IHJlc1ktMTsgeSsrKXtcclxuICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgcmVzWC0xOyB4Kyspe1xyXG4gICAgICAgICAgICBjb25zdCBpID0geSAqIChyZXNYKSArIHg7XHJcbiAgICAgICAgICAgIGluZGljaWVzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgaSsxLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpbmRpY2llcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgaSsxLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYKzEsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhEYXRhKTtcclxuICAgIGluZGljaWVzID0gbmV3IFVpbnQzMkFycmF5KGluZGljaWVzKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIHZlcnRleCBidWZmZXJcclxuICAgIGNvbnN0IHZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAge1xyXG4gICAgICAgIC8vIEJpbmQgYnVmZmVyXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcilcclxuICAgIFxyXG4gICAgICAgIC8vIEZlZWQgdmVydGV4IGJ1ZmZlciB3aXRoIGRhdGFcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgaW5kZXggYnVmZmVyXHJcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAge1xyXG4gICAgICAgIC8vIEJpbmQgYnVmZmVyXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXIpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gRmVlZCBpbmRleCBidWZmZXIgd2l0aCBkYXRhXHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNpZXMsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVXNlIHNoYWRlciBwcm9ncmFtXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTaGFkZXJQcm9ncmFtKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoc3RyLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzaGFkZXJcclxuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIGdpdmUgaXQgc291cmNlIGNvZGUgYW5kIGNvbXBpbGVcclxuICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3RyKTtcclxuICAgICAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKVxyXG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgQ29tcGlsaW5nIFNoYWRlciEnKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBzaGFkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgc2hhZGVyIHByb2dyYW1cclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQXR0YWNoIHZlcnRleCBzaGFkZXJcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKHZzLCBnbC5WRVJURVhfU0hBREVSKVxyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpXHJcbiAgICBcclxuICAgICAgICAvLyBBdHRhY2ggZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGZzLCBnbC5GUkFHTUVOVF9TSEFERVIpXHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxyXG4gICAgXHJcbiAgICAgICAgLy8gTGluayBhbmQgdmFsaWRhdGUgcHJvZ3JhbVxyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGZvciBlcnJvcnNcclxuICAgICAgICBjb25zdCBlcnJvcnMgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKVxyXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBDb21waWxpbmcgUHJvZ3JhbSEnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBGcmVlIEdQVSBtZW1vcnlcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbSgpO1xyXG4gICAgXHJcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgXHJcbiAgICB7Ly8gU3BlY2lmeSBsb2NhdGlvbnMgb2YgcG9zIGluIHRoZSB0eXBlZCBhcnJheXNcclxuICAgICAgICBsZXQgcG9zTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcInBvc1wiKTtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NMb2NhdGlvbik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAwKTsvLyBmb3Igc2Vjb25kIHRvIGxhc3QgMFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBUZXh0dXJlXHJcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgdXBkYXRlVGV4dHVyZSgpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVUZXh0dXJlKCl7XHJcbiAgICAgICAgLy8gdXNlIHRleHR1cmUgdW5pdCAwXHJcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIDApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gYmluZCB0byB0aGUgVEVYVFVSRV8yRCBiaW5kIHBvaW50IG9mIHRleHR1cmUgdW5pdCAwXHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBjYW52YXMpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gY2FudmFzIGlzIG5vdCBhIHBvd2VyIG9mIDIuIElmIGl0IHdhcywgaXQgd291bGQgYmUgaGlnaGVyIHF1YWxpdHkgdG8gZG9cclxuICAgICAgICAvLyBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7Ly8gZ2wuTElORUFSXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdW5pZm9ybXMgPSBbXTtcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB1bmlmb3JtTmFtZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHVuaWZvcm1zLnB1c2goZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lc1tpXSkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvL1RPRE86IGZsaXBZIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG4gICAgd2luZG93LnJlbmRlckdsID0gKCkgPT4ge1xyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xyXG5cclxuICAgICAgICAvLyBnZXQgbmV3IGNhbnZhcyBkYXRhXHJcbiAgICAgICAgdXBkYXRlVGV4dHVyZSgpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gc2V0dXAgdW5pZm9ybXNcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdW5pZm9ybUxhbWJkYXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBnbC51bmlmb3JtMWYodW5pZm9ybXNbaV0sIHVuaWZvcm1MYW1iZGFzW2ldKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZXQgdCA9IERhdGUubm93KCkgLyAxMDAwO1xyXG4gICAgICAgIC8vIHQgLT0gTWF0aC5mbG9vcih0LzEwMCkqMTAwO1xyXG4gICAgICAgIC8vIGdsLnVuaWZvcm0xZih1VGltZSwgdCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxLjApO1xyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUyxcclxuICAgICAgICAgICAgaW5kaWNpZXMubGVuZ3RoLCAvLyBob3cgbWFueSB2ZXJ0ZWNpZXMgd2Ugd2FudCB0byBkcmF3XHJcbiAgICAgICAgICAgIGdsLlVOU0lHTkVEX0lOVCwgLy8gVWludDMyIGZvciBjcmVhdGVkIGluZGljaWVzIGFycmF5IFxyXG4gICAgICAgICAgICAwIC8vIG9mZnNldCBpbiBpbmRleCBhcnJheSAoMCA9IHN0YXJ0IGZyb20gYmVnaW5uaW5nKVxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdW5Jbml0Tm9ubGluZWFyVHJhbnNmb3JtKCl7XHJcbiAgICBpZih3aW5kb3cuZGlzdG9ydGlvbnNBY3RpdmUgPT09IGZhbHNlKSByZXR1cm47XHJcbiAgICB3aW5kb3cucmVzaXplRm5zID0gd2luZG93LnJlc2l6ZUZucy5maWx0ZXIoZiA9PiBmICE9PSB3aW5kb3cucmVzaXplV2ViR2wpO1xyXG4gICAgd2luZG93LmRpc3RvcnRpb25zQWN0aXZlID0gZmFsc2U7XHJcbiAgICBnbENhbnZhcy5yZW1vdmUoKTtcclxufVxyXG5cclxuLy8gd2luZG93LmluaXREaXN0b3J0aW9uKGAjdmVyc2lvbiAzMDAgZXNcclxuLy8gICAgIGluIGhpZ2hwIHZlYzQgcG9zO1xyXG4gICAgXHJcbi8vICAgICB1bmlmb3JtIGZsb2F0IHVUaW1lO1xyXG4gICAgXHJcbi8vICAgICBvdXQgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG4gICAgXHJcbi8vICAgICB2b2lkIG1haW4oKVxyXG4vLyAgICAge1xyXG4vLyAgICAgICAgIGdsX1Bvc2l0aW9uID0gcG9zO1xyXG4vLyAgICAgICAgIGdsX1Bvc2l0aW9uLnggKz0gMC4xKnNpbig2LjAqdVRpbWUgKyAzLjAqcG9zLnkpO1xyXG4vLyAgICAgICAgIGdsX1Bvc2l0aW9uLnkgKz0gMC4yKnNpbig2LjAqdVRpbWUgLSA2LjAqcG9zLngpO1xyXG4gICAgXHJcbi8vICAgICAgICAgLy8gdGV4dHVyZSBjb29yZGluYXRlIGlzIGp1c3QgcG9zIGJ1dCB3aXRoaW4gMC0xIGluc3RlYWQgb2YgLTEgdG8gMS5cclxuLy8gICAgICAgICAvLyBTbyBzY2FsZSBpbiB0aGF0IHJhbmdlLlxyXG4vLyAgICAgICAgIHZUZXh0dXJlQ29vcmQgPSAocG9zLnh5KzEuKSowLjU7XHJcbi8vICAgICB9YCxcclxuLy8gICAgIGAjdmVyc2lvbiAzMDAgZXNcclxuLy8gICAgIGluIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcclxuICAgIFxyXG4vLyAgICAgb3V0IGhpZ2hwIHZlYzQgb3V0Q29sb3I7XHJcbiAgICBcclxuLy8gICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xyXG4gICAgXHJcbi8vICAgICB2b2lkIG1haW4oKVxyXG4vLyAgICAge1xyXG4vLyAgICAgICAgIC8vIG91dENvbG9yID0gdmVjNCh2VGV4dHVyZUNvb3JkLngsIDAuMCwgMC4wLCAxLjApO1xyXG4vLyAgICAgICAgIG91dENvbG9yID0gdGV4dHVyZSh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7Ly92ZWM0KDEsIDAsIDAuNSwgMSk7XHJcbi8vIH1gKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtpbml0Tm9ubGluZWFyVHJhbnNmb3JtLCB1bkluaXROb25saW5lYXJUcmFuc2Zvcm19O1xyXG5cclxuLy8gLy8gQ09ORSBNQVBcclxuLy8gd2luZG93LmluaXREaXN0b3J0aW9uKGAjdmVyc2lvbiAzMDAgZXNcclxuLy8gICAgIGluIGhpZ2hwIHZlYzQgcG9zO1xyXG4gICAgXHJcbi8vICAgICB1bmlmb3JtIGZsb2F0IHVUaW1lO1xyXG4gICAgXHJcbi8vICAgICBvdXQgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG4gICAgXHJcbi8vICAgICB2b2lkIG1haW4oKVxyXG4vLyAgICAge1xyXG4vLyAgICAgICAgIGZsb2F0IGFuZ2xlID0gYXRhbihwb3MueSwgcG9zLngpO1xyXG4vLyAgICAgICAgIGZsb2F0IGRpc3QgPSBzcXJ0KHBvcy55KnBvcy55ICsgcG9zLngqcG9zLngpO1xyXG5cclxuLy8gICAgICAgICAvLyBjYWxjdWxhdGluZyBtYXggZGlzdGFuY2UgYWxvbmcgdGhlIGFuZ2xlIGZyb20gdGhlIG9yaWdpbiB0byBlbmQgb2Ygc2NyZWVuXHJcblxyXG4vLyAgICAgICAgIGZsb2F0IHAgPSBtYXgoYWJzKGNvcyhhbmdsZSkpLCBhYnMoc2luKGFuZ2xlKSkpO1xyXG4vLyAgICAgICAgIC8vIGZsb2F0IG1heERpc3RBbG9uZ0FuZ2xlID0gMC41L3A7XHJcblxyXG4vLyAgICAgICAgIC8vIGFib3ZlIDIgbGluZXMgZXF1aXZhbGVudCB0bzpcclxuLy8gICAgICAgICBmbG9hdCB4ID0gY29zKGFuZ2xlKSAvIHA7XHJcbi8vICAgICAgICAgZmxvYXQgeSA9IHNpbihhbmdsZSkgLyBwO1xyXG4vLyAgICAgICAgIGZsb2F0IG1heERpc3RBbG9uZ0FuZ2xlID0gc3FydCh4KnggKyB5KnkpO1xyXG5cclxuLy8gICAgICAgICAvLyBqdXN0IHNldHRpbmcgeCx5IHRvIGdsX1Bvc2l0aW9uLnh5IHJlc3VsdHMgaW4gb3ZhbCBzaGFwZS4gV2hhdCB3ZSdyZSBkb2luZyBpcyBleHRydWRpbmcgdG8gM2QuXHJcbi8vICAgICAgICAgeCA9IGNvcyhhbmdsZSkgKiBkaXN0IC8gbWF4RGlzdEFsb25nQW5nbGU7XHJcbi8vICAgICAgICAgeSA9IHNpbihhbmdsZSkgKiBkaXN0IC8gbWF4RGlzdEFsb25nQW5nbGU7XHJcbi8vICAgICAgICAgZmxvYXQgeiA9IGRpc3QgLyBtYXhEaXN0QWxvbmdBbmdsZTtcclxuXHJcbi8vICAgICAgICAgZmxvYXQgYSA9IDIuO1xyXG4vLyAgICAgICAgIGZsb2F0IGIgPSAzLjE0LzQuO1xyXG5cclxuLy8gICAgICAgICBmbG9hdCBzYSA9IHNpbihhKTtcclxuLy8gICAgICAgICBmbG9hdCBzYiA9IHNpbihiKTtcclxuLy8gICAgICAgICBmbG9hdCBjYSA9IGNvcyhhKTtcclxuLy8gICAgICAgICBmbG9hdCBjYiA9IGNvcyhiKTtcclxuXHJcbi8vICAgICAgICAgZmxvYXQgY29uZVggPSB4ICogY2EgLSB5ICogc2E7XHJcbi8vICAgICAgICAgZmxvYXQgY29uZVkgPSAoeCAqIHNhICsgeSAqIGNhKSAqIHNiIC0geiAqIGNiO1xyXG5cclxuLy8gICAgICAgICBmbG9hdCB0ID0gdVRpbWUgLSBmbG9vcih1VGltZSk7XHJcblxyXG4vLyAgICAgICAgIGdsX1Bvc2l0aW9uID0gcG9zO1xyXG4vLyAgICAgICAgIGdsX1Bvc2l0aW9uLnggPSBjb25lWCAqIHQgKyBwb3MueCAqICgxLi10KTtcclxuLy8gICAgICAgICBnbF9Qb3NpdGlvbi55ID0gY29uZVkgKiB0ICsgcG9zLnkgKiAoMS4tdCkgKyAuNTtcclxuICAgIFxyXG4vLyAgICAgICAgIC8vIHRleHR1cmUgY29vcmRpbmF0ZSBpcyBqdXN0IHBvcyBidXQgd2l0aGluIDAtMSBpbnN0ZWFkIG9mIC0xIHRvIDEuXHJcbi8vICAgICAgICAgLy8gU28gc2NhbGUgaW4gdGhhdCByYW5nZS5cclxuLy8gICAgICAgICB2VGV4dHVyZUNvb3JkID0gKHBvcy54eSsxLikqMC41O1xyXG4vLyAgICAgfWAsXHJcbi8vICAgICBgI3ZlcnNpb24gMzAwIGVzXHJcbi8vICAgICBpbiBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XHJcbiAgICBcclxuLy8gICAgIG91dCBoaWdocCB2ZWM0IG91dENvbG9yO1xyXG4gICAgXHJcbi8vICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcclxuICAgIFxyXG4vLyAgICAgdm9pZCBtYWluKClcclxuLy8gICAgIHtcclxuLy8gICAgICAgICAvLyBvdXRDb2xvciA9IHZlYzQodlRleHR1cmVDb29yZC54LCAwLjAsIDAuMCwgMS4wKTtcclxuLy8gICAgICAgICBvdXRDb2xvciA9IHRleHR1cmUodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpOy8vdmVjNCgxLCAwLCAwLjUsIDEpO1xyXG4vLyB9YCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///964\n")}}]);