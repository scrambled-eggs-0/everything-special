"use strict";(self.webpackChunkomniserver=self.webpackChunkomniserver||[]).push([[964],{964:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// ONLY thing the api does is copy over the canvas to a webgl canvas\r\n// with shader effects. This means to draw anything we must draw it\r\n// on the canvas first and then do 1 draw call per each transformation.\r\n// This is the best even though drawing on webgl directly would be faster,\r\n// all our obstacles are tied to the canvas anyways and canvas can do pretty\r\n// much everything besides nonlinear transformations.\r\n\r\n// For the notable exception of doing something with some parameters not encoded\r\n// in the 2d image (e.g. z-coordinate) we should eventually implement a system\r\n// to add a buffer (see texCoordinates in serum's threedrenderer example)\r\n\r\nconst placeholder = document.getElementById('webglplaceholder');\r\nlet glCanvas;\r\n\r\nfunction initNonlinearTransform(vs, fs){\r\n    if(window.distortionsActive === true) unInitNonlinearTransform();\r\n    window.distortionsActive = true;\r\n\r\n    // set up canvas and resizing\r\n    glCanvas = document.createElement('canvas');\r\n    const gl = glCanvas.getContext('webgl2');\r\n    placeholder.appendChild(glCanvas);\r\n    \r\n    window.resizeWebGl = () => {\r\n        window.resizeElements([glCanvas]);\r\n        gl.viewport(0, 0, glCanvas.width, glCanvas.height);\r\n    }\r\n    window.resizeWebGl();\r\n    window.resizeFns.push(window.resizeWebGl);\r\n    \r\n    let vertexData = [];\r\n    let indicies = [];\r\n    \r\n    const jmp = 1;//10\r\n    const resX = Math.ceil(glCanvas.width / jmp);\r\n    const resY = Math.ceil(glCanvas.height / jmp);\r\n    \r\n    // forming verticies\r\n    for(let y = 0; y < resY; y++){\r\n        for(let x = 0; x < resX; x++){\r\n            // vertex positions in space. Scaled from -1 to 1\r\n            vertexData.push(\r\n                (x / (resX-1)) * 2 - 1,\r\n                (y / (resY-1)) * 2 - 1,\r\n            );\r\n        }\r\n    }\r\n    \r\n    // forming triangles\r\n    // we form triangles from y layer n to y layer n+1\r\n    for(let y = 0; y < resY-1; y++){\r\n        for(let x = 0; x < resX-1; x++){\r\n            const i = y * (resX) + x;\r\n            indicies.push(\r\n                i,\r\n                i+1,\r\n                i+resX,\r\n            );\r\n            indicies.push(\r\n                i+1,\r\n                i+resX,\r\n                i+resX+1,\r\n            );\r\n        }\r\n    }\r\n    \r\n    vertexData = new Float32Array(vertexData);\r\n    indicies = new Uint32Array(indicies);\r\n    \r\n    // Create vertex buffer\r\n    const vertexBuffer = gl.createBuffer();\r\n    {\r\n        // Bind buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\r\n    \r\n        // Feed vertex buffer with data\r\n        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);\r\n    }\r\n    \r\n    // Create index buffer\r\n    const indexBuffer = gl.createBuffer();\r\n    {\r\n        // Bind buffer\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    \r\n        // Feed index buffer with data\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicies, gl.STATIC_DRAW);\r\n    }\r\n    \r\n    // Use shader program\r\n    function createShaderProgram() {\r\n        function compileShader(str, type) {\r\n            // create shader\r\n            const shader = gl.createShader(type)\r\n        \r\n            // give it source code and compile\r\n            gl.shaderSource(shader, str);\r\n            gl.compileShader(shader)\r\n        \r\n            const errors = gl.getShaderInfoLog(shader)\r\n            if (errors.length != 0) {\r\n                console.log('Error Compiling Shader!');\r\n                console.log(errors);\r\n                return null;\r\n            }\r\n            else return shader;\r\n        }\r\n\r\n        // Create shader program\r\n        const program = gl.createProgram();\r\n    \r\n        // Attach vertex shader\r\n        const vertexShader = compileShader(vs, gl.VERTEX_SHADER)\r\n        gl.attachShader(program, vertexShader)\r\n    \r\n        // Attach fragment shader\r\n        const fragmentShader = compileShader(fs, gl.FRAGMENT_SHADER)\r\n        gl.attachShader(program, fragmentShader)\r\n    \r\n        // Link and validate program\r\n        gl.linkProgram(program);\r\n        gl.validateProgram(program);\r\n    \r\n        // Check for errors\r\n        const errors = gl.getProgramInfoLog(program)\r\n        if (errors.length !== 0) {\r\n            console.log('Error Compiling Program!');\r\n            console.log(errors);\r\n        }\r\n    \r\n        // Free GPU memory\r\n        gl.deleteShader(vertexShader);\r\n        gl.deleteShader(fragmentShader);\r\n    \r\n        return program;\r\n    }\r\n    const program = createShaderProgram();\r\n    \r\n    gl.useProgram(program);\r\n    \r\n    {// Specify locations of pos in the typed arrays\r\n        let posLocation = gl.getAttribLocation(program, \"pos\");\r\n        gl.enableVertexAttribArray(posLocation);\r\n        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT, 0);// for second to last 0\r\n    }\r\n    \r\n    // Texture\r\n    const texture = gl.createTexture();\r\n    updateTexture();\r\n    \r\n    function updateTexture(){\r\n        // use texture unit 0\r\n        gl.activeTexture(gl.TEXTURE0 + 0);\r\n    \r\n        // bind to the TEXTURE_2D bind point of texture unit 0\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\r\n    \r\n        // canvas is not a power of 2. If it was, it would be higher quality to do\r\n        // gl.generateMipmap(gl.TEXTURE_2D);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);// gl.LINEAR\r\n    }\r\n    \r\n    const uTime = gl.getUniformLocation(program, \"uTime\");\r\n    \r\n    //TODO: flipY gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n    window.renderGl = () => {\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n\r\n        // get new canvas data\r\n        updateTexture();\r\n    \r\n        // setup uniforms\r\n        let t = Date.now() / 1000;\r\n        t -= Math.floor(t/100)*100;\r\n        gl.uniform1f(uTime, t);\r\n        \r\n        gl.clearColor(0, 0, 0, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n    \r\n        gl.drawElements(gl.TRIANGLES,\r\n            indicies.length, // how many vertecies we want to draw\r\n            gl.UNSIGNED_INT, // Uint32 for created indicies array \r\n            0 // offset in index array (0 = start from beginning)\r\n        )\r\n    }\r\n}\r\n\r\nfunction unInitNonlinearTransform(){\r\n    if(window.distortionsActive === false) return;\r\n    window.resizeFns = window.resizeFns.filter(f => f !== window.resizeWebGl);\r\n    window.distortionsActive = false;\r\n    glCanvas.remove();\r\n}\r\n\r\n// window.initDistortion(`#version 300 es\r\n//     in highp vec4 pos;\r\n    \r\n//     uniform float uTime;\r\n    \r\n//     out highp vec2 vTextureCoord;\r\n    \r\n//     void main()\r\n//     {\r\n//         gl_Position = pos;\r\n//         gl_Position.x += 0.1*sin(6.0*uTime + 3.0*pos.y);\r\n//         gl_Position.y += 0.2*sin(6.0*uTime - 6.0*pos.x);\r\n    \r\n//         // texture coordinate is just pos but within 0-1 instead of -1 to 1.\r\n//         // So scale in that range.\r\n//         vTextureCoord = (pos.xy+1.)*0.5;\r\n//     }`,\r\n//     `#version 300 es\r\n//     in highp vec2 vTextureCoord;\r\n    \r\n//     out highp vec4 outColor;\r\n    \r\n//     uniform sampler2D uSampler;\r\n    \r\n//     void main()\r\n//     {\r\n//         // outColor = vec4(vTextureCoord.x, 0.0, 0.0, 1.0);\r\n//         outColor = texture(uSampler, vTextureCoord);//vec4(1, 0, 0.5, 1);\r\n// }`);\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({initNonlinearTransform, unInitNonlinearTransform});\r\n\r\n// // CONE MAP\r\n// window.initDistortion(`#version 300 es\r\n//     in highp vec4 pos;\r\n    \r\n//     uniform float uTime;\r\n    \r\n//     out highp vec2 vTextureCoord;\r\n    \r\n//     void main()\r\n//     {\r\n//         float angle = atan(pos.y, pos.x);\r\n//         float dist = sqrt(pos.y*pos.y + pos.x*pos.x);\r\n\r\n//         // calculating max distance along the angle from the origin to end of screen\r\n\r\n//         float p = max(abs(cos(angle)), abs(sin(angle)));\r\n//         // float maxDistAlongAngle = 0.5/p;\r\n\r\n//         // above 2 lines equivalent to:\r\n//         float x = cos(angle) / p;\r\n//         float y = sin(angle) / p;\r\n//         float maxDistAlongAngle = sqrt(x*x + y*y);\r\n\r\n//         // just setting x,y to gl_Position.xy results in oval shape. What we're doing is extruding to 3d.\r\n//         x = cos(angle) * dist / maxDistAlongAngle;\r\n//         y = sin(angle) * dist / maxDistAlongAngle;\r\n//         float z = dist / maxDistAlongAngle;\r\n\r\n//         float a = 2.;\r\n//         float b = 3.14/4.;\r\n\r\n//         float sa = sin(a);\r\n//         float sb = sin(b);\r\n//         float ca = cos(a);\r\n//         float cb = cos(b);\r\n\r\n//         float coneX = x * ca - y * sa;\r\n//         float coneY = (x * sa + y * ca) * sb - z * cb;\r\n\r\n//         float t = uTime - floor(uTime);\r\n\r\n//         gl_Position = pos;\r\n//         gl_Position.x = coneX * t + pos.x * (1.-t);\r\n//         gl_Position.y = coneY * t + pos.y * (1.-t) + .5;\r\n    \r\n//         // texture coordinate is just pos but within 0-1 instead of -1 to 1.\r\n//         // So scale in that range.\r\n//         vTextureCoord = (pos.xy+1.)*0.5;\r\n//     }`,\r\n//     `#version 300 es\r\n//     in highp vec2 vTextureCoord;\r\n    \r\n//     out highp vec4 outColor;\r\n    \r\n//     uniform sampler2D uSampler;\r\n    \r\n//     void main()\r\n//     {\r\n//         // outColor = vec4(vTextureCoord.x, 0.0, 0.0, 1.0);\r\n//         outColor = texture(uSampler, vTextureCoord);//vec4(1, 0, 0.5, 1);\r\n// }`);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb21uaXNlcnZlci8uL2VYY2xpZW50L2V4dHJhcy9kaXN0b3J0LmpzPzNlZjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT05MWSB0aGluZyB0aGUgYXBpIGRvZXMgaXMgY29weSBvdmVyIHRoZSBjYW52YXMgdG8gYSB3ZWJnbCBjYW52YXNcclxuLy8gd2l0aCBzaGFkZXIgZWZmZWN0cy4gVGhpcyBtZWFucyB0byBkcmF3IGFueXRoaW5nIHdlIG11c3QgZHJhdyBpdFxyXG4vLyBvbiB0aGUgY2FudmFzIGZpcnN0IGFuZCB0aGVuIGRvIDEgZHJhdyBjYWxsIHBlciBlYWNoIHRyYW5zZm9ybWF0aW9uLlxyXG4vLyBUaGlzIGlzIHRoZSBiZXN0IGV2ZW4gdGhvdWdoIGRyYXdpbmcgb24gd2ViZ2wgZGlyZWN0bHkgd291bGQgYmUgZmFzdGVyLFxyXG4vLyBhbGwgb3VyIG9ic3RhY2xlcyBhcmUgdGllZCB0byB0aGUgY2FudmFzIGFueXdheXMgYW5kIGNhbnZhcyBjYW4gZG8gcHJldHR5XHJcbi8vIG11Y2ggZXZlcnl0aGluZyBiZXNpZGVzIG5vbmxpbmVhciB0cmFuc2Zvcm1hdGlvbnMuXHJcblxyXG4vLyBGb3IgdGhlIG5vdGFibGUgZXhjZXB0aW9uIG9mIGRvaW5nIHNvbWV0aGluZyB3aXRoIHNvbWUgcGFyYW1ldGVycyBub3QgZW5jb2RlZFxyXG4vLyBpbiB0aGUgMmQgaW1hZ2UgKGUuZy4gei1jb29yZGluYXRlKSB3ZSBzaG91bGQgZXZlbnR1YWxseSBpbXBsZW1lbnQgYSBzeXN0ZW1cclxuLy8gdG8gYWRkIGEgYnVmZmVyIChzZWUgdGV4Q29vcmRpbmF0ZXMgaW4gc2VydW0ncyB0aHJlZWRyZW5kZXJlciBleGFtcGxlKVxyXG5cclxuY29uc3QgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2ViZ2xwbGFjZWhvbGRlcicpO1xyXG5sZXQgZ2xDYW52YXM7XHJcblxyXG5mdW5jdGlvbiBpbml0Tm9ubGluZWFyVHJhbnNmb3JtKHZzLCBmcyl7XHJcbiAgICBpZih3aW5kb3cuZGlzdG9ydGlvbnNBY3RpdmUgPT09IHRydWUpIHVuSW5pdE5vbmxpbmVhclRyYW5zZm9ybSgpO1xyXG4gICAgd2luZG93LmRpc3RvcnRpb25zQWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBzZXQgdXAgY2FudmFzIGFuZCByZXNpemluZ1xyXG4gICAgZ2xDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgIGNvbnN0IGdsID0gZ2xDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJyk7XHJcbiAgICBwbGFjZWhvbGRlci5hcHBlbmRDaGlsZChnbENhbnZhcyk7XHJcbiAgICBcclxuICAgIHdpbmRvdy5yZXNpemVXZWJHbCA9ICgpID0+IHtcclxuICAgICAgICB3aW5kb3cucmVzaXplRWxlbWVudHMoW2dsQ2FudmFzXSk7XHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2xDYW52YXMud2lkdGgsIGdsQ2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICB3aW5kb3cucmVzaXplV2ViR2woKTtcclxuICAgIHdpbmRvdy5yZXNpemVGbnMucHVzaCh3aW5kb3cucmVzaXplV2ViR2wpO1xyXG4gICAgXHJcbiAgICBsZXQgdmVydGV4RGF0YSA9IFtdO1xyXG4gICAgbGV0IGluZGljaWVzID0gW107XHJcbiAgICBcclxuICAgIGNvbnN0IGptcCA9IDE7Ly8xMFxyXG4gICAgY29uc3QgcmVzWCA9IE1hdGguY2VpbChnbENhbnZhcy53aWR0aCAvIGptcCk7XHJcbiAgICBjb25zdCByZXNZID0gTWF0aC5jZWlsKGdsQ2FudmFzLmhlaWdodCAvIGptcCk7XHJcbiAgICBcclxuICAgIC8vIGZvcm1pbmcgdmVydGljaWVzXHJcbiAgICBmb3IobGV0IHkgPSAwOyB5IDwgcmVzWTsgeSsrKXtcclxuICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgcmVzWDsgeCsrKXtcclxuICAgICAgICAgICAgLy8gdmVydGV4IHBvc2l0aW9ucyBpbiBzcGFjZS4gU2NhbGVkIGZyb20gLTEgdG8gMVxyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhLnB1c2goXHJcbiAgICAgICAgICAgICAgICAoeCAvIChyZXNYLTEpKSAqIDIgLSAxLFxyXG4gICAgICAgICAgICAgICAgKHkgLyAocmVzWS0xKSkgKiAyIC0gMSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIGZvcm1pbmcgdHJpYW5nbGVzXHJcbiAgICAvLyB3ZSBmb3JtIHRyaWFuZ2xlcyBmcm9tIHkgbGF5ZXIgbiB0byB5IGxheWVyIG4rMVxyXG4gICAgZm9yKGxldCB5ID0gMDsgeSA8IHJlc1ktMTsgeSsrKXtcclxuICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgcmVzWC0xOyB4Kyspe1xyXG4gICAgICAgICAgICBjb25zdCBpID0geSAqIChyZXNYKSArIHg7XHJcbiAgICAgICAgICAgIGluZGljaWVzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgaSsxLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpbmRpY2llcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgaSsxLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYKzEsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhEYXRhKTtcclxuICAgIGluZGljaWVzID0gbmV3IFVpbnQzMkFycmF5KGluZGljaWVzKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIHZlcnRleCBidWZmZXJcclxuICAgIGNvbnN0IHZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAge1xyXG4gICAgICAgIC8vIEJpbmQgYnVmZmVyXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcilcclxuICAgIFxyXG4gICAgICAgIC8vIEZlZWQgdmVydGV4IGJ1ZmZlciB3aXRoIGRhdGFcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgaW5kZXggYnVmZmVyXHJcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAge1xyXG4gICAgICAgIC8vIEJpbmQgYnVmZmVyXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXIpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gRmVlZCBpbmRleCBidWZmZXIgd2l0aCBkYXRhXHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNpZXMsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVXNlIHNoYWRlciBwcm9ncmFtXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTaGFkZXJQcm9ncmFtKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoc3RyLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzaGFkZXJcclxuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIGdpdmUgaXQgc291cmNlIGNvZGUgYW5kIGNvbXBpbGVcclxuICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3RyKTtcclxuICAgICAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKVxyXG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgQ29tcGlsaW5nIFNoYWRlciEnKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBzaGFkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgc2hhZGVyIHByb2dyYW1cclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQXR0YWNoIHZlcnRleCBzaGFkZXJcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKHZzLCBnbC5WRVJURVhfU0hBREVSKVxyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpXHJcbiAgICBcclxuICAgICAgICAvLyBBdHRhY2ggZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGZzLCBnbC5GUkFHTUVOVF9TSEFERVIpXHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxyXG4gICAgXHJcbiAgICAgICAgLy8gTGluayBhbmQgdmFsaWRhdGUgcHJvZ3JhbVxyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGZvciBlcnJvcnNcclxuICAgICAgICBjb25zdCBlcnJvcnMgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKVxyXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBDb21waWxpbmcgUHJvZ3JhbSEnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBGcmVlIEdQVSBtZW1vcnlcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbSgpO1xyXG4gICAgXHJcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgXHJcbiAgICB7Ly8gU3BlY2lmeSBsb2NhdGlvbnMgb2YgcG9zIGluIHRoZSB0eXBlZCBhcnJheXNcclxuICAgICAgICBsZXQgcG9zTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcInBvc1wiKTtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NMb2NhdGlvbik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAwKTsvLyBmb3Igc2Vjb25kIHRvIGxhc3QgMFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBUZXh0dXJlXHJcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgdXBkYXRlVGV4dHVyZSgpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVUZXh0dXJlKCl7XHJcbiAgICAgICAgLy8gdXNlIHRleHR1cmUgdW5pdCAwXHJcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIDApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gYmluZCB0byB0aGUgVEVYVFVSRV8yRCBiaW5kIHBvaW50IG9mIHRleHR1cmUgdW5pdCAwXHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBjYW52YXMpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gY2FudmFzIGlzIG5vdCBhIHBvd2VyIG9mIDIuIElmIGl0IHdhcywgaXQgd291bGQgYmUgaGlnaGVyIHF1YWxpdHkgdG8gZG9cclxuICAgICAgICAvLyBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7Ly8gZ2wuTElORUFSXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHVUaW1lID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidVRpbWVcIik7XHJcbiAgICBcclxuICAgIC8vVE9ETzogZmxpcFkgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XHJcbiAgICB3aW5kb3cucmVuZGVyR2wgPSAoKSA9PiB7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIGdldCBuZXcgY2FudmFzIGRhdGFcclxuICAgICAgICB1cGRhdGVUZXh0dXJlKCk7XHJcbiAgICBcclxuICAgICAgICAvLyBzZXR1cCB1bmlmb3Jtc1xyXG4gICAgICAgIGxldCB0ID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcbiAgICAgICAgdCAtPSBNYXRoLmZsb29yKHQvMTAwKSoxMDA7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVUaW1lLCB0KTtcclxuICAgICAgICBcclxuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEuMCk7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICBcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLFxyXG4gICAgICAgICAgICBpbmRpY2llcy5sZW5ndGgsIC8vIGhvdyBtYW55IHZlcnRlY2llcyB3ZSB3YW50IHRvIGRyYXdcclxuICAgICAgICAgICAgZ2wuVU5TSUdORURfSU5ULCAvLyBVaW50MzIgZm9yIGNyZWF0ZWQgaW5kaWNpZXMgYXJyYXkgXHJcbiAgICAgICAgICAgIDAgLy8gb2Zmc2V0IGluIGluZGV4IGFycmF5ICgwID0gc3RhcnQgZnJvbSBiZWdpbm5pbmcpXHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1bkluaXROb25saW5lYXJUcmFuc2Zvcm0oKXtcclxuICAgIGlmKHdpbmRvdy5kaXN0b3J0aW9uc0FjdGl2ZSA9PT0gZmFsc2UpIHJldHVybjtcclxuICAgIHdpbmRvdy5yZXNpemVGbnMgPSB3aW5kb3cucmVzaXplRm5zLmZpbHRlcihmID0+IGYgIT09IHdpbmRvdy5yZXNpemVXZWJHbCk7XHJcbiAgICB3aW5kb3cuZGlzdG9ydGlvbnNBY3RpdmUgPSBmYWxzZTtcclxuICAgIGdsQ2FudmFzLnJlbW92ZSgpO1xyXG59XHJcblxyXG4vLyB3aW5kb3cuaW5pdERpc3RvcnRpb24oYCN2ZXJzaW9uIDMwMCBlc1xyXG4vLyAgICAgaW4gaGlnaHAgdmVjNCBwb3M7XHJcbiAgICBcclxuLy8gICAgIHVuaWZvcm0gZmxvYXQgdVRpbWU7XHJcbiAgICBcclxuLy8gICAgIG91dCBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XHJcbiAgICBcclxuLy8gICAgIHZvaWQgbWFpbigpXHJcbi8vICAgICB7XHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24gPSBwb3M7XHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24ueCArPSAwLjEqc2luKDYuMCp1VGltZSArIDMuMCpwb3MueSk7XHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24ueSArPSAwLjIqc2luKDYuMCp1VGltZSAtIDYuMCpwb3MueCk7XHJcbiAgICBcclxuLy8gICAgICAgICAvLyB0ZXh0dXJlIGNvb3JkaW5hdGUgaXMganVzdCBwb3MgYnV0IHdpdGhpbiAwLTEgaW5zdGVhZCBvZiAtMSB0byAxLlxyXG4vLyAgICAgICAgIC8vIFNvIHNjYWxlIGluIHRoYXQgcmFuZ2UuXHJcbi8vICAgICAgICAgdlRleHR1cmVDb29yZCA9IChwb3MueHkrMS4pKjAuNTtcclxuLy8gICAgIH1gLFxyXG4vLyAgICAgYCN2ZXJzaW9uIDMwMCBlc1xyXG4vLyAgICAgaW4gaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG4gICAgXHJcbi8vICAgICBvdXQgaGlnaHAgdmVjNCBvdXRDb2xvcjtcclxuICAgIFxyXG4vLyAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XHJcbiAgICBcclxuLy8gICAgIHZvaWQgbWFpbigpXHJcbi8vICAgICB7XHJcbi8vICAgICAgICAgLy8gb3V0Q29sb3IgPSB2ZWM0KHZUZXh0dXJlQ29vcmQueCwgMC4wLCAwLjAsIDEuMCk7XHJcbi8vICAgICAgICAgb3V0Q29sb3IgPSB0ZXh0dXJlKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsvL3ZlYzQoMSwgMCwgMC41LCAxKTtcclxuLy8gfWApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2luaXROb25saW5lYXJUcmFuc2Zvcm0sIHVuSW5pdE5vbmxpbmVhclRyYW5zZm9ybX07XHJcblxyXG4vLyAvLyBDT05FIE1BUFxyXG4vLyB3aW5kb3cuaW5pdERpc3RvcnRpb24oYCN2ZXJzaW9uIDMwMCBlc1xyXG4vLyAgICAgaW4gaGlnaHAgdmVjNCBwb3M7XHJcbiAgICBcclxuLy8gICAgIHVuaWZvcm0gZmxvYXQgdVRpbWU7XHJcbiAgICBcclxuLy8gICAgIG91dCBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XHJcbiAgICBcclxuLy8gICAgIHZvaWQgbWFpbigpXHJcbi8vICAgICB7XHJcbi8vICAgICAgICAgZmxvYXQgYW5nbGUgPSBhdGFuKHBvcy55LCBwb3MueCk7XHJcbi8vICAgICAgICAgZmxvYXQgZGlzdCA9IHNxcnQocG9zLnkqcG9zLnkgKyBwb3MueCpwb3MueCk7XHJcblxyXG4vLyAgICAgICAgIC8vIGNhbGN1bGF0aW5nIG1heCBkaXN0YW5jZSBhbG9uZyB0aGUgYW5nbGUgZnJvbSB0aGUgb3JpZ2luIHRvIGVuZCBvZiBzY3JlZW5cclxuXHJcbi8vICAgICAgICAgZmxvYXQgcCA9IG1heChhYnMoY29zKGFuZ2xlKSksIGFicyhzaW4oYW5nbGUpKSk7XHJcbi8vICAgICAgICAgLy8gZmxvYXQgbWF4RGlzdEFsb25nQW5nbGUgPSAwLjUvcDtcclxuXHJcbi8vICAgICAgICAgLy8gYWJvdmUgMiBsaW5lcyBlcXVpdmFsZW50IHRvOlxyXG4vLyAgICAgICAgIGZsb2F0IHggPSBjb3MoYW5nbGUpIC8gcDtcclxuLy8gICAgICAgICBmbG9hdCB5ID0gc2luKGFuZ2xlKSAvIHA7XHJcbi8vICAgICAgICAgZmxvYXQgbWF4RGlzdEFsb25nQW5nbGUgPSBzcXJ0KHgqeCArIHkqeSk7XHJcblxyXG4vLyAgICAgICAgIC8vIGp1c3Qgc2V0dGluZyB4LHkgdG8gZ2xfUG9zaXRpb24ueHkgcmVzdWx0cyBpbiBvdmFsIHNoYXBlLiBXaGF0IHdlJ3JlIGRvaW5nIGlzIGV4dHJ1ZGluZyB0byAzZC5cclxuLy8gICAgICAgICB4ID0gY29zKGFuZ2xlKSAqIGRpc3QgLyBtYXhEaXN0QWxvbmdBbmdsZTtcclxuLy8gICAgICAgICB5ID0gc2luKGFuZ2xlKSAqIGRpc3QgLyBtYXhEaXN0QWxvbmdBbmdsZTtcclxuLy8gICAgICAgICBmbG9hdCB6ID0gZGlzdCAvIG1heERpc3RBbG9uZ0FuZ2xlO1xyXG5cclxuLy8gICAgICAgICBmbG9hdCBhID0gMi47XHJcbi8vICAgICAgICAgZmxvYXQgYiA9IDMuMTQvNC47XHJcblxyXG4vLyAgICAgICAgIGZsb2F0IHNhID0gc2luKGEpO1xyXG4vLyAgICAgICAgIGZsb2F0IHNiID0gc2luKGIpO1xyXG4vLyAgICAgICAgIGZsb2F0IGNhID0gY29zKGEpO1xyXG4vLyAgICAgICAgIGZsb2F0IGNiID0gY29zKGIpO1xyXG5cclxuLy8gICAgICAgICBmbG9hdCBjb25lWCA9IHggKiBjYSAtIHkgKiBzYTtcclxuLy8gICAgICAgICBmbG9hdCBjb25lWSA9ICh4ICogc2EgKyB5ICogY2EpICogc2IgLSB6ICogY2I7XHJcblxyXG4vLyAgICAgICAgIGZsb2F0IHQgPSB1VGltZSAtIGZsb29yKHVUaW1lKTtcclxuXHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24gPSBwb3M7XHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24ueCA9IGNvbmVYICogdCArIHBvcy54ICogKDEuLXQpO1xyXG4vLyAgICAgICAgIGdsX1Bvc2l0aW9uLnkgPSBjb25lWSAqIHQgKyBwb3MueSAqICgxLi10KSArIC41O1xyXG4gICAgXHJcbi8vICAgICAgICAgLy8gdGV4dHVyZSBjb29yZGluYXRlIGlzIGp1c3QgcG9zIGJ1dCB3aXRoaW4gMC0xIGluc3RlYWQgb2YgLTEgdG8gMS5cclxuLy8gICAgICAgICAvLyBTbyBzY2FsZSBpbiB0aGF0IHJhbmdlLlxyXG4vLyAgICAgICAgIHZUZXh0dXJlQ29vcmQgPSAocG9zLnh5KzEuKSowLjU7XHJcbi8vICAgICB9YCxcclxuLy8gICAgIGAjdmVyc2lvbiAzMDAgZXNcclxuLy8gICAgIGluIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcclxuICAgIFxyXG4vLyAgICAgb3V0IGhpZ2hwIHZlYzQgb3V0Q29sb3I7XHJcbiAgICBcclxuLy8gICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xyXG4gICAgXHJcbi8vICAgICB2b2lkIG1haW4oKVxyXG4vLyAgICAge1xyXG4vLyAgICAgICAgIC8vIG91dENvbG9yID0gdmVjNCh2VGV4dHVyZUNvb3JkLngsIDAuMCwgMC4wLCAxLjApO1xyXG4vLyAgICAgICAgIG91dENvbG9yID0gdGV4dHVyZSh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7Ly92ZWM0KDEsIDAsIDAuNSwgMSk7XHJcbi8vIH1gKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///964\n")}}]);