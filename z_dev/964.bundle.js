"use strict";(self.webpackChunkomniserver=self.webpackChunkomniserver||[]).push([[964],{964:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(763);\n// ONLY thing the api does is copy over the canvas to a webgl canvas\r\n// with shader effects. This means to draw anything we must draw it\r\n// on the canvas first and then do 1 draw call per each transformation.\r\n// This is the best even though drawing on webgl directly would be faster,\r\n// all our obstacles are tied to the canvas anyways and canvas can do pretty\r\n// much everything besides nonlinear transformations.\r\n\r\n// For the notable exception of doing something with some parameters not encoded\r\n// in the 2d image (e.g. z-coordinate) we should eventually implement a system\r\n// to add a buffer (see texCoordinates in serum\'s threedrenderer example)\r\n\r\n\r\n\r\nconst placeholder = document.getElementById(\'webglplaceholder\');\r\nlet glCanvas, storedDrawImg;\r\nfunction initNonlinearTransform(vs, fs, uniformNames, uniformLambdas){\r\n    if(_shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.distortionsActive === true) unInitNonlinearTransform();\r\n    if(isTainted(window.ctx) === true) _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.unTaintCanvas();\r\n    storedDrawImg = ctx.drawImage;\r\n    ctx.drawImage = () => {};\r\n    _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.distortionsActive = true;\r\n\r\n    // set up canvas and resizing\r\n    glCanvas = document.createElement(\'canvas\');\r\n    const gl = glCanvas.getContext(\'webgl2\');\r\n    placeholder.appendChild(glCanvas);\r\n    \r\n    _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.resizeWebGl = () => {\r\n        glCanvas.width = window.innerWidth;\r\n        glCanvas.height = window.innerHeight;\r\n        gl.viewport(0, 0, glCanvas.width, glCanvas.height);\r\n    }\r\n    _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.resizeWebGl();\r\n    _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.resizeFns.push(_shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.resizeWebGl);\r\n    \r\n    let vertexData = [];\r\n    let indicies = [];\r\n    \r\n    const jmp = 1;//10\r\n    const resX = Math.ceil(glCanvas.width / jmp);\r\n    const resY = Math.ceil(glCanvas.height / jmp);\r\n    \r\n    // forming verticies\r\n    for(let y = 0; y < resY; y++){\r\n        for(let x = 0; x < resX; x++){\r\n            // vertex positions in space. Scaled from -1 to 1\r\n            vertexData.push(\r\n                (x / (resX-1)) * 2 - 1,\r\n                (y / (resY-1)) * 2 - 1,\r\n            );\r\n        }\r\n    }\r\n    \r\n    // forming triangles\r\n    // we form triangles from y layer n to y layer n+1\r\n    for(let y = 0; y < resY-1; y++){\r\n        for(let x = 0; x < resX-1; x++){\r\n            const i = y * (resX) + x;\r\n            indicies.push(\r\n                i,\r\n                i+1,\r\n                i+resX,\r\n            );\r\n            indicies.push(\r\n                i+1,\r\n                i+resX,\r\n                i+resX+1,\r\n            );\r\n        }\r\n    }\r\n    \r\n    vertexData = new Float32Array(vertexData);\r\n    indicies = new Uint32Array(indicies);\r\n    \r\n    // Create vertex buffer\r\n    const vertexBuffer = gl.createBuffer();\r\n    {\r\n        // Bind buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\r\n    \r\n        // Feed vertex buffer with data\r\n        gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);\r\n    }\r\n    \r\n    // Create index buffer\r\n    const indexBuffer = gl.createBuffer();\r\n    {\r\n        // Bind buffer\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n    \r\n        // Feed index buffer with data\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indicies, gl.STATIC_DRAW);\r\n    }\r\n    \r\n    // Use shader program\r\n    function createShaderProgram() {\r\n        function compileShader(str, type) {\r\n            // create shader\r\n            const shader = gl.createShader(type)\r\n        \r\n            // give it source code and compile\r\n            gl.shaderSource(shader, str);\r\n            gl.compileShader(shader)\r\n        \r\n            const errors = gl.getShaderInfoLog(shader)\r\n            if (errors.length != 0) {\r\n                console.log(\'Error Compiling Shader!\');\r\n                console.log(errors);\r\n                return null;\r\n            }\r\n            else return shader;\r\n        }\r\n\r\n        // Create shader program\r\n        const program = gl.createProgram();\r\n    \r\n        // Attach vertex shader\r\n        const vertexShader = compileShader(vs, gl.VERTEX_SHADER)\r\n        gl.attachShader(program, vertexShader)\r\n    \r\n        // Attach fragment shader\r\n        const fragmentShader = compileShader(fs, gl.FRAGMENT_SHADER)\r\n        gl.attachShader(program, fragmentShader)\r\n    \r\n        // Link and validate program\r\n        gl.linkProgram(program);\r\n        gl.validateProgram(program);\r\n    \r\n        // Check for errors\r\n        const errors = gl.getProgramInfoLog(program)\r\n        if (errors.length !== 0) {\r\n            console.log(\'Error Compiling Program!\');\r\n            console.log(errors);\r\n        }\r\n    \r\n        // Free GPU memory\r\n        gl.deleteShader(vertexShader);\r\n        gl.deleteShader(fragmentShader);\r\n    \r\n        return program;\r\n    }\r\n    const program = createShaderProgram();\r\n    \r\n    gl.useProgram(program);\r\n    \r\n    {// Specify locations of pos in the typed arrays\r\n        let posLocation = gl.getAttribLocation(program, "pos");\r\n        gl.enableVertexAttribArray(posLocation);\r\n        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT, 0);// for second to last 0\r\n    }\r\n    \r\n    function updateTexture(){\r\n        // use texture unit 0\r\n        gl.activeTexture(gl.TEXTURE0 + 0);\r\n    \r\n        // bind to the TEXTURE_2D bind point of texture unit 0\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, window.canvas);\r\n    \r\n        // canvas is not a power of 2. If it was, it would be higher quality to do\r\n        // gl.generateMipmap(gl.TEXTURE_2D);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);// gl.LINEAR\r\n    }\r\n\r\n    // Texture\r\n    const texture = gl.createTexture();\r\n    updateTexture();\r\n\r\n    const uniforms = [];\r\n    for(let i = 0; i < uniformNames.length; i++){\r\n        uniforms.push(gl.getUniformLocation(program, uniformNames[i]));\r\n    }\r\n    \r\n    _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.renderGl = () => {\r\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n\r\n        // get new canvas data\r\n        updateTexture();\r\n    \r\n        // setup uniforms\r\n        for(let i = 0; i < uniformLambdas.length; i++){\r\n            gl.uniform1f(uniforms[i], uniformLambdas[i]());\r\n        }\r\n        // let t = Date.now() / 1000;\r\n        // t -= Math.floor(t/100)*100;\r\n        // gl.uniform1f(uTime, t);\r\n        \r\n        gl.clearColor(0, 0, 0, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n    \r\n        gl.drawElements(gl.TRIANGLES,\r\n            indicies.length, // how many vertecies we want to draw\r\n            gl.UNSIGNED_INT, // Uint32 for created indicies array \r\n            0 // offset in index array (0 = start from beginning)\r\n        )\r\n    }\r\n}\r\n\r\nfunction unInitNonlinearTransform(){\r\n    if(_shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.distortionsActive === false) return;\r\n    window.ctx.drawImage = storedDrawImg;\r\n    _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.resizeFns = _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.resizeFns.filter(f => f !== _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.resizeWebGl);\r\n    _shared_shared_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.distortionsActive = false;\r\n    glCanvas.remove();\r\n}\r\n\r\nfunction isTainted(ctx) {\r\n    try {\r\n        ctx.getImageData(0, 0, 1, 1);\r\n        return false;\r\n    } catch(err) {\r\n        return (err.code === 18);\r\n    }\r\n}\r\n\r\n// s.initDistortion(`#version 300 es\r\n//     in highp vec4 pos;\r\n    \r\n//     uniform float uTime;\r\n    \r\n//     out highp vec2 vTextureCoord;\r\n    \r\n//     void main()\r\n//     {\r\n//         gl_Position = pos;\r\n//         gl_Position.x += 0.1*sin(6.0*uTime + 3.0*pos.y);\r\n//         gl_Position.y += 0.2*sin(6.0*uTime - 6.0*pos.x);\r\n    \r\n//         // texture coordinate is just pos but within 0-1 instead of -1 to 1.\r\n//         // So scale in that range.\r\n//         vTextureCoord = (pos.xy+1.)*0.5;\r\n//     }`,\r\n//     `#version 300 es\r\n//     in highp vec2 vTextureCoord;\r\n    \r\n//     out highp vec4 outColor;\r\n    \r\n//     uniform sampler2D uSampler;\r\n    \r\n//     void main()\r\n//     {\r\n//         // outColor = vec4(vTextureCoord.x, 0.0, 0.0, 1.0);\r\n//         outColor = texture(uSampler, vTextureCoord);//vec4(1, 0, 0.5, 1);\r\n// }`, [\'uTime\'], [() => {return window.frames / 100}]);\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({initNonlinearTransform, unInitNonlinearTransform});\r\n\r\n// // CONE MAP\r\n// s.initDistortion(`#version 300 es\r\n//     in highp vec4 pos;\r\n    \r\n//     uniform float uTime;\r\n    \r\n//     out highp vec2 vTextureCoord;\r\n    \r\n//     void main()\r\n//     {\r\n//         float angle = atan(pos.y, pos.x);\r\n//         float dist = sqrt(pos.y*pos.y + pos.x*pos.x);\r\n\r\n//         // calculating max distance along the angle from the origin to end of screen\r\n\r\n//         float p = max(abs(cos(angle)), abs(sin(angle)));\r\n//         // float maxDistAlongAngle = 0.5/p;\r\n\r\n//         // above 2 lines equivalent to:\r\n//         float x = cos(angle) / p;\r\n//         float y = sin(angle) / p;\r\n//         float maxDistAlongAngle = sqrt(x*x + y*y);\r\n\r\n//         // just setting x,y to gl_Position.xy results in oval shape. What we\'re doing is extruding to 3d.\r\n//         x = cos(angle) * dist / maxDistAlongAngle;\r\n//         y = sin(angle) * dist / maxDistAlongAngle;\r\n//         float z = dist / maxDistAlongAngle;\r\n\r\n//         float a = 2.;\r\n//         float b = 3.14/4.;\r\n\r\n//         float sa = sin(a);\r\n//         float sb = sin(b);\r\n//         float ca = cos(a);\r\n//         float cb = cos(b);\r\n\r\n//         float coneX = x * ca - y * sa;\r\n//         float coneY = (x * sa + y * ca) * sb - z * cb;\r\n\r\n//         float t = uTime - floor(uTime);\r\n\r\n//         gl_Position = pos;\r\n//         gl_Position.x = coneX * t + pos.x * (1.-t);\r\n//         gl_Position.y = coneY * t + pos.y * (1.-t) + .5;\r\n    \r\n//         // texture coordinate is just pos but within 0-1 instead of -1 to 1.\r\n//         // So scale in that range.\r\n//         vTextureCoord = (pos.xy+1.)*0.5;\r\n//     }`,\r\n//     `#version 300 es\r\n//     in highp vec2 vTextureCoord;\r\n    \r\n//     out highp vec4 outColor;\r\n    \r\n//     uniform sampler2D uSampler;\r\n    \r\n//     void main()\r\n//     {\r\n//         // outColor = vec4(vTextureCoord.x, 0.0, 0.0, 1.0);\r\n//         outColor = texture(uSampler, vTextureCoord);//vec4(1, 0, 0.5, 1);\r\n// }`);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbW5pc2VydmVyLy4vZVhjbGllbnQvZXh0cmFzL2Rpc3RvcnQuanM/MDEyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPTkxZIHRoaW5nIHRoZSBhcGkgZG9lcyBpcyBjb3B5IG92ZXIgdGhlIGNhbnZhcyB0byBhIHdlYmdsIGNhbnZhc1xyXG4vLyB3aXRoIHNoYWRlciBlZmZlY3RzLiBUaGlzIG1lYW5zIHRvIGRyYXcgYW55dGhpbmcgd2UgbXVzdCBkcmF3IGl0XHJcbi8vIG9uIHRoZSBjYW52YXMgZmlyc3QgYW5kIHRoZW4gZG8gMSBkcmF3IGNhbGwgcGVyIGVhY2ggdHJhbnNmb3JtYXRpb24uXHJcbi8vIFRoaXMgaXMgdGhlIGJlc3QgZXZlbiB0aG91Z2ggZHJhd2luZyBvbiB3ZWJnbCBkaXJlY3RseSB3b3VsZCBiZSBmYXN0ZXIsXHJcbi8vIGFsbCBvdXIgb2JzdGFjbGVzIGFyZSB0aWVkIHRvIHRoZSBjYW52YXMgYW55d2F5cyBhbmQgY2FudmFzIGNhbiBkbyBwcmV0dHlcclxuLy8gbXVjaCBldmVyeXRoaW5nIGJlc2lkZXMgbm9ubGluZWFyIHRyYW5zZm9ybWF0aW9ucy5cclxuXHJcbi8vIEZvciB0aGUgbm90YWJsZSBleGNlcHRpb24gb2YgZG9pbmcgc29tZXRoaW5nIHdpdGggc29tZSBwYXJhbWV0ZXJzIG5vdCBlbmNvZGVkXHJcbi8vIGluIHRoZSAyZCBpbWFnZSAoZS5nLiB6LWNvb3JkaW5hdGUpIHdlIHNob3VsZCBldmVudHVhbGx5IGltcGxlbWVudCBhIHN5c3RlbVxyXG4vLyB0byBhZGQgYSBidWZmZXIgKHNlZSB0ZXhDb29yZGluYXRlcyBpbiBzZXJ1bSdzIHRocmVlZHJlbmRlcmVyIGV4YW1wbGUpXHJcblxyXG5pbXBvcnQgc2hhcmVkIGZyb20gJy4uLy4uL3NoYXJlZC9zaGFyZWQuanMnO1xyXG5cclxuY29uc3QgcGxhY2Vob2xkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2ViZ2xwbGFjZWhvbGRlcicpO1xyXG5sZXQgZ2xDYW52YXMsIHN0b3JlZERyYXdJbWc7XHJcbmZ1bmN0aW9uIGluaXROb25saW5lYXJUcmFuc2Zvcm0odnMsIGZzLCB1bmlmb3JtTmFtZXMsIHVuaWZvcm1MYW1iZGFzKXtcclxuICAgIGlmKHNoYXJlZC5kaXN0b3J0aW9uc0FjdGl2ZSA9PT0gdHJ1ZSkgdW5Jbml0Tm9ubGluZWFyVHJhbnNmb3JtKCk7XHJcbiAgICBpZihpc1RhaW50ZWQod2luZG93LmN0eCkgPT09IHRydWUpIHNoYXJlZC51blRhaW50Q2FudmFzKCk7XHJcbiAgICBzdG9yZWREcmF3SW1nID0gY3R4LmRyYXdJbWFnZTtcclxuICAgIGN0eC5kcmF3SW1hZ2UgPSAoKSA9PiB7fTtcclxuICAgIHNoYXJlZC5kaXN0b3J0aW9uc0FjdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgLy8gc2V0IHVwIGNhbnZhcyBhbmQgcmVzaXppbmdcclxuICAgIGdsQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjb25zdCBnbCA9IGdsQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicpO1xyXG4gICAgcGxhY2Vob2xkZXIuYXBwZW5kQ2hpbGQoZ2xDYW52YXMpO1xyXG4gICAgXHJcbiAgICBzaGFyZWQucmVzaXplV2ViR2wgPSAoKSA9PiB7XHJcbiAgICAgICAgZ2xDYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICBnbENhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2xDYW52YXMud2lkdGgsIGdsQ2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBzaGFyZWQucmVzaXplV2ViR2woKTtcclxuICAgIHNoYXJlZC5yZXNpemVGbnMucHVzaChzaGFyZWQucmVzaXplV2ViR2wpO1xyXG4gICAgXHJcbiAgICBsZXQgdmVydGV4RGF0YSA9IFtdO1xyXG4gICAgbGV0IGluZGljaWVzID0gW107XHJcbiAgICBcclxuICAgIGNvbnN0IGptcCA9IDE7Ly8xMFxyXG4gICAgY29uc3QgcmVzWCA9IE1hdGguY2VpbChnbENhbnZhcy53aWR0aCAvIGptcCk7XHJcbiAgICBjb25zdCByZXNZID0gTWF0aC5jZWlsKGdsQ2FudmFzLmhlaWdodCAvIGptcCk7XHJcbiAgICBcclxuICAgIC8vIGZvcm1pbmcgdmVydGljaWVzXHJcbiAgICBmb3IobGV0IHkgPSAwOyB5IDwgcmVzWTsgeSsrKXtcclxuICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgcmVzWDsgeCsrKXtcclxuICAgICAgICAgICAgLy8gdmVydGV4IHBvc2l0aW9ucyBpbiBzcGFjZS4gU2NhbGVkIGZyb20gLTEgdG8gMVxyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhLnB1c2goXHJcbiAgICAgICAgICAgICAgICAoeCAvIChyZXNYLTEpKSAqIDIgLSAxLFxyXG4gICAgICAgICAgICAgICAgKHkgLyAocmVzWS0xKSkgKiAyIC0gMSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIGZvcm1pbmcgdHJpYW5nbGVzXHJcbiAgICAvLyB3ZSBmb3JtIHRyaWFuZ2xlcyBmcm9tIHkgbGF5ZXIgbiB0byB5IGxheWVyIG4rMVxyXG4gICAgZm9yKGxldCB5ID0gMDsgeSA8IHJlc1ktMTsgeSsrKXtcclxuICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgcmVzWC0xOyB4Kyspe1xyXG4gICAgICAgICAgICBjb25zdCBpID0geSAqIChyZXNYKSArIHg7XHJcbiAgICAgICAgICAgIGluZGljaWVzLnB1c2goXHJcbiAgICAgICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICAgICAgaSsxLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpbmRpY2llcy5wdXNoKFxyXG4gICAgICAgICAgICAgICAgaSsxLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYLFxyXG4gICAgICAgICAgICAgICAgaStyZXNYKzEsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhEYXRhKTtcclxuICAgIGluZGljaWVzID0gbmV3IFVpbnQzMkFycmF5KGluZGljaWVzKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIHZlcnRleCBidWZmZXJcclxuICAgIGNvbnN0IHZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAge1xyXG4gICAgICAgIC8vIEJpbmQgYnVmZmVyXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcilcclxuICAgIFxyXG4gICAgICAgIC8vIEZlZWQgdmVydGV4IGJ1ZmZlciB3aXRoIGRhdGFcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4RGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDcmVhdGUgaW5kZXggYnVmZmVyXHJcbiAgICBjb25zdCBpbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAge1xyXG4gICAgICAgIC8vIEJpbmQgYnVmZmVyXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXhCdWZmZXIpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gRmVlZCBpbmRleCBidWZmZXIgd2l0aCBkYXRhXHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNpZXMsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVXNlIHNoYWRlciBwcm9ncmFtXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVTaGFkZXJQcm9ncmFtKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoc3RyLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBzaGFkZXJcclxuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIGdpdmUgaXQgc291cmNlIGNvZGUgYW5kIGNvbXBpbGVcclxuICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3RyKTtcclxuICAgICAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpXHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKVxyXG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgQ29tcGlsaW5nIFNoYWRlciEnKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBzaGFkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgc2hhZGVyIHByb2dyYW1cclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgXHJcbiAgICAgICAgLy8gQXR0YWNoIHZlcnRleCBzaGFkZXJcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKHZzLCBnbC5WRVJURVhfU0hBREVSKVxyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpXHJcbiAgICBcclxuICAgICAgICAvLyBBdHRhY2ggZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGZzLCBnbC5GUkFHTUVOVF9TSEFERVIpXHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxyXG4gICAgXHJcbiAgICAgICAgLy8gTGluayBhbmQgdmFsaWRhdGUgcHJvZ3JhbVxyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGdsLnZhbGlkYXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGZvciBlcnJvcnNcclxuICAgICAgICBjb25zdCBlcnJvcnMgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKVxyXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBDb21waWxpbmcgUHJvZ3JhbSEnKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBGcmVlIEdQVSBtZW1vcnlcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgXHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9ncmFtID0gY3JlYXRlU2hhZGVyUHJvZ3JhbSgpO1xyXG4gICAgXHJcbiAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgXHJcbiAgICB7Ly8gU3BlY2lmeSBsb2NhdGlvbnMgb2YgcG9zIGluIHRoZSB0eXBlZCBhcnJheXNcclxuICAgICAgICBsZXQgcG9zTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcInBvc1wiKTtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NMb2NhdGlvbik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAwKTsvLyBmb3Igc2Vjb25kIHRvIGxhc3QgMFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVUZXh0dXJlKCl7XHJcbiAgICAgICAgLy8gdXNlIHRleHR1cmUgdW5pdCAwXHJcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIDApO1xyXG4gICAgXHJcbiAgICAgICAgLy8gYmluZCB0byB0aGUgVEVYVFVSRV8yRCBiaW5kIHBvaW50IG9mIHRleHR1cmUgdW5pdCAwXHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB3aW5kb3cuY2FudmFzKTtcclxuICAgIFxyXG4gICAgICAgIC8vIGNhbnZhcyBpcyBub3QgYSBwb3dlciBvZiAyLiBJZiBpdCB3YXMsIGl0IHdvdWxkIGJlIGhpZ2hlciBxdWFsaXR5IHRvIGRvXHJcbiAgICAgICAgLy8gZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpOy8vIGdsLkxJTkVBUlxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRleHR1cmVcclxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICB1cGRhdGVUZXh0dXJlKCk7XHJcblxyXG4gICAgY29uc3QgdW5pZm9ybXMgPSBbXTtcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB1bmlmb3JtTmFtZXMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHVuaWZvcm1zLnB1c2goZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lc1tpXSkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzaGFyZWQucmVuZGVyR2wgPSAoKSA9PiB7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIGdldCBuZXcgY2FudmFzIGRhdGFcclxuICAgICAgICB1cGRhdGVUZXh0dXJlKCk7XHJcbiAgICBcclxuICAgICAgICAvLyBzZXR1cCB1bmlmb3Jtc1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB1bmlmb3JtTGFtYmRhcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3Jtc1tpXSwgdW5pZm9ybUxhbWJkYXNbaV0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxldCB0ID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcbiAgICAgICAgLy8gdCAtPSBNYXRoLmZsb29yKHQvMTAwKSoxMDA7XHJcbiAgICAgICAgLy8gZ2wudW5pZm9ybTFmKHVUaW1lLCB0KTtcclxuICAgICAgICBcclxuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDEuMCk7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICBcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLFxyXG4gICAgICAgICAgICBpbmRpY2llcy5sZW5ndGgsIC8vIGhvdyBtYW55IHZlcnRlY2llcyB3ZSB3YW50IHRvIGRyYXdcclxuICAgICAgICAgICAgZ2wuVU5TSUdORURfSU5ULCAvLyBVaW50MzIgZm9yIGNyZWF0ZWQgaW5kaWNpZXMgYXJyYXkgXHJcbiAgICAgICAgICAgIDAgLy8gb2Zmc2V0IGluIGluZGV4IGFycmF5ICgwID0gc3RhcnQgZnJvbSBiZWdpbm5pbmcpXHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1bkluaXROb25saW5lYXJUcmFuc2Zvcm0oKXtcclxuICAgIGlmKHNoYXJlZC5kaXN0b3J0aW9uc0FjdGl2ZSA9PT0gZmFsc2UpIHJldHVybjtcclxuICAgIHdpbmRvdy5jdHguZHJhd0ltYWdlID0gc3RvcmVkRHJhd0ltZztcclxuICAgIHNoYXJlZC5yZXNpemVGbnMgPSBzaGFyZWQucmVzaXplRm5zLmZpbHRlcihmID0+IGYgIT09IHNoYXJlZC5yZXNpemVXZWJHbCk7XHJcbiAgICBzaGFyZWQuZGlzdG9ydGlvbnNBY3RpdmUgPSBmYWxzZTtcclxuICAgIGdsQ2FudmFzLnJlbW92ZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1RhaW50ZWQoY3R4KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICByZXR1cm4gKGVyci5jb2RlID09PSAxOCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIHMuaW5pdERpc3RvcnRpb24oYCN2ZXJzaW9uIDMwMCBlc1xyXG4vLyAgICAgaW4gaGlnaHAgdmVjNCBwb3M7XHJcbiAgICBcclxuLy8gICAgIHVuaWZvcm0gZmxvYXQgdVRpbWU7XHJcbiAgICBcclxuLy8gICAgIG91dCBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XHJcbiAgICBcclxuLy8gICAgIHZvaWQgbWFpbigpXHJcbi8vICAgICB7XHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24gPSBwb3M7XHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24ueCArPSAwLjEqc2luKDYuMCp1VGltZSArIDMuMCpwb3MueSk7XHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24ueSArPSAwLjIqc2luKDYuMCp1VGltZSAtIDYuMCpwb3MueCk7XHJcbiAgICBcclxuLy8gICAgICAgICAvLyB0ZXh0dXJlIGNvb3JkaW5hdGUgaXMganVzdCBwb3MgYnV0IHdpdGhpbiAwLTEgaW5zdGVhZCBvZiAtMSB0byAxLlxyXG4vLyAgICAgICAgIC8vIFNvIHNjYWxlIGluIHRoYXQgcmFuZ2UuXHJcbi8vICAgICAgICAgdlRleHR1cmVDb29yZCA9IChwb3MueHkrMS4pKjAuNTtcclxuLy8gICAgIH1gLFxyXG4vLyAgICAgYCN2ZXJzaW9uIDMwMCBlc1xyXG4vLyAgICAgaW4gaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG4gICAgXHJcbi8vICAgICBvdXQgaGlnaHAgdmVjNCBvdXRDb2xvcjtcclxuICAgIFxyXG4vLyAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XHJcbiAgICBcclxuLy8gICAgIHZvaWQgbWFpbigpXHJcbi8vICAgICB7XHJcbi8vICAgICAgICAgLy8gb3V0Q29sb3IgPSB2ZWM0KHZUZXh0dXJlQ29vcmQueCwgMC4wLCAwLjAsIDEuMCk7XHJcbi8vICAgICAgICAgb3V0Q29sb3IgPSB0ZXh0dXJlKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsvL3ZlYzQoMSwgMCwgMC41LCAxKTtcclxuLy8gfWAsIFsndVRpbWUnXSwgWygpID0+IHtyZXR1cm4gd2luZG93LmZyYW1lcyAvIDEwMH1dKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtpbml0Tm9ubGluZWFyVHJhbnNmb3JtLCB1bkluaXROb25saW5lYXJUcmFuc2Zvcm19O1xyXG5cclxuLy8gLy8gQ09ORSBNQVBcclxuLy8gcy5pbml0RGlzdG9ydGlvbihgI3ZlcnNpb24gMzAwIGVzXHJcbi8vICAgICBpbiBoaWdocCB2ZWM0IHBvcztcclxuICAgIFxyXG4vLyAgICAgdW5pZm9ybSBmbG9hdCB1VGltZTtcclxuICAgIFxyXG4vLyAgICAgb3V0IGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcclxuICAgIFxyXG4vLyAgICAgdm9pZCBtYWluKClcclxuLy8gICAgIHtcclxuLy8gICAgICAgICBmbG9hdCBhbmdsZSA9IGF0YW4ocG9zLnksIHBvcy54KTtcclxuLy8gICAgICAgICBmbG9hdCBkaXN0ID0gc3FydChwb3MueSpwb3MueSArIHBvcy54KnBvcy54KTtcclxuXHJcbi8vICAgICAgICAgLy8gY2FsY3VsYXRpbmcgbWF4IGRpc3RhbmNlIGFsb25nIHRoZSBhbmdsZSBmcm9tIHRoZSBvcmlnaW4gdG8gZW5kIG9mIHNjcmVlblxyXG5cclxuLy8gICAgICAgICBmbG9hdCBwID0gbWF4KGFicyhjb3MoYW5nbGUpKSwgYWJzKHNpbihhbmdsZSkpKTtcclxuLy8gICAgICAgICAvLyBmbG9hdCBtYXhEaXN0QWxvbmdBbmdsZSA9IDAuNS9wO1xyXG5cclxuLy8gICAgICAgICAvLyBhYm92ZSAyIGxpbmVzIGVxdWl2YWxlbnQgdG86XHJcbi8vICAgICAgICAgZmxvYXQgeCA9IGNvcyhhbmdsZSkgLyBwO1xyXG4vLyAgICAgICAgIGZsb2F0IHkgPSBzaW4oYW5nbGUpIC8gcDtcclxuLy8gICAgICAgICBmbG9hdCBtYXhEaXN0QWxvbmdBbmdsZSA9IHNxcnQoeCp4ICsgeSp5KTtcclxuXHJcbi8vICAgICAgICAgLy8ganVzdCBzZXR0aW5nIHgseSB0byBnbF9Qb3NpdGlvbi54eSByZXN1bHRzIGluIG92YWwgc2hhcGUuIFdoYXQgd2UncmUgZG9pbmcgaXMgZXh0cnVkaW5nIHRvIDNkLlxyXG4vLyAgICAgICAgIHggPSBjb3MoYW5nbGUpICogZGlzdCAvIG1heERpc3RBbG9uZ0FuZ2xlO1xyXG4vLyAgICAgICAgIHkgPSBzaW4oYW5nbGUpICogZGlzdCAvIG1heERpc3RBbG9uZ0FuZ2xlO1xyXG4vLyAgICAgICAgIGZsb2F0IHogPSBkaXN0IC8gbWF4RGlzdEFsb25nQW5nbGU7XHJcblxyXG4vLyAgICAgICAgIGZsb2F0IGEgPSAyLjtcclxuLy8gICAgICAgICBmbG9hdCBiID0gMy4xNC80LjtcclxuXHJcbi8vICAgICAgICAgZmxvYXQgc2EgPSBzaW4oYSk7XHJcbi8vICAgICAgICAgZmxvYXQgc2IgPSBzaW4oYik7XHJcbi8vICAgICAgICAgZmxvYXQgY2EgPSBjb3MoYSk7XHJcbi8vICAgICAgICAgZmxvYXQgY2IgPSBjb3MoYik7XHJcblxyXG4vLyAgICAgICAgIGZsb2F0IGNvbmVYID0geCAqIGNhIC0geSAqIHNhO1xyXG4vLyAgICAgICAgIGZsb2F0IGNvbmVZID0gKHggKiBzYSArIHkgKiBjYSkgKiBzYiAtIHogKiBjYjtcclxuXHJcbi8vICAgICAgICAgZmxvYXQgdCA9IHVUaW1lIC0gZmxvb3IodVRpbWUpO1xyXG5cclxuLy8gICAgICAgICBnbF9Qb3NpdGlvbiA9IHBvcztcclxuLy8gICAgICAgICBnbF9Qb3NpdGlvbi54ID0gY29uZVggKiB0ICsgcG9zLnggKiAoMS4tdCk7XHJcbi8vICAgICAgICAgZ2xfUG9zaXRpb24ueSA9IGNvbmVZICogdCArIHBvcy55ICogKDEuLXQpICsgLjU7XHJcbiAgICBcclxuLy8gICAgICAgICAvLyB0ZXh0dXJlIGNvb3JkaW5hdGUgaXMganVzdCBwb3MgYnV0IHdpdGhpbiAwLTEgaW5zdGVhZCBvZiAtMSB0byAxLlxyXG4vLyAgICAgICAgIC8vIFNvIHNjYWxlIGluIHRoYXQgcmFuZ2UuXHJcbi8vICAgICAgICAgdlRleHR1cmVDb29yZCA9IChwb3MueHkrMS4pKjAuNTtcclxuLy8gICAgIH1gLFxyXG4vLyAgICAgYCN2ZXJzaW9uIDMwMCBlc1xyXG4vLyAgICAgaW4gaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG4gICAgXHJcbi8vICAgICBvdXQgaGlnaHAgdmVjNCBvdXRDb2xvcjtcclxuICAgIFxyXG4vLyAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XHJcbiAgICBcclxuLy8gICAgIHZvaWQgbWFpbigpXHJcbi8vICAgICB7XHJcbi8vICAgICAgICAgLy8gb3V0Q29sb3IgPSB2ZWM0KHZUZXh0dXJlQ29vcmQueCwgMC4wLCAwLjAsIDEuMCk7XHJcbi8vICAgICAgICAgb3V0Q29sb3IgPSB0ZXh0dXJlKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTsvL3ZlYzQoMSwgMCwgMC41LCAxKTtcclxuLy8gfWApOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///964\n')}}]);